# -*- coding: utf-8 -*-

# Created by: PyQt5 UI code generator 5.15.2 and modified by later code editing
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

# Developed by: Ligdamis A. Gutiérrez E. PhD.
# Shannon Entropy Work by Pablo Rey D.
# Entropy estimator for Characterization of Volcanic Seismic Signals

# Andalusian Institute of Geophysics,
# Signal Theory, Telematics and Communications Department,
# Department of Theoretical Physics and the Cosmos,
# Science Faculty,
# Granada University, (Ugr), Spain, 2023

# This software is the product of the research by the Spanish projects:

# a)    PID2022-143083NB-I00, “LEARNING”, funded by MCIN/AEI /10.13039/501100011033
# b)    JMI and LG were partially funded by the Spanish project PROOF-FOREVER (EUR2022.134044)
# c)    PRD was funded by the Ministerio de Ciencia e Innovación del Gobierno de España (MCIN), Agencia Estatal de Investigación (AEI), Fondo Social Europeo (FSE), and Programa Estatal de Promoción del Talento y su Empleabilidad en I+D+I Ayudas para contratos predoctorales para la formación de doctores 2020 (PRE2020-092719).
# d)    Spanish Project PID2022-143083NB-100 founded by MCIN/AEI/10.13039/501100011033 and by FEDER (EU) “Una manera de hacer Europa”.
# e)    PLEC2022-009271“"DigiVolCa”", funded by MCIN/AEI, funded by MCIN/AEI/10.13039/501100011033 and by EU «NextGenerationEU/PRTR», 10.13039/501100011033.

''' WARNING: Do not modify or edit the code without permission of the author.
    In case of using this software, indicate and refer to the author and the institution he represents.
    The University of Granada, Ugr '''

# Program: Entropy_1.py -> Entropy estimator for Characterization of Volcanic Seismic Signals

# Load libraries to use

# Library for NumPy that provides support for creating vectors and matrices
# and scipy for the stadistics
import numpy as np
import scipy.stats as stats
from scipy import ndimage, datasets
from scipy import signal

# Libraries for the use of PyQt5 - binding of the graphical Qt library
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import QApplication, QWidget, QMessageBox
from PyQt5 import QtCore, QtGui, QtWidgets, uic

# Libraries for the use Matplotlib for make Graphics
import matplotlib
import matplotlib.pyplot as plt
import matplotlib.dates as dates
import matplotlib.dates as mdates
from matplotlib.dates import DateFormatter
from matplotlib.ticker import MultipleLocator
import matplotlib.dates as mdates

# Use of the obspy Library, for seismic data processing.
# It contains routines for reading and analyzing time series of seismic records
# in the most general formats used in observatories (MSEED, SAC, etc.)
from obspy import read, Stream

# for use de time
import datetime
from datetime import date, timedelta
from datetime import date, time, datetime

# For system use, threads and paths (path)
import sys
import os
import csv
import subprocess
import pathlib
from pathlib import Path

# Identify the operating system
import platform
sistema = platform.system()  # Identify the operating system

# Libraries to use tkinter (Graphical interface)
import tkinter
from tkinter import *
import tkinter as tk
from tkinter.ttk import Combobox, Style
from tkinter import Frame, IntVar, Label, filedialog, Entry, Radiobutton, CURRENT

# For use the window as root (changes later)
root = tk.Tk()
root.withdraw()


class Ui_MainWindow(object):                            # Main Class of Program Ui_MainWindow, Object: MainWindow.
    def setupUi(self, MainWindow):                      # Main function class and MainWindow object.
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(1099, 471)

        icon = QtGui.QIcon()
        # Loading the Ugr image on the canvas
        icon.addPixmap(QtGui.QPixmap(r"Images/Ugr.gif"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        MainWindow.setWindowIcon(icon)
        MainWindow.setToolTip("")

        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")


        # Set frame group

        self.frame = QtWidgets.QFrame(self.centralwidget)
        self.frame.setGeometry(QtCore.QRect(10, 10, 1081, 231))
        palette = QtGui.QPalette()
        brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Base, brush)
        brush = QtGui.QBrush(QtGui.QColor(216, 225, 240))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Window, brush)
        brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Base, brush)
        brush = QtGui.QBrush(QtGui.QColor(216, 225, 240))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Window, brush)
        brush = QtGui.QBrush(QtGui.QColor(216, 225, 240))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Base, brush)
        brush = QtGui.QBrush(QtGui.QColor(216, 225, 240))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Window, brush)
        self.frame.setPalette(palette)
        self.frame.setAutoFillBackground(True)
        self.frame.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.frame.setFrameShadow(QtWidgets.QFrame.Plain)
        self.frame.setObjectName("frame")

        # Set Fame_2 group

        self.frame_2 = QtWidgets.QFrame(self.centralwidget)
        self.frame_2.setGeometry(QtCore.QRect(10, 250, 901, 201))
        palette = QtGui.QPalette()
        brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Base, brush)
        brush = QtGui.QBrush(QtGui.QColor(240, 228, 181))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Window, brush)
        brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Base, brush)
        brush = QtGui.QBrush(QtGui.QColor(240, 228, 181))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Window, brush)
        brush = QtGui.QBrush(QtGui.QColor(240, 228, 181))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Base, brush)
        brush = QtGui.QBrush(QtGui.QColor(240, 228, 181))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Window, brush)
        self.frame_2.setPalette(palette)
        self.frame_2.setAutoFillBackground(True)
        self.frame_2.setFrameShape(QtWidgets.QFrame.Panel)
        self.frame_2.setFrameShadow(QtWidgets.QFrame.Raised)
        self.frame_2.setObjectName("frame_2")

        # Set labels from frame 2

        self.label_5 = QtWidgets.QLabel(self.frame_2)
        self.label_5.setGeometry(QtCore.QRect(10, 30, 881, 41))
        palette = QtGui.QPalette()
        brush = QtGui.QBrush(QtGui.QColor(0, 0, 0))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.WindowText, brush)
        brush = QtGui.QBrush(QtGui.QColor(170, 255, 255))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Window, brush)
        brush = QtGui.QBrush(QtGui.QColor(0, 0, 0))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.WindowText, brush)
        brush = QtGui.QBrush(QtGui.QColor(170, 255, 255))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Window, brush)
        brush = QtGui.QBrush(QtGui.QColor(120, 120, 120))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.WindowText, brush)
        brush = QtGui.QBrush(QtGui.QColor(240, 240, 240))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Window, brush)
        self.label_5.setPalette(palette)
        self.label_5.setAutoFillBackground(True)
        self.label_5.setFrameShape(QtWidgets.QFrame.Panel)
        self.label_5.setFrameShadow(QtWidgets.QFrame.Raised)
        self.label_5.setText("")
        self.label_5.setObjectName("label_5")

        self.label_6 = QtWidgets.QLabel(self.frame_2)
        self.label_6.setGeometry(QtCore.QRect(30, 10, 171, 16))
        self.label_6.setObjectName("label_6")

        self.line_5 = QtWidgets.QFrame(self.frame_2)
        self.line_5.setGeometry(QtCore.QRect(0, 90, 1081, 16))
        self.line_5.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_5.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_5.setObjectName("line_5")

        self.label_7 = QtWidgets.QLabel(self.frame_2)
        self.label_7.setGeometry(QtCore.QRect(30, 110, 451, 16))
        self.label_7.setObjectName("label_7")

        self.label_8 = QtWidgets.QLabel(self.frame_2)
        self.label_8.setGeometry(QtCore.QRect(10, 140, 881, 41))
        palette = QtGui.QPalette()
        brush = QtGui.QBrush(QtGui.QColor(0, 0, 0))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.WindowText, brush)
        brush = QtGui.QBrush(QtGui.QColor(220, 245, 220))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Window, brush)
        brush = QtGui.QBrush(QtGui.QColor(0, 0, 0))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.WindowText, brush)
        brush = QtGui.QBrush(QtGui.QColor(220, 245, 220))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Window, brush)
        brush = QtGui.QBrush(QtGui.QColor(120, 120, 120))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.WindowText, brush)
        brush = QtGui.QBrush(QtGui.QColor(240, 240, 240))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Window, brush)
        self.label_8.setPalette(palette)
        self.label_8.setAutoFillBackground(True)
        self.label_8.setFrameShape(QtWidgets.QFrame.Panel)
        self.label_8.setFrameShadow(QtWidgets.QFrame.Raised)
        self.label_8.setText("")
        self.label_8.setObjectName("label_8")


        # Set line from frame group ***

        self.line = QtWidgets.QFrame(self.frame)
        self.line.setGeometry(QtCore.QRect(133, 0, 20, 231))
        self.line.setFrameShape(QtWidgets.QFrame.VLine)
        self.line.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line.setObjectName("line")

        self.line_2 = QtWidgets.QFrame(self.frame)
        self.line_2.setGeometry(QtCore.QRect(670, 118, 20, 111))
        self.line_2.setFrameShape(QtWidgets.QFrame.VLine)
        self.line_2.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_2.setObjectName("line_2")

        self.line_4 = QtWidgets.QFrame(self.frame)
        self.line_4.setGeometry(QtCore.QRect(784, 0, 20, 231))
        self.line_4.setFrameShape(QtWidgets.QFrame.VLine)
        self.line_4.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_4.setObjectName("line_4")

        self.line_11 = QtWidgets.QFrame(self.frame)
        self.line_11.setGeometry(QtCore.QRect(145, 110, 649, 16))
        self.line_11.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_11.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_11.setObjectName("line_11")

        self.line_13 = QtWidgets.QFrame(self.frame)
        self.line_13.setGeometry(QtCore.QRect(794, 130, 291, 20))
        self.line_13.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_13.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_13.setObjectName("line_13")

        self.line_14 = QtWidgets.QFrame(self.frame)
        self.line_14.setGeometry(QtCore.QRect(525, 118, 20, 111))
        self.line_14.setFrameShape(QtWidgets.QFrame.VLine)
        self.line_14.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_14.setObjectName("line_14")

        self.line_15 = QtWidgets.QFrame(self.frame)
        self.line_15.setGeometry(QtCore.QRect(340, 118, 20, 111))
        self.line_15.setFrameShape(QtWidgets.QFrame.VLine)
        self.line_15.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_15.setObjectName("line_15")


        # Set pushButtons from frame group ***

        self.pushButton = QtWidgets.QPushButton(self.frame)                     # Command Button (load records)
        self.pushButton.setGeometry(QtCore.QRect(270, 70, 98, 31))
        palette = QtGui.QPalette()
        brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Button, brush)
        brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Window, brush)
        brush = QtGui.QBrush(QtGui.QColor(240, 240, 240))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Button, brush)
        brush = QtGui.QBrush(QtGui.QColor(240, 240, 240))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Window, brush)
        brush = QtGui.QBrush(QtGui.QColor(240, 240, 240))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Button, brush)
        brush = QtGui.QBrush(QtGui.QColor(240, 240, 240))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Window, brush)
        self.pushButton.setPalette(palette)
        self.pushButton.setAutoFillBackground(True)
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap(r"Images/Load.gif"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.pushButton.setIcon(icon)
        self.pushButton.setObjectName("pushButton")

        self.pushButton_2 = QtWidgets.QPushButton(self.frame)                   # Command Button (store CSV and NPY file output)
        self.pushButton_2.setGeometry(QtCore.QRect(462, 70, 112, 31))
        palette = QtGui.QPalette()
        brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Button, brush)
        brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Window, brush)
        brush = QtGui.QBrush(QtGui.QColor(240, 240, 240))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Button, brush)
        brush = QtGui.QBrush(QtGui.QColor(240, 240, 240))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Window, brush)
        brush = QtGui.QBrush(QtGui.QColor(240, 240, 240))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Button, brush)
        brush = QtGui.QBrush(QtGui.QColor(240, 240, 240))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Window, brush)
        self.pushButton_2.setPalette(palette)
        self.pushButton_2.setAutoFillBackground(True)
        icon1 = QtGui.QIcon()
        icon1.addPixmap(QtGui.QPixmap(r"Images/Store1.gif"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.pushButton_2.setIcon(icon1)
        self.pushButton_2.setObjectName("pushButton_2")

        self.pushButton_3 = QtWidgets.QPushButton(self.frame)                   # Command Button (Plot Entropy)
        self.pushButton_3.setGeometry(QtCore.QRect(665, 70, 115, 31))
        icon2 = QtGui.QIcon()
        icon2.addPixmap(QtGui.QPixmap(r"Images/Plot.gif"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.pushButton_3.setIcon(icon2)
        self.pushButton_3.setObjectName("pushButton_3")

        # Set radio Button and checkBox from frame group ***

        self.radioButton = QtWidgets.QRadioButton(self.frame)
        self.radioButton.setGeometry(QtCore.QRect(360, 180, 51, 17))
        self.radioButton.setPalette(palette)
        font = QtGui.QFont()
        font.setFamily("Times New Roman")
        font.setPointSize(7)
        font.setBold(True)
        font.setWeight(75)
        self.radioButton.setFont(font)
        self.radioButton.setChecked(False)
        self.radioButton.setObjectName("radioButton")

        self.radioButton_2 = QtWidgets.QRadioButton(self.frame)
        self.radioButton_2.setGeometry(QtCore.QRect(425, 180, 51, 17))
        self.radioButton_2.setPalette(palette)
        font = QtGui.QFont()
        font.setFamily("Times New Roman")
        font.setPointSize(7)
        font.setBold(True)
        font.setWeight(75)
        self.radioButton_2.setFont(font)
        self.radioButton_2.setChecked(True)
        self.radioButton_2.setObjectName("radioButton_2")

        self.radioButton_3 = QtWidgets.QRadioButton(self.frame)
        self.radioButton_3.setGeometry(QtCore.QRect(480, 180, 51, 17))
        self.radioButton_3.setPalette(palette)
        font = QtGui.QFont()
        font.setFamily("Times New Roman")
        font.setPointSize(7)
        font.setBold(True)
        font.setWeight(75)
        self.radioButton_3.setFont(font)
        self.radioButton_3.setChecked(False)
        self.radioButton_3.setObjectName("radioButton_3")

        self.checkBox = QtWidgets.QCheckBox(self.frame)
        self.checkBox.setGeometry(QtCore.QRect(619, 130, 70, 17))
        self.checkBox.setPalette(palette)
        font = QtGui.QFont()
        font.setFamily("Times New Roman")
        font.setPointSize(7)
        font.setBold(True)
        font.setWeight(75)
        self.checkBox.setFont(font)
        self.checkBox.setChecked(False)
        self.checkBox.setObjectName("checkBox")

        self.checkBox_2 = QtWidgets.QCheckBox(self.frame)
        self.checkBox_2.setGeometry(QtCore.QRect(742, 124, 70, 17))
        self.checkBox_2.setPalette(palette)
        font = QtGui.QFont()
        font.setFamily("Times New Roman")
        font.setPointSize(7)
        font.setBold(True)
        font.setWeight(75)
        self.checkBox_2.setFont(font)
        self.checkBox_2.setChecked(False)
        self.checkBox_2.setObjectName("checkBox_2")

        # Set comboBox_2 from frame group ***

        self.groupBox_2 = QtWidgets.QGroupBox(self.frame)
        self.groupBox_2.setGeometry(QtCore.QRect(820, 10, 211, 101))
        palette = QtGui.QPalette()
        brush = QtGui.QBrush(QtGui.QColor(240, 255, 247))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Window, brush)
        brush = QtGui.QBrush(QtGui.QColor(240, 255, 247))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Window, brush)
        brush = QtGui.QBrush(QtGui.QColor(240, 255, 247))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Window, brush)
        self.groupBox_2.setPalette(palette)
        self.groupBox_2.setAutoFillBackground(True)
        self.groupBox_2.setObjectName("groupBox_2")
        self.comboBox_2 = QtWidgets.QComboBox(self.groupBox_2)
        self.comboBox_2.setGeometry(QtCore.QRect(10, 20, 191, 22))
        self.comboBox_2.setObjectName("comboBox_2")
        self.comboBox_2.addItem("")
        self.comboBox_2.addItem("")
        self.comboBox_2.addItem("")
        self.comboBox_2.addItem("")
        self.comboBox_2.addItem("")


        # Set Labels from frame group ***

        self.label = QtWidgets.QLabel(self.frame)
        self.label.setGeometry(QtCore.QRect(40, 20, 71, 61))
        self.label.setText("")
        self.label.setPixmap(QtGui.QPixmap(r"Images/Ugr.gif"))
        self.label.setScaledContents(True)
        self.label.setObjectName("label")

        self.label_2 = QtWidgets.QLabel(self.frame)
        self.label_2.setGeometry(QtCore.QRect(40, 160, 67, 61))
        self.label_2.setText("")
        self.label_2.setPixmap(QtGui.QPixmap(r"Images/IAG.gif"))
        self.label_2.setScaledContents(True)
        self.label_2.setObjectName("label_2")

        self.label_3 = QtWidgets.QLabel(self.frame)
        self.label_3.setGeometry(QtCore.QRect(150, 0, 635, 41))
        font = QtGui.QFont()
        font.setFamily("Times New Roman")
        font.setPointSize(36)
        font.setBold(True)
        font.setItalic(True)
        font.setWeight(75)
        self.label_3.setFont(font)
        self.label_3.setObjectName("label_3")

        self.label_18 = QtWidgets.QLabel(self.frame)
        self.label_18.setGeometry(QtCore.QRect(880, 200, 61, 16))
        font = QtGui.QFont()
        font.setPointSize(7)
        self.label_18.setFont(font)
        self.label_18.setObjectName("label_18")

        self.label_19 = QtWidgets.QLabel(self.frame)
        self.label_19.setGeometry(QtCore.QRect(880, 160, 71, 16))
        self.label_19.setObjectName("label_19")

        self.label_20 = QtWidgets.QLabel(self.frame)
        self.label_20.setGeometry(QtCore.QRect(960, 190, 61, 16))
        self.label_20.setObjectName("label_20")

        self.label_21 = QtWidgets.QLabel(self.frame)
        self.label_21.setGeometry(QtCore.QRect(960, 160, 61, 16))
        self.label_21.setObjectName("label_21")

        self.label_22 = QtWidgets.QLabel(self.frame)
        self.label_22.setGeometry(QtCore.QRect(800, 160, 61, 16))
        self.label_22.setObjectName("label_22")

        self.label_23 = QtWidgets.QLabel(self.frame)
        self.label_23.setGeometry(QtCore.QRect(150, 150, 111, 20))
        self.label_23.setObjectName("label_23")

        self.label_24 = QtWidgets.QLabel(self.frame)
        self.label_24.setGeometry(QtCore.QRect(360, 40, 251, 16))
        self.label_24.setObjectName("label_24")

        self.label_25 = QtWidgets.QLabel(self.frame)
        self.label_25.setGeometry(QtCore.QRect(170, 75, 91, 21))
        self.label_25.setObjectName("label_25")

        self.label_26 = QtWidgets.QLabel(self.frame)
        self.label_26.setGeometry(QtCore.QRect(385, 75, 61, 21))
        self.label_26.setObjectName("label_26")

        self.label_27 = QtWidgets.QLabel(self.frame)
        self.label_27.setGeometry(QtCore.QRect(385, 160, 121, 21))
        self.label_27.setObjectName("label_27")

        self.label_28 = QtWidgets.QLabel(self.frame)
        self.label_28.setGeometry(QtCore.QRect(365, 130, 201, 16))
        self.label_28.setObjectName("label_28")

        self.label_29 = QtWidgets.QLabel(self.frame)
        self.label_29.setGeometry(QtCore.QRect(275, 178, 71, 16))
        font = QtGui.QFont()
        font.setPointSize(7)
        self.label_29.setFont(font)
        self.label_29.setObjectName("label_29")

        self.label_30 = QtWidgets.QLabel(self.frame)
        self.label_30.setGeometry(QtCore.QRect(400, 200, 71, 16))
        font = QtGui.QFont()
        font.setPointSize(7)
        self.label_30.setFont(font)
        self.label_30.setObjectName("label_30")

        self.label_31 = QtWidgets.QLabel(self.frame)
        self.label_31.setGeometry(QtCore.QRect(684, 123, 60, 21))
        self.label_31.setObjectName("label_31")

        self.label_32 = QtWidgets.QLabel(self.frame)
        self.label_32.setGeometry(QtCore.QRect(275, 152, 71, 16))
        font = QtGui.QFont()
        font.setPointSize(7)
        self.label_32.setFont(font)
        self.label_32.setObjectName("label_32")

        self.label_33 = QtWidgets.QLabel(self.frame)
        self.label_33.setGeometry(QtCore.QRect(198, 125, 201, 16))
        self.label_33.setObjectName("label_33")

        self.label_34 = QtWidgets.QLabel(self.frame)
        self.label_34.setGeometry(QtCore.QRect(150, 178, 201, 16))
        self.label_34.setObjectName("label_34")

        self.label_35 = QtWidgets.QLabel(self.frame)
        self.label_35.setGeometry(QtCore.QRect(150, 203, 201, 16))
        self.label_35.setObjectName("label_35")

        self.label_36 = QtWidgets.QLabel(self.frame)
        self.label_36.setGeometry(QtCore.QRect(275, 205, 71, 16))
        font = QtGui.QFont()
        font.setPointSize(7)
        self.label_36.setFont(font)
        self.label_36.setObjectName("label_36")

        self.label_37 = QtWidgets.QLabel(self.frame)   # Initial Year
        self.label_37.setGeometry(QtCore.QRect(686, 145, 110, 21))
        self.label_37.setObjectName("label_37")

        self.label_38 = QtWidgets.QLabel(self.frame)   # (YYYY)
        self.label_38.setGeometry(QtCore.QRect(759, 145, 111, 20))
        font = QtGui.QFont()
        font.setPointSize(7)
        self.label_38.setFont(font)
        self.label_38.setObjectName("label_38")

        self.label_39 = QtWidgets.QLabel(self.frame)   # Initial Month
        self.label_39.setGeometry(QtCore.QRect(685, 171, 111, 20))
        font = QtGui.QFont()
        font.setPointSize(7)
        self.label_39.setFont(font)
        self.label_39.setObjectName("label_39")

        self.label_40 = QtWidgets.QLabel(self.frame)   # (MM)
        self.label_40.setGeometry(QtCore.QRect(757, 171, 110, 21))
        self.label_40.setObjectName("label_40")

        self.label_41 = QtWidgets.QLabel(self.frame)
        self.label_41.setGeometry(QtCore.QRect(594, 70, 71, 31))
        self.label_41.setObjectName("label_41")

        self.label_42 = QtWidgets.QLabel(self.frame)
        self.label_42.setGeometry(QtCore.QRect(543, 128, 60, 21))
        self.label_42.setObjectName("label_42")

        self.label_43 = QtWidgets.QLabel(self.frame)
        self.label_43.setGeometry(QtCore.QRect(545, 165, 60, 21))
        self.label_43.setObjectName("label_43")

        self.label_44 = QtWidgets.QLabel(self.frame)
        self.label_44.setGeometry(QtCore.QRect(545, 195, 60, 21))
        self.label_44.setObjectName("label_44")

        self.label_45 = QtWidgets.QLabel(self.frame)
        self.label_45.setGeometry(QtCore.QRect(628, 197, 71, 16))
        font = QtGui.QFont()
        font.setPointSize(7)
        self.label_45.setFont(font)
        self.label_45.setObjectName("label_45")

        self.label_46 = QtWidgets.QLabel(self.frame)
        self.label_46.setGeometry(QtCore.QRect(628, 165, 71, 16))
        font = QtGui.QFont()
        font.setPointSize(7)
        self.label_46.setFont(font)
        self.label_46.setObjectName("label_46")

        self.label_47 = QtWidgets.QLabel(self.frame)
        self.label_47.setGeometry(QtCore.QRect(40, 90, 65, 65))
        self.label_47.setText("")
        self.label_47.setPixmap(QtGui.QPixmap(r"Images/LogoTSTC.gif"))
        self.label_47.setScaledContents(True)
        self.label_47.setObjectName("label_47")

        self.label_48 = QtWidgets.QLabel(self.frame)   # Initial Day
        self.label_48.setGeometry(QtCore.QRect(687, 197, 111, 20))
        font = QtGui.QFont()
        font.setPointSize(7)
        self.label_48.setFont(font)
        self.label_48.setObjectName("label_48")

        self.label_49 = QtWidgets.QLabel(self.frame)    # (DD)
        self.label_49.setGeometry(QtCore.QRect(761, 197, 110, 21))
        self.label_49.setObjectName("label_49")

        self.label_50 = QtWidgets.QLabel(self.frame)    # e.g.(YYYMMDD)
        self.label_50.setGeometry(QtCore.QRect(693, 214, 110, 21))
        self.label_50.setObjectName("label_50")

        # Set lineEdit from frame group ***

        self.lineEdit_5 = QtWidgets.QLineEdit(self.frame)               # Smoothing type
        self.lineEdit_5.setGeometry(QtCore.QRect(230, 175, 41, 20))
        # Qt.ImhFormattedNumbersOnly -> Only allows the use of numbers including decimals and sign (-)
        self.lineEdit_5.setInputMethodHints(QtCore.Qt.ImhFormattedNumbersOnly)
        rx2  = QtCore.QRegExp("[0-3]{99}")      # Format to only allow 3 integers
        val2 = QtGui.QRegExpValidator(rx2)
        self.lineEdit_5.setValidator(val2)
        self.lineEdit_5.setInputMethodHints(QtCore.Qt.ImhPreferNumbers)
        self.lineEdit_5.setText("")
        self.lineEdit_5.setAlignment(QtCore.Qt.AlignCenter)              # <----- To Align text
        self.lineEdit_5.setDragEnabled(False)
        self.lineEdit_5.setValidator(val2)
        self.lineEdit_5.setObjectName("lineEdit_5")

        self.lineEdit_6 = QtWidgets.QLineEdit(self.frame)
        self.lineEdit_6.setGeometry(QtCore.QRect(810, 180, 51, 20))
        self.lineEdit_6.setInputMethodHints(QtCore.Qt.ImhPreferNumbers)
        self.lineEdit_6.setAlignment(QtCore.Qt.AlignCenter)
        self.lineEdit_6.setObjectName("lineEdit_6")

        self.lineEdit_7 = QtWidgets.QLineEdit(self.frame)
        self.lineEdit_7.setGeometry(QtCore.QRect(890, 180, 41, 20))
        self.lineEdit_7.setAlignment(QtCore.Qt.AlignCenter)
        self.lineEdit_7.setInputMethodHints(QtCore.Qt.ImhPreferNumbers)
        self.lineEdit_7.setObjectName("lineEdit_7")

        self.lineEdit_8 = QtWidgets.QLineEdit(self.frame)
        self.lineEdit_8.setGeometry(QtCore.QRect(1030, 160, 41, 20))
        self.lineEdit_8.setAlignment(QtCore.Qt.AlignCenter)
        self.lineEdit_8.setInputMethodHints(QtCore.Qt.ImhPreferNumbers)
        self.lineEdit_8.setObjectName("lineEdit_8")

        self.lineEdit_9 = QtWidgets.QLineEdit(self.frame)
        self.lineEdit_9.setGeometry(QtCore.QRect(1030, 190, 41, 20))
        self.lineEdit_9.setInputMethodHints(QtCore.Qt.ImhPreferNumbers)
        self.lineEdit_9.setAlignment(QtCore.Qt.AlignCenter)
        self.lineEdit_9.setObjectName("lineEdit_9")

        self.lineEdit_10 = QtWidgets.QLineEdit(self.frame)
        self.lineEdit_10.setGeometry(QtCore.QRect(230, 150, 41, 20))
        self.lineEdit_10.setInputMethodHints(QtCore.Qt.ImhPreferNumbers)
        rx2  = QtCore.QRegExp("[0-3]{999}")      # Format to only allow 3 integers
        val2 = QtGui.QRegExpValidator(rx2)
        self.lineEdit_10.setValidator(val2)
        self.lineEdit_10.setText("")
        self.lineEdit_10.setAlignment(QtCore.Qt.AlignCenter)              # <----- Text AlignCenter
        self.lineEdit_10.setDragEnabled(False)
        self.lineEdit_10.setValidator(val2)
        self.lineEdit_10.setObjectName("lineEdit_10")

        self.lineEdit_11 = QtWidgets.QLineEdit(self.frame)
        self.lineEdit_11.setGeometry(QtCore.QRect(580, 165, 41, 20))
        # Qt.ImhFormattedNumbersOnly -> Only allows the use of numbers including decimals and sign (-)
        self.lineEdit_11.setInputMethodHints(QtCore.Qt.ImhFormattedNumbersOnly)
        #rx2  = QtCore.QRegExp("[0-3]{999}")      # Format to only allow 3 integers
        #val2 = QtGui.QRegExpValidator(rx2)
        #self.lineEdit_11.setValidator(val2)
        self.lineEdit_11.setInputMethodHints(QtCore.Qt.ImhPreferNumbers)
        self.lineEdit_11.setText("")
        self.lineEdit_11.setAlignment(QtCore.Qt.AlignCenter)              # <----- To Align text
        self.lineEdit_11.setDragEnabled(False)
        self.lineEdit_11.setValidator(QtGui.QIntValidator(1, 999))
        #self.lineEdit_11.setValidator(val2)
        self.lineEdit_11.setObjectName("lineEdit_11")

        self.lineEdit_12 = QtWidgets.QLineEdit(self.frame)
        self.lineEdit_12.setGeometry(QtCore.QRect(580, 195, 41, 20))
        # Qt.ImhFormattedNumbersOnly -> Only allows the use of numbers including decimals and sign (-)
        self.lineEdit_12.setInputMethodHints(QtCore.Qt.ImhFormattedNumbersOnly)
        rx2  = QtCore.QRegExp("[0-3]{999}")      # Format to only allow 3 integers
        val2 = QtGui.QRegExpValidator(rx2)
        self.lineEdit_12.setValidator(val2)
        self.lineEdit_12.setInputMethodHints(QtCore.Qt.ImhPreferNumbers)
        self.lineEdit_12.setValidator(QtGui.QIntValidator(1, 999))
        self.lineEdit_12.setText("")
        self.lineEdit_12.setAlignment(QtCore.Qt.AlignCenter)              # <----- To Align text
        self.lineEdit_12.setDragEnabled(False)
        self.lineEdit_12.setValidator(val2)
        self.lineEdit_12.setObjectName("lineEdit_12")

        self.lineEdit_13 = QtWidgets.QLineEdit(self.frame)               # NaN Tolerance
        self.lineEdit_13.setGeometry(QtCore.QRect(230, 202, 41, 20))
        # Qt.ImhFormattedNumbersOnly -> Only allows the use of numbers including decimals and sign (-)
        self.lineEdit_13.setInputMethodHints(QtCore.Qt.ImhFormattedNumbersOnly)
        rx2  = QtCore.QRegExp("[0-3]{999}")      # Format to only allow 3 integers
        val2 = QtGui.QRegExpValidator(rx2)
        self.lineEdit_13.setValidator(val2)
        self.lineEdit_13.setInputMethodHints(QtCore.Qt.ImhPreferNumbers)
        self.lineEdit_13.setText("")
        self.lineEdit_13.setAlignment(QtCore.Qt.AlignCenter)              # <----- To Align text
        self.lineEdit_13.setDragEnabled(False)
        self.lineEdit_13.setValidator(val2)
        self.lineEdit_13.setObjectName("lineEdit_13")

        self.lineEdit_14 = QtWidgets.QLineEdit(self.frame)               # Initial Year
        self.lineEdit_14.setGeometry(QtCore.QRect(714, 146, 41, 20))
        # Qt.ImhFormattedNumbersOnly -> Only allows the use of numbers including decimals and sign (-)
        self.lineEdit_14.setInputMethodHints(QtCore.Qt.ImhFormattedNumbersOnly)
        rx2  = QtCore.QRegExp("[0-3]{9999}")      # Format to only allow 3 integers
        val2 = QtGui.QRegExpValidator(rx2)
        self.lineEdit_14.setValidator(val2)
        self.lineEdit_14.setInputMethodHints(QtCore.Qt.ImhPreferNumbers)
        self.lineEdit_14.setText("")
        self.lineEdit_14.setAlignment(QtCore.Qt.AlignCenter)              # <----- To Align text
        self.lineEdit_14.setDragEnabled(False)
        self.lineEdit_14.setValidator(val2)
        self.lineEdit_14.setObjectName("lineEdit_14")

        self.lineEdit_15 = QtWidgets.QLineEdit(self.frame)               # Initial Month
        self.lineEdit_15.setGeometry(QtCore.QRect(714, 170, 41, 20))
        # Qt.ImhFormattedNumbersOnly -> Only allows the use of numbers including decimals and sign (-)
        self.lineEdit_15.setInputMethodHints(QtCore.Qt.ImhFormattedNumbersOnly)
        rx2  = QtCore.QRegExp("[0-3]{99}")      # Format to only allow 3 integers
        val2 = QtGui.QRegExpValidator(rx2)
        self.lineEdit_15.setValidator(val2)
        self.lineEdit_15.setInputMethodHints(QtCore.Qt.ImhPreferNumbers)
        self.lineEdit_15.setText("")
        self.lineEdit_15.setAlignment(QtCore.Qt.AlignCenter)              # <----- To Align text
        self.lineEdit_15.setDragEnabled(False)
        self.lineEdit_15.setValidator(val2)
        self.lineEdit_15.setObjectName("lineEdit_15")

        self.lineEdit_16 = QtWidgets.QLineEdit(self.frame)               # Initial Day
        self.lineEdit_16.setGeometry(QtCore.QRect(714, 196, 41, 20))
        # Qt.ImhFormattedNumbersOnly -> Only allows the use of numbers including decimals and sign (-)
        self.lineEdit_16.setInputMethodHints(QtCore.Qt.ImhFormattedNumbersOnly)
        rx2  = QtCore.QRegExp("[0-3]{999}")      # Format to only allow 3 integers
        val2 = QtGui.QRegExpValidator(rx2)
        self.lineEdit_16.setValidator(val2)
        self.lineEdit_16.setInputMethodHints(QtCore.Qt.ImhPreferNumbers)
        self.lineEdit_16.setText("")
        self.lineEdit_16.setAlignment(QtCore.Qt.AlignCenter)              # <----- To Align text
        self.lineEdit_16.setDragEnabled(False)
        self.lineEdit_16.setValidator(val2)
        self.lineEdit_16.setObjectName("lineEdit_16")

        # Frame_5 group ***

        self.frame_5 = QtWidgets.QFrame(self.centralwidget)
        self.frame_5.setGeometry(QtCore.QRect(920, 250, 171, 201))
        palette = QtGui.QPalette()
        brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Base, brush)
        brush = QtGui.QBrush(QtGui.QColor(216, 225, 240))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Window, brush)
        brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Base, brush)
        brush = QtGui.QBrush(QtGui.QColor(216, 225, 240))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Window, brush)
        brush = QtGui.QBrush(QtGui.QColor(216, 225, 240))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Base, brush)
        brush = QtGui.QBrush(QtGui.QColor(216, 225, 240))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Window, brush)
        self.frame_5.setPalette(palette)
        self.frame_5.setAutoFillBackground(True)
        self.frame_5.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.frame_5.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.frame_5.setObjectName("frame_5")

        # Set line from frame_5 group

        self.line_15 = QtWidgets.QFrame(self.frame_5)
        self.line_15.setGeometry(QtCore.QRect(0, 70, 171, 16))
        self.line_15.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_15.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_15.setObjectName("line_15")

        self.line_16 = QtWidgets.QFrame(self.frame_5)
        self.line_16.setGeometry(QtCore.QRect(0, 140, 171, 16))
        self.line_16.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_16.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_16.setObjectName("line_16")

        # Set pushButtons  from Frame_5 group ***

        self.pushButton_4 = QtWidgets.QPushButton(self.frame_5)                 # Command Button (Clean inputs)
        self.pushButton_4.setGeometry(QtCore.QRect(40, 25, 91, 31))
        icon3 = QtGui.QIcon()
        icon3.addPixmap(QtGui.QPixmap(r"Images/Clean.gif"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.pushButton_4.setIcon(icon3)
        self.pushButton_4.setObjectName("pushButton_4")

        self.pushButton_5 = QtWidgets.QPushButton(self.frame_5)                 # Command Button (Exit)
        self.pushButton_5.setGeometry(QtCore.QRect(40, 160, 91, 31))
        icon4 = QtGui.QIcon()
        icon4.addPixmap(QtGui.QPixmap(r"Images/Exit.gif"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.pushButton_5.setIcon(icon4)
        self.pushButton_5.setObjectName("pushButton_5")

        self.pushButton_6 = QtWidgets.QPushButton(self.frame_5)                 # Command Button (Back)
        self.pushButton_6.setGeometry(QtCore.QRect(40, 95, 91, 31))
        icon3 = QtGui.QIcon()
        icon3.addPixmap(QtGui.QPixmap(r"Images/Back.gif"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.pushButton_6.setIcon(icon3)
        self.pushButton_6.setObjectName("pushButton_6")


        MainWindow.setCentralWidget(self.centralwidget)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

        # Color and text formatting on Command Buttons
        self.pushButton.setStyleSheet("background-color: honeydew; color: blue")                # Text and Color of the Command Button (load records)
        self.pushButton_2.setStyleSheet("background-color: silver; color: blue")                # Text and Color of the Command Button (store CSV and NPY file output)
        self.pushButton_3.setStyleSheet("background-color: skyblue; color: blue")               # Text and Color of the Command Button (Plot Entropy)
        self.pushButton_4.setStyleSheet("background-color: bisque; color: blue")                # Text and Color of the Command Button (Clean inputs)
        self.pushButton_5.setStyleSheet("background-color: CornflowerBlue; color: white")       # Text and Color of the Command Button (Exit)
        self.pushButton_6.setStyleSheet("background-color: honeydew; color: blue")              # Text and Color of the Command Button (Back)


    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "Entropy, Kurtosis and Frequency Index estimator for Characterization of Volcanic Seismic Signals -  Granada University (Ugr)"))
        self.label_6.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" color:#142cc8;\">Directory to upload records:</span></p></body></html>"))
        self.label_7.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" color:#142cc8;\">Directory to store the CSV file: Please, make sure the old CSV file does not exist or is closed.</span></p></body></html>"))
        self.label_3.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:10pt; font-weight:490; color:#0000ff;\">Shannon Entropy, Kurtosis and Frequency Index. Application method for Volcanic Seismic Signals</span></p></body></html>"))

        # PushButton Labels
        self.pushButton.setText(_translate("MainWindow", "Load Records"))
        self.pushButton_2.setText(_translate("MainWindow", "CSV and NPY File"))
        self.pushButton_3.setText(_translate("MainWindow", " Plot Calculations"))
        self.pushButton_4.setText(_translate("MainWindow", "Clear entries"))
        self.pushButton_5.setText(_translate("MainWindow", "  Exit"))
        self.pushButton_6.setText(_translate("MainWindow", "  Go Back"))

        # PushButton ToolTip
        self.pushButton.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-weight:600; color:#00007f;\">Load Records</span></p></body></html>"))
        self.pushButton_2.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:7pt; font-weight:500; color:#00007f;\">Store CSV and NPY file</span></p></body></html>"))
        self.pushButton_3.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-weight:600; color:#00007f;\">Plot Results</span></p></body></html>"))
        self.pushButton_4.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-weight:600; color:#00007f;\">Clear inputs</span></p></body></html>"))
        self.pushButton_5.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-weight:600; color:#aa0000;\">Exit</span></p></body></html>"))
        self.pushButton_6.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-weight:600; color:#00007f;\"> Go Back</span></p></body></html>"))   # Go Back

        self.groupBox_2.setTitle(_translate("MainWindow", "Filter type"))
        self.comboBox_2.setItemText(0, _translate("MainWindow", "Please select"))
        self.comboBox_2.setItemText(1, _translate("MainWindow", "Lowpass"))
        self.comboBox_2.setItemText(2, _translate("MainWindow", "Highpass"))
        self.comboBox_2.setItemText(3, _translate("MainWindow", "Bandpass"))
        self.comboBox_2.setItemText(4, _translate("MainWindow", "Bandstop"))

        self.label_18.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:6pt; font-weight:600; font-style:italic; color:#00007f;\">By default = 4</span></p></body></html>"))
        self.label_19.setText(_translate("MainWindow", "<html><head/><body><p align=\"center\"><span style=\" font-size:7pt; font-weight:600; font-style:italic; color:#aa5500;\">Filter Order</span></p></body></html>"))
        self.label_20.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:6pt; font-weight:600; font-style:italic; color:#aa5500;\">Frec Max (Hz):</span></p></body></html>"))
        self.label_21.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:6pt; font-weight:600; font-style:italic; color:#aa5500;\">Frec Min (Hz):</span></p></body></html>"))
        self.label_22.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:6pt; font-weight:600; color:#0055ff;\">Frequency (Hz)</span></p></body></html>"))
        self.label_23.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" color:#0000ff;\">Window width</span></p></body></html>"))
        self.label_24.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" color:#0000ff;\">Selection of loading records and storing output file</span></p></body></html>"))
        self.label_25.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" color:#0000ff;\">Directory selection</span></p></body></html>"))
        self.label_26.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" color:#0000ff;\">CSV and NPY File</span></p></body></html>"))
        self.label_27.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" color:#0000ff;\">Analysis window length</span></p></body></html>"))
        self.label_28.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" color:#0000ff;\">Time intervals selection windows </span></p></body></html>"))
        self.label_29.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:6pt; font-weight:600; font-style:italic; color:#00007f;\">By default = 3</span></p></body></html>"))
        self.label_30.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:6pt; font-weight:600; font-style:italic; color:#00007f;\">By default = 1 hr.</span></p></body></html>"))
        self.label_31.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" color:#0000ff;\">Initial time </span></p></body></html>"))
        self.label_32.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:6pt; font-weight:600; font-style:italic; color:#00007f;\">By default = 50</span></p></body></html>"))
        self.label_33.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" color:#0000ff;\">Envelope parameters </span></p></body></html>"))
        self.label_34.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:6pt; color:#0000ff;\">Smoothing type (1-3) </span></p></body></html>"))
        self.label_35.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" color:#0000ff;\">NaN Tolerance </span></p></body></html>"))
        self.label_36.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:6pt; font-weight:600; font-style:italic; color:#00007f;\">By default = 1</span></p></body></html>"))
        self.label_37.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" color:#0000ff;\">Year</span></p></body></html>"))
        self.label_38.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:6pt; font-weight:600; font-style:italic; color:#00007f;\">(YYYY)</span></p></body></html>"))
        self.label_39.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" color:#0000ff;\">Month</span></p></body></html>"))
        self.label_40.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:6pt; font-weight:600; font-style:italic; color:#00007f;\">(MM)</span></p></body></html>"))
        self.label_41.setText(_translate("MainWindow", "<html><head/><body><p align=\"center\"><span style=\" color:#0000ff;\">Print Results</span></p></body></html>"))
        self.label_42.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" color:#0000ff;\">Time interval</span></p></body></html>"))
        self.label_43.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" color:#0000ff;\">Start</span></p></body></html>"))
        self.label_44.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" color:#0000ff;\">End</span></p></body></html>"))
        self.label_45.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:6pt; font-weight:600; font-style:italic; color:#00007f;\">Julian days</span></p></body></html>"))
        self.label_46.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:6pt; font-weight:600; font-style:italic; color:#00007f;\">Julian days</span></p></body></html>"))
        self.label_48.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" color:#0000ff;\">Day</span></p></body></html>"))
        self.label_49.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:6pt; font-weight:600; font-style:italic; color:#00007f;\">(DD)</span></p></body></html>"))
        self.label_50.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:6pt; font-weight:600; font-style:italic; color:#00007f;\">e.g.(YYYY,MM,DD)</span></p></body></html>"))

        # Validate so that only "integers" numbers are accepted, you must put "QIntValidator".
        self.lineEdit_5.setValidator(QtGui.QIntValidator(1, 99))            # Only accepts numbers in the Smoothing type text box. Value two digits.
        self.lineEdit_7.setValidator(QtGui.QIntValidator(1, 99))            # Only accepts numbers in the Filter Order text box. Value two digits.
        self.lineEdit_10.setValidator(QtGui.QIntValidator(1, 9999))         # Only accepts numbers in the Envelope window size text box. Value four digits.
        self.lineEdit_11.setValidator(QtGui.QIntValidator(1, 999))          # Only accepts numbers in the Star size text box. Value three digits.
        self.lineEdit_12.setValidator(QtGui.QIntValidator(1, 999))          # Only accepts numbers in the End size text box. Value three digits.
        self.lineEdit_13.setValidator(QtGui.QIntValidator(1, 99))           # Only accepts numbers in the NaN Tolerance text box. Value two digits.
        self.lineEdit_14.setValidator(QtGui.QIntValidator(1, 9999))         # Only accepts numbers in the Year size text box. Value four digits.
        self.lineEdit_15.setValidator(QtGui.QIntValidator(1, 99))           # Only accepts numbers in the Month size text box. Value two digits.
        self.lineEdit_16.setValidator(QtGui.QIntValidator(1, 99))           # Only accepts numbers in the Day size text box. Value two digits.

        # To work with Lowpass and Highpass filters. Validate so that only decimal numbers are accepted "QDoubleValidator"
        self.lineEdit_6.setValidator(QtGui.QDoubleValidator())              # Only accepts decimal numbers in the frequency text box.
        self.lineEdit_8.setValidator(QtGui.QDoubleValidator())              # Only accepts decimal numbers in the frequency mim. text box.
        self.lineEdit_9.setValidator(QtGui.QDoubleValidator())              # Only accepts decimal numbers in the frequency max. text box.

        # Disable text boxes at startup
        self.lineEdit_5.setEnabled(False)                                   # Disable Smoothing type text box.
        self.lineEdit_6.setEnabled(False)                                   # Disable the frequency Text box.
        self.lineEdit_7.setEnabled(False)                                   # Disable the Filter Order Text box.
        self.lineEdit_8.setEnabled(False)                                   # Disable the frequency mim. Text box.
        self.lineEdit_9.setEnabled(False)                                   # Disable the frequency max. Text box.
        self.lineEdit_10.setEnabled(False)                                  # Disable the Envelope window size Text box.
        self.lineEdit_11.setEnabled(False)                                  # Disable the Start time Text box.
        self.lineEdit_12.setEnabled(False)                                  # Disable the End time Text box.
        self.lineEdit_13.setEnabled(False)                                  # Disable NaN Tolerance Text box.
        self.lineEdit_14.setEnabled(False)                                  # Disable Initial Year Text box.
        self.lineEdit_15.setEnabled(False)                                  # Disable Initial Month Text box.
        self.lineEdit_16.setEnabled(False)                                  # Disable Initial Day Text box.

        # Disable pushButton (Plot Entropy) at startup
        self.pushButton_3.setEnabled(False)                                 # Disable the Plot Entropy Command Button.

        self.lineEdit_5.setText("3")                                        # Starts initial Smoothing type text box contents = 3.
        self.lineEdit_7.setText("4")                                        # Start filter order text box = 4.
        self.lineEdit_10.setText("50")                                      # Start Envelope window size text box = 50.
        self.lineEdit_13.setText("1")                                       # Start NaN Tolerance size text box = 1.

        # RadioButtons and checkBox labels
        self.radioButton.setText(_translate("MainWindow", "10 min."))
        self.radioButton_2.setText(_translate("MainWindow", "1 hr."))
        self.radioButton_3.setText(_translate("MainWindow", "24 hrs."))

        self.checkBox.setText(_translate("MainWindow", "Yes/No"))

        self.checkBox_2.setText(_translate("MainWindow", "Yes/No"))

        # Command button actions, function calls
        self.pushButton.clicked.connect(self.Load_records)                  # Call the function to upload file (Load Records).
        self.pushButton_2.clicked.connect(self.Store_File)                  # Calls the function to store the CSV file output (CSV File).
        self.pushButton_3.clicked.connect(self.Plot_entropy)                # Call the function to Plot Entropy (Plot Entropy).
        self.pushButton_4.clicked.connect(self.Clean_entries)               # Call the function to clean entries (Clean entries)
        self.pushButton_5.clicked.connect(self.Exit1)                       # Calls the function to Exit (Exir module).
        self.pushButton_6.clicked.connect(self.Back1)                       # Call the function to return to the Home Screen (Back to menu).

        # Call to the function according to the ComboBox list for the Filter type.
        self.comboBox_2.activated.connect(self.selection_changed1)

        # Call to the function according to the CheckBox
        self.checkBox.stateChanged.connect(self.state_changed2)

        # Call to the function according to the CheckBox_2
        self.checkBox_2.stateChanged.connect(self.state_changed3)


    """ -------------*** Start of Program Functions  ***------------ """

    """ Function to open and clean """


    def state_changed2(self):                                                # To check activation of the checkBox, Yes Ready
        if self.checkBox.isChecked():
            self.lineEdit_11.setEnabled(True)                                              # Enabled the Start time Text box.
            self.lineEdit_12.setEnabled(True)                                              # Enabled the End time Text box.

        else:
            self.lineEdit_11.setText("")                                                    # Clear the Start time Text box.
            self.lineEdit_12.setText("")                                                    # Clear the End time Text box.
            self.lineEdit_11.setEnabled(False)                                              # Disable the Start time Text box.
            self.lineEdit_12.setEnabled(False)                                              # Disable the End time Text box.

    def state_changed3(self):                                               # To check activation of the checkBox_2, Yes Ready

        if self.checkBox_2.isChecked():
            self.lineEdit_14.setEnabled(True)                                               # Enabled Initial Year Text box.
            self.lineEdit_15.setEnabled(True)                                               # Enabled Initial Month Text box.
            self.lineEdit_16.setEnabled(True)                                               # Enabled Initial Day Text box.

        else:
            self.lineEdit_14.setText("")                                                    # Clear Initial Year Text box.
            self.lineEdit_15.setText("")                                                    # Clear Initial Month Text box.
            self.lineEdit_16.setText("")                                                    # Clear Initial Day Text box.

            self.lineEdit_14.setEnabled(False)                                              # Disable Initial Year Text box.
            self.lineEdit_15.setEnabled(False)                                              # Disable Initial Month Text box.
            self.lineEdit_16.setEnabled(False)                                              # Disable Initial Day Text box.


    def Load_records(self):                                 # Function to select the directory where the files are located.
        if sistema == "Windows":                            # Windows System.

            self.archivo_abierto3=filedialog.askdirectory(initialdir = "/",
              title = "Please Select Folder")

            self.ruta1 = Path(self.archivo_abierto3)
            self.ruta2 = self.ruta1.joinpath(self.ruta1).resolve()

            font=QtGui.QFont()
            font.setFamily("Times New Roman")
            font.setPointSize(8)
            font.setBold(False)
            font.setItalic(False)
            font.setWeight(60)
            self.label_5.setFont(font)                                          # Printing using text format.
            self.label_5.setText(self.archivo_abierto3 + "/")                   # Printing on the file path label.

        else:                                                                   # Linux System
            self.activacion4()                                                  # Call to the input cleaning function and Activation/Deactivation
            self.archivo_abierto3=filedialog.askdirectory(initialdir = "/",
              title = "Please Select Folder")

            self.ruta3 = Path(self.archivo_abierto3)
            self.ruta4 = self.ruta3.joinpath(self.ruta3).resolve()

            font=QtGui.QFont()
            font.setFamily("Times New Roman")
            font.setPointSize(8)
            font.setBold(False)
            font.setItalic(False)
            font.setWeight(60)
            self.label_5.setFont(font)                                          # Printing using text format.
            self.label_5.setText(self.archivo_abierto3 + "/")                   # Printing on the file path label.

    def Store_File(self):                                   # Function to select the directory where the files CSV and NPY are store.
        if sistema == "Windows":                            # Windows System

            self.archivo_abierto4=filedialog.askdirectory(initialdir = "/",
              title = "Please Select Folder")

            self.ruta1 = Path(self.archivo_abierto4)
            self.ruta2 = self.ruta1.joinpath(self.ruta1).resolve()

            font=QtGui.QFont()
            font.setFamily("Times New Roman")
            font.setPointSize(8)
            font.setBold(False)
            font.setItalic(False)
            font.setWeight(60)
            self.label_8.setFont(font)                                          # Printing using text format.
            self.label_8.setText(self.archivo_abierto4 + "/")                   # Printing on the file path label.

        else:                                                                   # Linux System
            self.activacion4()                                                  # Call to the input cleaning function and Activation/Deactivation
            self.archivo_abierto4=filedialog.askdirectory(initialdir = "/",
              title = "Please Select Folder")

            self.ruta3 = Path(self.archivo_abierto4)
            self.ruta4 = self.ruta3.joinpath(self.ruta3).resolve()

            font=QtGui.QFont()
            font.setFamily("Times New Roman")
            font.setPointSize(8)
            font.setBold(False)
            font.setItalic(False)
            font.setWeight(60)
            self.label_8.setFont(font)                                          # Printing using text format.
            self.label_8.setText(self.archivo_abierto4 + "/")                   # Printing on the file path label.


    def Clean_entries(self):                                                    # Clean and leave everything as at the beginning.

        msg = QMessageBox()
        msg.setIcon(QMessageBox.Question)
        msg.setWindowTitle("Clean all inputs.")
        msg.setText("Are you sure to delete all entries?")
        msg.setStandardButtons(QMessageBox.Ok | QMessageBox.Cancel)
        msg.setDefaultButton(QMessageBox.Ok)                                    # By default, the focus is on the OK button
        returnValue = msg.exec()
        if returnValue == QMessageBox.Ok:                                       # If the answer is OK

            # Position the ComboBox at the start.
            self.comboBox_2.setCurrentIndex(0)                                  # Position in the first Item (Filter Type)
            plt.close()                                                         # Close the existing chart.

            # Delete label content and Text Boxes.
            self.label_5.setText("")                                            # Delete the contents of the label (Directory to store the CSV file)
            self.label_8.setText("")                                            # Delete the contents of the CSV File text box

            self.lineEdit_5.setText("3")                                        # Clear the content of "initial Smoothing type" text box
            self.lineEdit_6.setText("")                                         # Clear the content of the Frequency text box.
            self.lineEdit_7.setText("4")                                        # Clear the content of the filter Order and Start filter order text box = 4.
            self.lineEdit_8.setText("")                                         # Clear the content of the minimum frequency text box.
            self.lineEdit_9.setText("")                                         # Clear the content of the maximum frequency text box.
            self.lineEdit_10.setText("50")                                      # Clear the content of the Envelope size text box.
            self.lineEdit_11.setText("")                                        # Clear the content of the Star time text box.
            self.lineEdit_12.setText("")                                        # Clear the content of the End time text box.
            self.lineEdit_13.setText("1")                                       # Clear the content of the NaN Tolerance text box = 1.

            # Disable text boxes again on startup
            self.lineEdit_5.setEnabled(False)                                   # Disable the "Smoothing type" text box.
            self.lineEdit_6.setEnabled(False)                                   # Disable the frequency Text box.
            self.lineEdit_7.setEnabled(False)                                   # Disable the Filter Order Text box.
            self.lineEdit_8.setEnabled(False)                                   # Disable the frequency mim. Text box.
            self.lineEdit_9.setEnabled(False)                                   # Disable the frequency max. Text box.
            self.lineEdit_10.setEnabled(False)                                  # Disable the Envelope size Text box.
            self.lineEdit_11.setEnabled(False)                                  # Disable the Start time Text box.
            self.lineEdit_12.setEnabled(False)                                  # Disable the End time Text box.
            self.lineEdit_13.setEnabled(False)                                  # Disable the NaN Tolerance Text box.

            self.pushButton_3.setEnabled(False)                                 # Disable the Plot Entropy Command Button.

            # Disable and enable the radioButton and CheckBox on startup
            self.radioButton.setChecked(False)
            self.radioButton_2.setChecked(True)
            self.radioButton_3.setChecked(False)
            self.checkBox.setChecked(False)
            self.checkBox_2.setChecked(False)

            plt.close()                                                         # Close the existing chart.
        else:
            pass

    """  Function to manage the filter combobox  """

    def selection_changed1(self):  # Function that programs the list of the ComboBox for the Type of Filter

        index = self.comboBox_2.currentIndex()                          # According to Combobox selection, its index is captured.

        if (0 == index):                                                # *** In case the combo index is 0, (Select) """
            # Position the ComboBoxes at the beginning
            self.activacion1()                                          # Call to the cleaning function and Activation/Deactivation 1

        elif (1 == index):                                              # *** In case the combo index is 1, (Lowpass) """
            self.activacion2()                                          # Call to the cleaning function and Activation/Deactivation 2

        elif (2 == index):                                              # *** In case the combo index is 2, (Highpass) """
            self.activacion2()                                          # Call to the cleaning function and Activation/Deactivation 2

        elif (3 == index):                                              # *** In case the combo index is 3, (Bandpass) """
            self.activacion3()                                          # Call to the cleaning function and Activation/Deactivation 3

        elif (4 == index):                                              # *** In case the combo index is 3, (Bandstop) """
            self.activacion3()                                          # Call to the cleaning function and Activation/Deactivation 3

        else:
            pass

    def Plot_entropy(self):                                                 # Function to validate entries and plot Filters.

            index1 = self.comboBox_2.currentIndex()                         # Reading the ComboBox index.

            if (1 == index1):

                if self.radioButton_2.isChecked() == True:

                    self.filtropasobajo()                                   # Lowpass filter with 1 hr. analysis.

                elif self.radioButton.isChecked() == True:

                    self.filtropasobajo10()                                 # Lowpass filter with 10 min. analysis.

                else:

                    self.filtropasobajo24hr()                               # Lowpass filter with 24 hr. analysis.

            elif (2 == index1):

                if self.radioButton_2.isChecked() == True:

                    self.filtropasoalto()                                   # Highpass filter with 1 hr. analysis.

                elif self.radioButton.isChecked() == True:

                    self.filtropasoalto10()                                 # Highpass filter with 10 min. analysis.

                else:

                    self.filtropasoalto24hr()                               # Highpass filter with 24 hr. analysis.

            elif (3 == index1):

                if self.radioButton_2.isChecked() == True:

                    self.filtropasabanda()                                  # Bandpass filter with 1 hr. analysis.

                elif self.radioButton.isChecked() == True:

                    self.filtropasabanda10()                                # Bandpass filter with 10 min. analysis

                else:

                    self.filtropasabanda24hr()                              # Bandpass filter with 24 hr. analysis.

            elif (4 == index1):

                if self.radioButton_2.isChecked() == True:

                    self.filtrobandstop()                                   # Stopband filter with 1 hr. analysis.

                elif self.radioButton.isChecked() == True:

                    self.filtrobandstop10()                                 # Stopband filter with 10 m analysis
                else:

                    self.filtroBandstop24hr()                               # Stopband filter with 24 hr. analysis.
            else:
                pass


    def activacion1(self):                                              # To Activate / Deactivate and cleaning in "Selection" -> Index 0.

        plt.close()                                                     # Close the existing chart.

        # Clean entrances.
        self.label_5.setText("")                                        # Delete the contents of the label (Directory to store the CSV file)
        self.label_8.setText("")                                        # Delete the contents of the CSV File text box

        self.lineEdit_5.setText("3")                                    # Clear the content of "Smoothing type" text box = 3.
        self.lineEdit_6.setText("")                                     # Clear the content of the Frequency text box.
        self.lineEdit_7.setText("4")                                    # Clear the content of the filter Order and Start filter order text box = 4.
        self.lineEdit_8.setText("")                                     # Clear the content of the minimum frequency text box.
        self.lineEdit_9.setText("")                                     # Clear the content of the maximum frequency text box.
        self.lineEdit_10.setText("50")                                  # Clear and Start the Envelope windows text box = 50.
        self.lineEdit_11.setText("")                                    # Clear the content of the Star time text box.
        self.lineEdit_12.setText("")                                    # Clear the content of the End time text box.
        self.lineEdit_13.setText("1")                                   # Clear the content of the NaN Tolerance text box = 1.

        # Disable text boxes again as at startup
        self.lineEdit_5.setEnabled(False)                               # Disable the "Smoothing type" text box.
        self.lineEdit_6.setEnabled(False)                               # Disable the frequency Text box.
        self.lineEdit_7.setEnabled(False)                               # Disable the Filter Order Text box.
        self.lineEdit_8.setEnabled(False)                               # Disable the frequency mim. Text box.
        self.lineEdit_9.setEnabled(False)                               # Disable the frequency max. Text box.
        self.lineEdit_10.setEnabled(False)                              # Disable the Envelope size Text box.
        self.lineEdit_11.setEnabled(False)                              # Disable the Start time Text box.
        self.lineEdit_12.setEnabled(False)                              # Disable the End time Text box.
        self.lineEdit_13.setEnabled(False)                              # Disable the NaN Tolerance Text box.

        # Disable and enable the radioButton and CheckBox on startup
        self.radioButton.setChecked(False)
        self.radioButton_2.setChecked(True)
        self.radioButton_3.setChecked(False)
        self.checkBox.setChecked(False)
        self.checkBox_2.setChecked(False)

        self.pushButton_3.setEnabled(False)                             # Disable the Plot Entropy Command Button.

        plt.close()                                                     # Close the existing chart.

    def activacion2(self):                          # To Activate/Deactivate and clean in Lowpass and Highpass filter.

        plt.close()                                                     # Close the existing chart.

        # Enable/Disable text boxes
        self.lineEdit_5.setEnabled(True)                                # Enabled the "Smoothing type" text box.
        self.lineEdit_6.setEnabled(True)                                # Enabled the frequency Text box.
        self.lineEdit_7.setEnabled(True)                                # Enabled the Filter Order Text box.
        self.lineEdit_8.setText("")                                     # Clear the content of the minimum frequency text box.
        self.lineEdit_9.setText("")                                     # Clear the content of the maximum frequency text box.
        self.lineEdit_8.setEnabled(False)                               # Disable the frequency mim. Text box.
        self.lineEdit_9.setEnabled(False)                               # Disable the frequency max. Text box.
        self.lineEdit_10.setEnabled(True)                               # Enabled the Envelope size Text box.
        self.lineEdit_13.setEnabled(True)                               # Enabled the NaN Tolerance Text box.

        self.pushButton_3.setEnabled(True)                              # Enabled the Plot Entropy Command Button.

        if self.checkBox.isChecked() == True:                           # If the time interval checkBox is true

            self.lineEdit_11.setEnabled(True)                           # Enabled the Start time Text box.
            self.lineEdit_12.setEnabled(True)                           # Enabled the End time Text box.

        else:
            self.lineEdit_11.setText("")                                # Clear the content of the Star time text box.
            self.lineEdit_12.setText("")                                # Clear the content of the End time text box.

            self.lineEdit_11.setEnabled(False)                          # Disable the Start time Text box.
            self.lineEdit_12.setEnabled(False)                          # Disable the End time Text box.

        if self.checkBox_2.isChecked() == True:                         # If the time interval checkBox_2 is true

            self.lineEdit_14.setEnabled(True)                           # Enabled the Start time Year Text box.
            self.lineEdit_15.setEnabled(True)                           # Enabled the Start time Month Text box.
            self.lineEdit_16.setEnabled(True)                           # Enabled the Start time Day Text box.

        else:
            self.lineEdit_14.setText("")                                # Clear the content of the Start time Year Text box.
            self.lineEdit_15.setText("")                                # Clear the content of the Start time Month Text box.
            self.lineEdit_16.setText("")                                # Clear the content of the Start time Day Text box.

            self.lineEdit_14.setEnabled(False)                          # Disable the Start time Year Text box.
            self.lineEdit_15.setEnabled(False)                          # Disable the Start time Month Text box.
            self.lineEdit_16.setEnabled(False)                          # Disable the Start time Day Text box.

        plt.close()                                                     # Close the existing chart.

    def activacion3(self):                          # To Activate/Deactivate and clean in Bandpass and Bandstop filter.

        plt.close()                                                     # Close the existing chart.

        # Enable/Disable text boxes
        self.lineEdit_5.setEnabled(True)                                # Enabled the "Smoothing type" text box.
        self.lineEdit_6.setText("")                                     # Clear the content of the Frequency text box.
        self.lineEdit_6.setEnabled(False)                               # Enabled the frequency Text box.
        self.lineEdit_7.setEnabled(True)                                # Enabled the Filter Order Text box.
        self.lineEdit_8.setEnabled(True)                                # Disable the frequency mim. Text box.
        self.lineEdit_9.setEnabled(True)                                # Disable the frequency max. Text box.
        self.lineEdit_10.setEnabled(True)                               # Enabled the Envelope size Text box.
        self.lineEdit_13.setEnabled(True)                               # Enabled the NaN Tolerance Text box.

        self.pushButton_3.setEnabled(True)                              # Enabled the Plot Entropy Command Button.

        if self.checkBox.isChecked() == True:                           # If the time interval checkBox is true

            self.lineEdit_11.setEnabled(True)                           # Enabled the Start time Text box.
            self.lineEdit_12.setEnabled(True)                           # Enabled the End time Text box.

        else:
            self.lineEdit_11.setText("")                                # Clear the content of the Star time text box.
            self.lineEdit_12.setText("")                                # Clear the content of the End time text box.

            self.lineEdit_11.setEnabled(False)                          # Disable the Start time Text box.
            self.lineEdit_12.setEnabled(False)                          # Disable the End time Text box.

        if self.checkBox_2.isChecked() == True:                         # If the time interval checkBox_2 is true
            self.lineEdit_5.setEnabled(True)                            # Enabled the "Smoothing type" text box.
            self.lineEdit_14.setEnabled(True)                           # Enabled the Start time Year Text box.
            self.lineEdit_15.setEnabled(True)                           # Enabled the Start time Month Text box.
            self.lineEdit_16.setEnabled(True)                           # Enabled the Start time Day Text box.

        else:
            self.lineEdit_14.setText("")                                # Clear the content of the Start time Year Text box.
            self.lineEdit_15.setText("")                                # Clear the content of the Start time Month Text box.
            self.lineEdit_16.setText("")                                # Clear the content of the Start time Day Text box.
            self.lineEdit_14.setEnabled(False)                          # Disable the Start time Year Text box.
            self.lineEdit_15.setEnabled(False)                          # Disable the Start time Month Text box.
            self.lineEdit_16.setEnabled(False)                          # Disable the Start time Day Text box.

        plt.close()                                                     # Close the existing chart.


    """ Begin to filter functions """

    def filtropasobajo(self):                                           # 1.- Function to execute the Lowpass filter with 1 hr. analysis window.

        try:

            # Verifying that the checkbox is true. Work with time intervals.

            if self.checkBox.isChecked() == True:                      # CheckBox 1 of the time interval is activated

                # Verify (Validation), that the text box and label is not empty

                if not self.label_5.text():
                    MensCombo1 = QMessageBox()
                    MensCombo1.setIcon(QMessageBox.Warning)
                    MensCombo1.setWindowTitle("Empty directory to upload records")
                    MensCombo1.setText("Please, enter a valid name of directory")
                    returnValue = MensCombo1.exec()

                elif not self.label_8.text():
                    MensCombo2 = QMessageBox()
                    MensCombo2.setIcon(QMessageBox.Warning)
                    MensCombo2.setWindowTitle("Empty path to store CSV/NPY file")
                    MensCombo2.setText("Please, enter a valid name of directory")
                    returnValue = MensCombo2.exec()

                elif not self.lineEdit_5.text():
                    MensCombo3 = QMessageBox()
                    MensCombo3.setIcon(QMessageBox.Warning)
                    MensCombo3.setWindowTitle("Empty Smoothing type")
                    MensCombo3.setText("Please, enter a valid Value")
                    returnValue = MensCombo3.exec()

                elif not self.lineEdit_6.text():
                    MensCombo4 = QMessageBox()
                    MensCombo4.setIcon(QMessageBox.Warning)
                    MensCombo4.setWindowTitle("Empty Frequency")
                    MensCombo4.setText("Please, enter a valid Value")
                    returnValue = MensCombo4.exec()

                elif not self.lineEdit_7.text():
                    MensCombo5 = QMessageBox()
                    MensCombo5.setIcon(QMessageBox.Warning)
                    MensCombo5.setWindowTitle("Empty Filter Order")
                    MensCombo5.setText("Please, enter a valid Value")
                    returnValue = MensCombo5.exec()

                elif not self.lineEdit_10.text():
                    MensCombo6 = QMessageBox()
                    MensCombo6.setIcon(QMessageBox.Warning)
                    MensCombo6.setWindowTitle("Empty Envelope Window size")
                    MensCombo6.setText("Please, enter a valid Value")
                    returnValue = MensCombo6.exec()

                elif not self.lineEdit_11.text():
                    MensCombo7 = QMessageBox()
                    MensCombo7.setIcon(QMessageBox.Warning)
                    MensCombo7.setWindowTitle("Empty Start time")
                    MensCombo7.setText("Please, enter a valid Value")
                    returnValue = MensCombo7.exec()

                elif not self.lineEdit_12.text():
                    MensCombo8 = QMessageBox()
                    MensCombo8.setIcon(QMessageBox.Warning)
                    MensCombo8.setWindowTitle("Empty End time")
                    MensCombo8.setText("Please, enter a valid Value")
                    returnValue = MensCombo8.exec()

                elif not self.lineEdit_13.text():
                    MensCombo9 = QMessageBox()
                    MensCombo9.setIcon(QMessageBox.Warning)
                    MensCombo9.setWindowTitle("Empty NaN Tolerance")
                    MensCombo9.setText("Please, enter a valid Value")
                    returnValue = MensCombo9.exec()

                else:
                    # Filtering with a Lowpass.
                    plt.close()                                                 # Close the existing chart.

                    carpeta = (self.label_5.text())                             # Reading the directory or file folder label.

                    # Code to detect the contents of the folder and the files that the folder contains
                    with os.scandir(carpeta) as ficheros:
                        ficheros4 = [fichero.name for fichero in ficheros if fichero.is_file()]

                    # The contents of the files in "ficheros4" is a list. This code converts them to string
                    lfiles = [str(elemento) for elemento in ficheros4]

                    # Code used to determine the name of the files contained in the folder and to be used in the loading loop
                    Iniciolfiles = lfiles[0]                                    # Detects the numeric value of the "Start" in the name
                    Finlfiles = lfiles[-1]                                      # Detects the numerical value of the "End" in the name
                    Indice1 = Iniciolfiles.rfind('.')                           # Determines the index, which will be marked by the dot at the end for the extension
                    Nombre3 = Iniciolfiles[0:Indice1]                           # Indicates the name of the file in str (minus) the index or extension (each day)

                    # Data entry from labels and fields or text boxes (this value is a string by default)
                    frec3 = (self.lineEdit_6.text())                            # reading frequency Label.
                    orden1 = (self.lineEdit_7.text())                           # Reading the Filter Order Label.


                    # Data entry for enveloped (this value is a string by default)
                    Tam = (self.lineEdit_10.text())                             # Reading the envelope window size label.
                    Tsua = (self.lineEdit_5.text())                             # Reading the Smoothing type label.
                    Tnan = (self.lineEdit_13.text())                            # Reading the NaN Tolerance label.

                    Start1 = (self.lineEdit_11.text())                          # Star Time Size label reading.
                    End1 = (self.lineEdit_12.text())                            # End Time Size label reading.

                    # Convert the string value of the input text boxes to float or integer
                    frec4=float(frec3)                                          # Converts Frequency value to float.
                    orden4=int(orden1)                                          # Converts filter order value to integer.

                    Tam1=int(Tam)                                               # Converts the envelope window size value to integer.
                    Tsua1=int(Tsua)                                             # Converts the Smoothing type value to integer.
                    Tnan1=int(Tnan)                                             # Converts the NaN Tolerance value to integer.

                    timeIn = 365

                    Start2=int(Start1)                                          # Converts the Start time window size value to an integer.
                    End2=int(End1)                                              # Converts the End time window size value to an integer.

                    Diferencia = End2 - Start2                                  # Value of the difference between end and start to obtain the number of days to calculate

                    # Function for Shannon entropy calculating
                    def calcular_entropia(datos):
                        params = stats.norm.fit(datos)
                        dist = stats.norm(*params)
                        probabilidades = dist.pdf(datos)
                        entropia = -np.sum(probabilidades * np.log2(probabilidades))
                        return entropia

                    # Function for Kurtosis calculating
                    def calcular_kurtosis(datos):
                        n = len(datos)
                        media = np.mean(datos)
                        varianza = np.var(datos)
                        desviacion_estandar = np.sqrt(varianza)

                        if desviacion_estandar == 0:
                            return 0.0
                        kurtosis = np.sum((datos - media)**4) / (n * desviacion_estandar**4) - 3.0
                        return kurtosis

                    # Function for Shannon entropy enveloped calculating
                    def nanfastsmooth(Y, w, type=1, tol=0.5):

                        """
                        Smooths vector Y with a moving average of width w, ignoring NaNs in data.

                        Parameters:
                        Y (numpy array): Input signal.
                        w (int): Window width.
                        type (int): Smooth type (1 for rectangular, 2 for triangular, 3 for pseudo-Gaussian).
                        tol (float): Tolerance to NaNs between 0 and 1.

                        Returns:
                        numpy array: Smoothed signal.
                        """
                        mask = ~np.isnan(Y)  # Create a boolean mask for non-NaN values
                        Y[mask] = nanfastsmooth_core(Y[mask], w, type, tol)  # Apply smoothing to non-NaN values
                        return Y

                    # Function for Shannon entropy enveloped type calculating. For default the value = 3
                    def nanfastsmooth_core(Y, w, type, tol):
                        if type == 1:
                            SmoothY = moving_average(Y, w)
                        elif type == 2:
                            SmoothY = moving_average(moving_average(Y, w), w)
                        elif type == 3:
                            SmoothY = moving_average(moving_average(moving_average(Y, w), w), w)

                        return SmoothY

                    def moving_average(Y, window_size):
                        return np.convolve(Y, np.ones(window_size)/window_size, mode='same')

                    def calcular_indice_frecuencias(datos, frecuencia_muestreo):
                        # Frequency filter applied
                        freq_bajas = (1, 5.5)
                        freq_altas = (6, 16)

                        datos_bajas = apply_bandpass_filter(datos, frecuencia_muestreo, freq_bajas)
                        datos_altas = apply_bandpass_filter(datos, frecuencia_muestreo, freq_altas)

                        # The energy is calculated for each signal
                        energia_bajas = np.sum(datos_bajas ** 2)
                        energia_altas = np.sum(datos_altas ** 2)

                        # The frequency index is calculated
                        indice_frecuencias = np.log(energia_altas / energia_bajas) if energia_bajas != 0 else np.nan
                        return indice_frecuencias

                    def apply_bandpass_filter(datos, frecuencia_muestreo, freq_band):
                        nyquist = 0.5 * frecuencia_muestreo
                        normal_freq_band = np.array(freq_band) / nyquist
                        b, a = signal.butter(4, normal_freq_band, btype='band')
                        datos_filtrados = signal.filtfilt(b, a, datos)
                        return datos_filtrados

                    # Start entropy and averaged entropy values
                    entropia_shannon = []
                    entropia_promediada = []
                    kurtosis_resultados = []
                    frequency_index = []

                    # Cycle for the day-by-day calculation of the entropy in the files contained in the folder, using the time range (Start to End)
                    for dia in range(Start2, End2 + 1):

                        archivo = Nombre3 + '.'+ f"{dia:003}"       # Here you select the name previously calculated plus point and the value of each Julian day

                        # If there is no file in the list, the entire day is added with a value of zero
                        if not os.path.exists(os.path.join(carpeta, archivo)):
                            for _ in range(24):  # Adds 24 hours with zero value if there is no file
                                entropia_shannon.append(0)
                                entropia_promediada.append(0)
                                kurtosis_resultados.append(0)
                                frequency_index.append(0)
                            continue

                        # Designation of the data contained in the folder files
                        st = Stream()
                        st += read(os.path.join(carpeta, archivo))
                        frecuencia_muestreo = st[0].stats.sampling_rate
                        # calculation of the lowpass filter with the parameters indicated by the user.
                        st.filter('lowpass', freq=frec4, corners=orden4, zerophase=True)
                        # Data value
                        datos = st[0].data

                        # Divide the data into hours and calculate entropy for each hour.
                        for hora in range(24):
                            inicio = hora * 3600  # start of time in seconds.
                            fin = inicio + 3600  # End of time in seconds.
                            datos_hora = datos[inicio:fin]

                            if len(datos_hora) < 3600:  # If the hour is incomplete, add zeros to the end.
                                datos_hora = np.append(datos_hora, np.zeros(3600 - len(datos_hora)))

                            # Accumulator of the calculated values of the Shannon entropy and the averaged entropy.
                            entropia_shannon.append(calcular_entropia(datos_hora))
                            entropia_promediada.append(calcular_entropia(datos_hora) / len(datos_hora))
                            kurtosis_resultados.append(calcular_kurtosis(datos_hora))
                            frequency_index.append(calcular_indice_frecuencias(datos_hora, frecuencia_muestreo))

                    # Converting shannon entropy value and averaged entropy to data array.
                    entropia_shannon = np.array(entropia_shannon)
                    entropia_promediada = np.array(entropia_promediada)
                    kurtosis_resultados = np.array(kurtosis_resultados)
                    frequency_index=np.array(frequency_index)

                    # Shannon Entropy Graph. Value of non-zero indices where there is no data.
                    indices_no_cero_shannon = np.where(entropia_shannon != 0)[0]

                    indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                    indices_no_cero_frecuency = np.where(frequency_index != 0)[0]

                    indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]

                    # **** SAVE THE RESULTS FILE .CSV
                    archivoFil2 = (self.label_8.text())                         # Reading directory label.

                    # **** SAVE THE RESULTS .npy FILE FOR LATER GRAPH *****
                    TW = str(Tam1)                                              # Convert Envelope Window value to string for names.
                    F1 = (Nombre3 + '_Lowpass_Filter_1hr_Time_interval_Dots_and_Time' + '_Windows=' + TW + '.csv')            # Assign F1, Capture the name of the record and add the .csv extension.

                    # Guardar resultados en archivos .npy
                    F1a = (Nombre3 + '_Lowpass_Filter_1hr_Time_interval_Dots_and_Time' + '_Windows=' + TW)
                    F2 = (archivoFil2 + F1)                                     # Assigns to F2 the directory plus the previous name where the record will be stored.
                    F3 = (archivoFil2 + F1a)

                    with open(F2, 'w+', newline='') as archivo_csv:             # Each result is saved in the file, day, time and values of Shannon's entropy and averaged.
                        writer = csv.writer(archivo_csv)
                        writer.writerow(['Day', ' Hour', ' Shannon Entropy', ' Averaged Shannon Entropy', ' Kurtosis', ' Frequency Index'])

                        for dia in range(1, Diferencia + 1):                        # Save data by day and time according to the time interval (Start - End)
                            for hora in range(24):

                                writer.writerow([dia, hora, entropia_shannon[(dia - 1) * 24 + hora], entropia_promediada[(dia - 1) * 24 + hora], kurtosis_resultados[(dia - 1) * 24 + hora], frequency_index[(dia - 1) * 24 + hora] ])

                    # Use example
                    Y = entropia_shannon
                    Y = np.where(Y == 0, np.nan, Y)

                    Y1 = kurtosis_resultados
                    Y1 = np.where(Y1 == 0, np.nan, Y1)

                    Y2 = frequency_index
                    Y2 = np.where(Y2 == 0, np.nan, Y2)

                    # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                    # Graph 1 - ENTROPY BY POINTS.

                    if self.checkBox_2.isChecked():                                 # CheckBox 2 of the Initial Time is activated (This marks time on the x axis)

                        if not self.lineEdit_14.text():
                            MensCombo14 = QMessageBox()
                            MensCombo14.setIcon(QMessageBox.Warning)
                            MensCombo14.setWindowTitle("Empty Year value")
                            MensCombo14.setText("Please, enter a valid value")
                            returnValue = MensCombo14.exec()

                        elif not self.lineEdit_15.text():
                            MensCombo15 = QMessageBox()
                            MensCombo15.setIcon(QMessageBox.Warning)
                            MensCombo15.setWindowTitle("Empty Month value")
                            MensCombo15.setText("Please, enter a valid value")
                            returnValue = MensCombo15.exec()

                        elif not self.lineEdit_16.text():
                            MensCombo16 = QMessageBox()
                            MensCombo16.setIcon(QMessageBox.Warning)
                            MensCombo16.setWindowTitle("Empty Day value")
                            MensCombo16.setText("Please, enter a valid value")
                            returnValue = MensCombo16.exec()

                        else:

                            # Data entry for enveloped (this value is a string by default)
                            Anio = (self.lineEdit_14.text())                            # Reading the Year value label.
                            Mes = (self.lineEdit_15.text())                             # Reading the Month value label.
                            Dia1 = (self.lineEdit_16.text())                            # Reading the Day value label.

                            # Convert the string value of the input text boxes to  integer

                            Anio1=int(Anio)                                             # Converts the Year value to integer.
                            Mes1=int(Mes)                                               # Converts the Month value to integer.
                            Dia2=int(Dia1)                                              # Converts the NaN Day value to integer.

                            # The date vector is created
                            fecha_inicio = datetime(Anio1, Mes1, Dia2)
                            dias = [fecha_inicio + timedelta(hours=i) for i in range(len(entropia_shannon[indices_no_cero_shannon]))]

                            # "Indices_no_cero_shannon" = np.where(entropia_shannon != 0)[0]
                            st = (dias, entropia_shannon[indices_no_cero_shannon])
                            np.save(F3, st)  # Save the ".npy" file in the directory.
                            plt.close()

                            st = (dias, entropia_shannon[indices_no_cero_shannon])

                            # Save the ".npy" file in the directory.
                            np.save(F3, st)
                            plt.close()                                             # Close the existing chart.

                            # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                            # Graph 1 - ENTROPY BY POINTS.

                            plt.plot(dias, entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='ShannonEntropy: Points per hour -> 1 Hr.')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_ShannonEntropy: Each point = 1 Hr. with Lowpass filter', color ="darkgreen", fontsize=18)
                            #plt.grid()
                            plt.show()

                            # Graph 2 - Averaged Shannon Entropy Graph.

                            fig, ax = plt.subplots(1,1)
                            indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                            plt.plot(dias, entropia_promediada[indices_no_cero_promediada], "ob", mfc="b", mec = "b", label='ShannonAveragedEntropy: Points per hour -> 1 Hr.')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Shannon Averaged Entropy: Each point = 1 Hr. with Lowpass filter.', color ="darkgreen", fontsize=18)

                            # Graph 3 - Graph of Shannon Entropy with the envelope.

                            # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE.

                            fig, ax = plt.subplots(1,1)

                            y_filtered = nanfastsmooth(Y.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                            plt.plot(dias, entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='Shannon_Entropy')
                            plt.plot(dias, y_filtered[indices_no_cero_shannon], color='blue', label='Envelope')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Envelope - Shannon Entropy: Each point = 1 Hr. with Lowpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            # Graph 4 - Envelope only graph.

                            fig, ax = plt.subplots(1,1)

                            plt.plot(dias, y_filtered[indices_no_cero_shannon], label='Filtered Signal', color='blue')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Only the envelope of Shannon entropy: Each point = 1 Hr. with Lowpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                            # Graph 5 Frequency Index with enveloped
                            fig, ax = plt.subplots(1,1)

                            y_filtered3 = nanfastsmooth(Y2.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                            plt.plot(dias, frequency_index[indices_no_cero_frecuency], 'o-', label='Frequency Index')
                            plt.plot(dias, y_filtered3[indices_no_cero_frecuency], label='Envelope', color='red')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                            plt.title(Nombre3 + ' Frequency Index: Each point = 1 Hr. with Lowpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            # Graph 6 Kurtosis with Envelope
                            fig, ax = plt.subplots(1,1)
                            indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]

                            # The date vector is created
                            fecha_inicio = datetime(Anio1, Mes1, Dia2)
                            dias2 = [fecha_inicio + timedelta(hours=i) for i in range(len(entropia_shannon[indices_no_cero_kurtosis]))]

                            y_filtered2 = nanfastsmooth(Y1.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                            plt.plot(dias2, kurtosis_resultados[indices_no_cero_kurtosis], 'o', label='Kurtosis')
                            plt.plot(dias2, y_filtered2[indices_no_cero_kurtosis], label='Envelope', color='red')
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                            plt.title(Nombre3 + ' Kurtosis: Each point = 1 Hr. with Lowpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)

                            plt.show()

                    else:

                        # Plot the vectors into separate figures.
                        dias = np.arange(1, 8761 + 1)

                        st = (dias, entropia_shannon[indices_no_cero_shannon])

                        np.save(F3, st)  # Save the ".npy" file in the directory.
                        plt.close()

                        # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                        # Graph 1 - ENTROPY BY POINTS.

                        plt.plot(dias[indices_no_cero_shannon], entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='ShannonEntropy: Points per hour -> 1 Hr.')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_ShannonEntropy: Each point = 1 Hr. with Lowpass filter', color ="darkgreen", fontsize=18)

                        # Graph 2 - Averaged Shannon Entropy Graph.

                        fig, ax = plt.subplots(1,1)
                        indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                        plt.plot(dias[indices_no_cero_promediada], entropia_promediada[indices_no_cero_promediada], "ob", mfc="b", mec = "b", label='ShannonAveragedEntropy: Points per hour -> 1 Hr.')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Shannon Averaged Entropy: Each point = 1 Hr. with Lowpass filter.', color ="darkgreen", fontsize=18)


                        # Graph 3 - Graph of Shannon Entropy with the envelope.

                        # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE.

                        fig, ax = plt.subplots(1,1)

                        y_filtered = nanfastsmooth(Y.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                        plt.plot(dias[indices_no_cero_shannon], entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='Shannon Entropy')
                        plt.plot(dias[indices_no_cero_shannon], y_filtered[indices_no_cero_shannon], label='Envelope', color='blue')
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Envelope - Shannon Entropy: Each point = 1 Hr. with Lowpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                        # Graph 4 - Envelope only graph.

                        fig, ax = plt.subplots(1,1)

                        plt.plot(dias[indices_no_cero_shannon], y_filtered[indices_no_cero_shannon], label='Filtered Signal', color='blue')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Only the envelope of Shannon entropy: Each point = 1 Hr. with Lowpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                        # Graph 5 Frequency Index with Envelope
                        fig, ax = plt.subplots(1,1)

                        y_filtered3 = nanfastsmooth(Y2.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                        plt.plot(dias[indices_no_cero_frecuency], frequency_index[indices_no_cero_frecuency], 'o-', label='Frequency Index')
                        plt.plot(dias[indices_no_cero_frecuency], y_filtered3[indices_no_cero_frecuency], label='Envelope', color='red')
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                        plt.title(Nombre3 + ' Frequency Index: Each point = 1 Hr. with Lowpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)


                        # Graph 6 Kurtosis with Envelope
                        fig, ax = plt.subplots(1,1)
                        indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]

                        y_filtered2 = nanfastsmooth(Y1.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                        plt.plot(dias[indices_no_cero_kurtosis], kurtosis_resultados[indices_no_cero_kurtosis], 'o', label='Kurtosis')
                        plt.plot(dias[indices_no_cero_kurtosis], y_filtered2[indices_no_cero_kurtosis], label='Envelope', color='red')
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                        plt.title(Nombre3 + ' Kurtosis: Each point = 1 Hr. with Lowpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)

                        plt.show()

            else:                                           # Here the value of the entropy is calculated without the time interval (Start - End)

                if not self.label_5.text():
                    MensCombo1 = QMessageBox()
                    MensCombo1.setIcon(QMessageBox.Warning)
                    MensCombo1.setWindowTitle("Empty directory to upload records")
                    MensCombo1.setText("Please, enter a valid name of directory")
                    returnValue = MensCombo1.exec()

                elif not self.label_8.text():
                    MensCombo2 = QMessageBox()
                    MensCombo2.setIcon(QMessageBox.Warning)
                    MensCombo2.setWindowTitle("Empty path to store CSV/NPY file")
                    MensCombo2.setText("Please, enter a valid name of directory")
                    returnValue = MensCombo2.exec()

                elif not self.lineEdit_5.text():
                    MensCombo3 = QMessageBox()
                    MensCombo3.setIcon(QMessageBox.Warning)
                    MensCombo3.setWindowTitle("Empty Smoothing type")
                    MensCombo3.setText("Please, enter a valid Value")
                    returnValue = MensCombo3.exec()

                elif not self.lineEdit_6.text():
                    MensCombo4 = QMessageBox()
                    MensCombo4.setIcon(QMessageBox.Warning)
                    MensCombo4.setWindowTitle("Empty Frequency")
                    MensCombo4.setText("Please, enter a valid Value")
                    returnValue = MensCombo4.exec()

                elif not self.lineEdit_7.text():
                    MensCombo5 = QMessageBox()
                    MensCombo5.setIcon(QMessageBox.Warning)
                    MensCombo5.setWindowTitle("Empty Filter Order")
                    MensCombo5.setText("Please, enter a valid Value")
                    returnValue = MensCombo5.exec()

                elif not self.lineEdit_10.text():
                    MensCombo6 = QMessageBox()
                    MensCombo6.setIcon(QMessageBox.Warning)
                    MensCombo6.setWindowTitle("Empty Envelope Window size")
                    MensCombo6.setText("Please, enter a valid Value")
                    returnValue = MensCombo6.exec()

                elif not self.lineEdit_13.text():
                    MensCombo7 = QMessageBox()
                    MensCombo7.setIcon(QMessageBox.Warning)
                    MensCombo7.setWindowTitle("Empty NaN Tolerance")
                    MensCombo7.setText("Please, enter a valid Value")
                    returnValue = MensCombo7.exec()

                else:
                    # Filtering with a Lowpass 1 Hr.
                    plt.close()                                                 # Close the existing chart.

                    carpeta = (self.label_5.text())                             # Reading the directory or file folder label.

                    # Code to detect the contents of the folder and the files that the folder contains
                    with os.scandir(carpeta) as ficheros:
                        ficheros4 = [fichero.name for fichero in ficheros if fichero.is_file()]

                    # The contents of the files in "ficheros4" is a list. This code converts them to string
                    lfiles = [str(elemento) for elemento in ficheros4]

                    # Code used to determine the name of the files contained in the folder and to be used in the loading loop
                    Iniciolfiles = lfiles[0]                                    # Detects the numeric value of the "Start" in the name
                    Finlfiles = lfiles[-1]                                      # Detects the numerical value of the "End" in the name
                    Indice1 = Iniciolfiles.rfind('.')                           # Determines the index, which will be marked by the dot at the end for the extension
                    Nombre3 = Iniciolfiles[0:Indice1]                           # Indicates the name of the file in str (minus) the index or extension (each day)

                    # Data entry from labels and fields or text boxes (this value is a string by default)
                    num_temporal_units = (self.lineEdit_5.text())               # label reading of the total number of daily files.
                    frec3 = (self.lineEdit_6.text())                            # reading frequency Label.
                    orden1 = (self.lineEdit_7.text())                           # Reading the Filter Order Label.

                    # Data entry for enveloped (this value is a string by default)
                    Tam = (self.lineEdit_10.text())                             # Reading the envelope window size label.
                    Tsua = (self.lineEdit_5.text())                             # Reading the Smoothing type label.
                    Tnan = (self.lineEdit_13.text())                            # Reading the NaN Tolerance label.

                    # Convert the string value of the input text boxes to float or integer
                    frec4=float(frec3)                                          # Converts Frequency value to float.
                    orden4=int(orden1)                                          # Converts filter order value to integer.

                    Tam1=int(Tam)                                               # Converts the envelope window size value to integer.
                    Tsua1=int(Tsua)                                             # Converts the Smoothing type value to integer.
                    Tnan1=int(Tnan)                                             # Converts the NaN Tolerance value to integer.

                    timeIn = 365

                    # Function for Shannon entropy calculating
                    def calcular_entropia(datos):
                        params = stats.norm.fit(datos)
                        dist = stats.norm(*params)
                        probabilidades = dist.pdf(datos)
                        entropia = -np.sum(probabilidades * np.log2(probabilidades))
                        return entropia

                     # Function for Kurtosis calculating
                    def calcular_kurtosis(datos):
                        n = len(datos)
                        media = np.mean(datos)
                        varianza = np.var(datos)
                        desviacion_estandar = np.sqrt(varianza)

                        if desviacion_estandar == 0:
                            return 0.0
                        kurtosis = np.sum((datos - media)**4) / (n * desviacion_estandar**4) - 3.0
                        return kurtosis

                    # Function for Shannon entropy enveloped calculating
                    def nanfastsmooth(Y, w, type=1, tol=0.5):

                        """
                        Smooths vector Y with a moving average of width w, ignoring NaNs in data.

                        Parameters:
                        Y (numpy array): Input signal.
                        w (int): Window width.
                        type (int): Smooth type (1 for rectangular, 2 for triangular, 3 for pseudo-Gaussian).
                        tol (float): Tolerance to NaNs between 0 and 1.

                        Returns:
                        numpy array: Smoothed signal.
                        """
                        mask = ~np.isnan(Y)  # Create a boolean mask for non-NaN values
                        Y[mask] = nanfastsmooth_core(Y[mask], w, type, tol)  # Apply smoothing to non-NaN values
                        return Y

                    # Function for Shannon entropy enveloped type calculating. For default the value = 3
                    def nanfastsmooth_core(Y, w, type, tol):
                        if type == 1:
                            SmoothY = moving_average(Y, w)
                        elif type == 2:
                            SmoothY = moving_average(moving_average(Y, w), w)
                        elif type == 3:
                            SmoothY = moving_average(moving_average(moving_average(Y, w), w), w)

                        return SmoothY

                    def moving_average(Y, window_size):
                        return np.convolve(Y, np.ones(window_size)/window_size, mode='same')

                    def calcular_indice_frecuencias(datos, frecuencia_muestreo):
                        # Frequency filter applied
                        freq_bajas = (1, 5.5)
                        freq_altas = (6, 16)

                        datos_bajas = apply_bandpass_filter(datos, frecuencia_muestreo, freq_bajas)
                        datos_altas = apply_bandpass_filter(datos, frecuencia_muestreo, freq_altas)

                        # The energy is calculated for each signal
                        energia_bajas = np.sum(datos_bajas ** 2)
                        energia_altas = np.sum(datos_altas ** 2)

                        # The frequency index is calculated
                        indice_frecuencias = np.log(energia_altas / energia_bajas) if energia_bajas != 0 else np.nan
                        return indice_frecuencias

                    def apply_bandpass_filter(datos, frecuencia_muestreo, freq_band):
                        nyquist = 0.5 * frecuencia_muestreo
                        normal_freq_band = np.array(freq_band) / nyquist
                        b, a = signal.butter(4, normal_freq_band, btype='band')
                        datos_filtrados = signal.filtfilt(b, a, datos)
                        return datos_filtrados

                    # Start entropy and averaged entropy values
                    entropia_shannon = []
                    entropia_promediada = []
                    kurtosis_resultados = []
                    frequency_index = []

                    # Cycle for the day-by-day calculation of the entropy in the files contained in the folder, using the time range (Start to End)
                    for dia in range(1, timeIn + 1):

                        archivo = Nombre3 + '.'+ f"{dia:003}"       # Here you select the name previously calculated plus point and the value of each Julian day

                        # If there is no file in the list, the entire day is added with a value of zero
                        if not os.path.exists(os.path.join(carpeta, archivo)):
                            for _ in range(24):  # Adds 24 hours with zero value if there is no file
                                entropia_shannon.append(0)
                                entropia_promediada.append(0)
                                kurtosis_resultados.append(0)
                                frequency_index.append(0)
                            continue

                        # Designation of the data contained in the folder files
                        st = Stream()
                        st += read(os.path.join(carpeta, archivo))
                        frecuencia_muestreo = st[0].stats.sampling_rate
                        # calculation of the lowpass filter with the parameters indicated by the user.
                        st.filter('lowpass', freq=frec4, corners=orden4, zerophase=True)
                        # Data value
                        datos = st[0].data

                        # Divide the data into hours and calculate entropy for each hour.
                        for hora in range(24):
                            inicio = hora * 3600  # start of time in seconds.
                            fin = inicio + 3600  # End of time in seconds.
                            datos_hora = datos[inicio:fin]

                            if len(datos_hora) < 3600:  # If the hour is incomplete, add zeros to the end.
                                datos_hora = np.append(datos_hora, np.zeros(3600 - len(datos_hora)))

                            # Accumulator of the calculated values of the Shannon entropy and the averaged entropy.
                            entropia_shannon.append(calcular_entropia(datos_hora))
                            entropia_promediada.append(calcular_entropia(datos_hora) / len(datos_hora))
                            kurtosis_resultados.append(calcular_kurtosis(datos_hora))
                            frequency_index.append(calcular_indice_frecuencias(datos_hora, frecuencia_muestreo))

                    # Converting shannon entropy value and averaged entropy to data array.
                    entropia_shannon = np.array(entropia_shannon)
                    entropia_promediada = np.array(entropia_promediada)
                    kurtosis_resultados = np.array(kurtosis_resultados)
                    frequency_index=np.array(frequency_index)

                    # Shannon Entropy Graph. Value of non-zero indices where there is no data.
                    indices_no_cero_shannon = np.where(entropia_shannon != 0)[0]

                    indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                    indices_no_cero_frecuency = np.where(frequency_index != 0)[0]

                    indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]


                    # **** SAVE THE RESULTS FILE .CSV
                    archivoFil2 = (self.label_8.text())                         # Reading directory label.

                    # **** SAVE THE RESULTS .npy FILE FOR LATER GRAPH *****
                    TW = str(Tam1)                                              # Convert Envelope Window value to string for names.
                    F1 = (Nombre3 + '_Lowpass_Filter_1hr_without_Time_interval_Dots_and_Time' + '_Windows=' + TW + '.csv')            # Assign F1, Capture the name of the record and add the .csv extension.

                    # Guardar resultados en archivos .npy
                    F1a = (Nombre3 + '_Lowpass_Filter_1hr_without_Time_interval_Dots_and_Time' + '_Windows=' + TW)
                    F2 = (archivoFil2 + F1)                                     # Assigns to F2 the directory plus the previous name where the record will be stored.
                    F3 = (archivoFil2 + F1a)

                    with open(F2, 'w+', newline='') as archivo_csv:             # Each result is saved in the file, day, time and values of Shannon's entropy and averaged.
                        writer = csv.writer(archivo_csv)
                        writer.writerow(['Day', ' hour', ' Shannon Entropy', ' Averaged Shannon Entropy', ' Envelope Shannon Entropy', ' Kurtosis', ' Frequency Index'])

                        for dia in range(1, timeIn + 1):                        # Save data by day and time according to the time interval (Start - End)
                            for hora in range(24):
                                writer.writerow([dia, hora, entropia_shannon[(dia - 1) * 24 + hora], entropia_promediada[(dia - 1) * 24 + hora], kurtosis_resultados[(dia - 1) * 24 + hora], frequency_index[(dia - 1) * 24 + hora] ])

                    # Use example
                    Y = entropia_shannon
                    Y = np.where(Y == 0, np.nan, Y)

                    Y1 = kurtosis_resultados
                    Y1 = np.where(Y1 == 0, np.nan, Y1)

                    Y2 = frequency_index
                    Y2 = np.where(Y2 == 0, np.nan, Y2)

                    # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                    # Graph 1 - ENTROPY BY POINTS.

                    if self.checkBox_2.isChecked():                                 # checkBox for Initial Time

                        if not self.lineEdit_14.text():
                            MensCombo14 = QMessageBox()
                            MensCombo14.setIcon(QMessageBox.Warning)
                            MensCombo14.setWindowTitle("Empty Year value")
                            MensCombo14.setText("Please, enter a valid value")
                            returnValue = MensCombo14.exec()

                        elif not self.lineEdit_15.text():
                            MensCombo15 = QMessageBox()
                            MensCombo15.setIcon(QMessageBox.Warning)
                            MensCombo15.setWindowTitle("Empty Month value")
                            MensCombo15.setText("Please, enter a valid value")
                            returnValue = MensCombo15.exec()

                        elif not self.lineEdit_16.text():
                            MensCombo16 = QMessageBox()
                            MensCombo16.setIcon(QMessageBox.Warning)
                            MensCombo16.setWindowTitle("Empty Day value")
                            MensCombo16.setText("Please, enter a valid value")
                            returnValue = MensCombo16.exec()

                        else:

                            # Data entry for enveloped (this value is a string by default)
                            Anio = (self.lineEdit_14.text())                            # Reading the Year value label.
                            Mes = (self.lineEdit_15.text())                             # Reading the Month value label.
                            Dia1 = (self.lineEdit_16.text())                            # Reading the Day value label.

                            # Convert the string value of the input text boxes to  integer

                            Anio1=int(Anio)                                             # Converts the Year value to integer.
                            Mes1=int(Mes)                                               # Converts the Month value to integer.
                            Dia2=int(Dia1)                                              # Converts the NaN Day value to integer.

                            # The date vector is created
                            fecha_inicio = datetime(Anio1, Mes1, Dia2)
                            dias = [fecha_inicio + timedelta(hours=i) for i in range(len(entropia_shannon[indices_no_cero_shannon]))]

                            st = (dias, entropia_shannon[indices_no_cero_shannon])

                            # Save the ".npy" file in the directory.
                            np.save(F3, st)
                            plt.close()                                             # Close the existing chart.

                            # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                            # Graph 1 - ENTROPY BY POINTS.

                            plt.plot(dias, entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='Shannon Entropy')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_ShannonEntropy: Each point = 1 Hr. with Lowpass filter', color ="darkgreen", fontsize=18)
                            #plt.grid()
                            plt.show()

                            # Graph 2 - Averaged Shannon Entropy Graph.

                            fig, ax = plt.subplots(1,1)
                            indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                            plt.plot(dias, entropia_promediada[indices_no_cero_promediada], "ob", mfc="b", mec = "b", label='ShannonAveragedEntropy: Points per hour -> 1 Hr.')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Shannon Averaged Entropy: Each point = 1 Hr. with Lowpass filter.', color ="darkgreen", fontsize=18)

                            # Graph 3 - Graph of Shannon Entropy with the envelope.

                            # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE.

                            fig, ax = plt.subplots(1,1)

                            y_filtered = nanfastsmooth(Y.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                            plt.plot(dias, entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='Shannon Entropy')
                            plt.plot(dias, y_filtered[indices_no_cero_shannon], label='Envelope', color='blue')
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Envelope - Shannon Entropy: Each point = 1 Hr. with Lowpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                            # Graph 4 - Envelope only graph.

                            fig, ax = plt.subplots(1,1)

                            plt.plot(dias, y_filtered[indices_no_cero_shannon], label='Filtered Signal', color='blue')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Only the envelope of Shannon entropy: Each point = 1 Hr. with Lowpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                            # Graph 5 Frequency Index with Envelope
                            fig, ax = plt.subplots(1,1)

                            y_filtered3 = nanfastsmooth(Y2.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                            plt.plot(dias, frequency_index[indices_no_cero_frecuency], 'o-', label='Frequency Index')
                            plt.plot(dias, y_filtered3[indices_no_cero_frecuency], label='Envelope', color='red')
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                            plt.title(Nombre3 + ' Frequency Index: Each point = 1 Hr. with Lowpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)

                            # Graph 6 Kurtosis with Envelope
                            fig, ax = plt.subplots(1,1)
                            indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]

                            # The date vector is created
                            fecha_inicio = datetime(Anio1, Mes1, Dia2)
                            dias2 = [fecha_inicio + timedelta(hours=i) for i in range(len(entropia_shannon[indices_no_cero_kurtosis]))]

                            y_filtered2 = nanfastsmooth(Y1.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                            plt.plot(dias2, kurtosis_resultados[indices_no_cero_kurtosis], 'o', label='Kurtosis')
                            plt.plot(dias2, y_filtered2[indices_no_cero_kurtosis], label='Envelope', color='red')
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                            plt.title(Nombre3 + ' Kurtosis: Each point = 1 Hr. with Lowpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)

                            plt.show()

                    else:

                        # Plot the vectors into separate figures.
                        dias = np.arange(1, 8761 + 1)

                        st = (dias, entropia_shannon[indices_no_cero_shannon])

                        np.save(F3, st)  # Save the ".npy" file in the directory.
                        plt.close()

                        # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                        # Graph 1 - ENTROPY BY POINTS.

                        plt.plot(dias[indices_no_cero_shannon], entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='ShannonEntropy: Points per hour -> 1 Hr.')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_ShannonEntropy: Each point = 1 Hr. with Lowpass filter', color ="darkgreen", fontsize=18)

                        # Graph 2 - Averaged Shannon Entropy Graph.

                        fig, ax = plt.subplots(1,1)
                        indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                        plt.plot(dias[indices_no_cero_promediada], entropia_promediada[indices_no_cero_promediada], "ob", mfc="b", mec = "b", label='ShannonAveragedEntropy: Points per hour -> 1 Hr.')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Shannon Averaged Entropy: Each point = 1 Hr. with Lowpass filter.', color ="darkgreen", fontsize=18)

                        # Graph 3 - Graph of Shannon Entropy plus the envelope.

                        # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE.

                        fig, ax = plt.subplots(1,1)

                        y_filtered = nanfastsmooth(Y.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                        plt.plot(dias[indices_no_cero_shannon], entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='Shannon Entropy')
                        plt.plot(dias[indices_no_cero_shannon], y_filtered[indices_no_cero_shannon], label='Envelope', color='blue')
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Envelope - Shannon Entropy: Each point = 1 Hr. with Lowpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                        # Graph 4 - Envelope only graph.

                        fig, ax = plt.subplots(1,1)

                        plt.plot(dias[indices_no_cero_shannon], y_filtered[indices_no_cero_shannon], label='Filtered Signal', color='blue')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Only the envelope of Shannon entropy: Each point = 1 Hr. with Lowpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                        # Graph 5 Frequency Index with Envelope
                        fig, ax = plt.subplots(1,1)

                        y_filtered3 = nanfastsmooth(Y2.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                        plt.plot(dias[indices_no_cero_frecuency], frequency_index[indices_no_cero_frecuency], 'o-', label='Frequency Index')
                        plt.plot(dias[indices_no_cero_frecuency], y_filtered3[indices_no_cero_frecuency], label='Envelope', color='red')
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                        plt.title(Nombre3 + ' Frequency Index: Each point = 1 Hr. with Lowpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)

                        # Graph 6 Kurtosis with Envelope
                        fig, ax = plt.subplots(1,1)
                        indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]

                        y_filtered2 = nanfastsmooth(Y1.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                        plt.plot(dias[indices_no_cero_kurtosis], kurtosis_resultados[indices_no_cero_kurtosis], 'o', label='Kurtosis')
                        plt.plot(dias[indices_no_cero_kurtosis], y_filtered2[indices_no_cero_kurtosis], label='Envelope', color='red')
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                        plt.title(Nombre3 + ' Kurtosis: Each point = 1 Hr. with Lowpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)

                        plt.show()


        except:                         # In any other case of invalid or empty inputs
                plt.close()                                                 # Close the existing chart.
                msgBox = QMessageBox()
                msgBox.setIcon(QMessageBox.Warning)
                msgBox.setText("The File Does not exist, is Invalid or the CSV old file is open. Please close, try again ...")
                msgBox.setWindowTitle("Invalid Record inputs or CSV Old file is open ")
                returnValue = msgBox.exec()
                pass


    def filtropasoalto(self):                                               # 2.- Function to execute the Highpass filter with 1 hr. analysis window.

        try:

            # Verifying that the checkbox is true. Work with time intervals.

            if self.checkBox.isChecked() == True:                      # CheckBox 1 of the time interval is activated

                # Verify (Validation), that the text box and label is not empty

                if not self.label_5.text():
                    MensCombo1 = QMessageBox()
                    MensCombo1.setIcon(QMessageBox.Warning)
                    MensCombo1.setWindowTitle("Empty directory to upload records")
                    MensCombo1.setText("Please, enter a valid name of directory")
                    returnValue = MensCombo1.exec()

                elif not self.label_8.text():
                    MensCombo2 = QMessageBox()
                    MensCombo2.setIcon(QMessageBox.Warning)
                    MensCombo2.setWindowTitle("Empty path to store CSV/NPY file")
                    MensCombo2.setText("Please, enter a valid name of directory")
                    returnValue = MensCombo2.exec()

                elif not self.lineEdit_5.text():
                    MensCombo3 = QMessageBox()
                    MensCombo3.setIcon(QMessageBox.Warning)
                    MensCombo3.setWindowTitle("Empty Smoothing type")
                    MensCombo3.setText("Please, enter a valid Value")
                    returnValue = MensCombo3.exec()

                elif not self.lineEdit_6.text():
                    MensCombo4 = QMessageBox()
                    MensCombo4.setIcon(QMessageBox.Warning)
                    MensCombo4.setWindowTitle("Empty Frequency")
                    MensCombo4.setText("Please, enter a valid Value")
                    returnValue = MensCombo4.exec()

                elif not self.lineEdit_7.text():
                    MensCombo5 = QMessageBox()
                    MensCombo5.setIcon(QMessageBox.Warning)
                    MensCombo5.setWindowTitle("Empty Filter Order")
                    MensCombo5.setText("Please, enter a valid Value")
                    returnValue = MensCombo5.exec()

                elif not self.lineEdit_10.text():
                    MensCombo6 = QMessageBox()
                    MensCombo6.setIcon(QMessageBox.Warning)
                    MensCombo6.setWindowTitle("Empty Envelope Window size")
                    MensCombo6.setText("Please, enter a valid Value")
                    returnValue = MensCombo6.exec()

                elif not self.lineEdit_11.text():
                    MensCombo7 = QMessageBox()
                    MensCombo7.setIcon(QMessageBox.Warning)
                    MensCombo7.setWindowTitle("Empty Start time")
                    MensCombo7.setText("Please, enter a valid Value")
                    returnValue = MensCombo7.exec()

                elif not self.lineEdit_12.text():
                    MensCombo8 = QMessageBox()
                    MensCombo8.setIcon(QMessageBox.Warning)
                    MensCombo8.setWindowTitle("Empty End time")
                    MensCombo8.setText("Please, enter a valid Value")
                    returnValue = MensCombo8.exec()

                elif not self.lineEdit_13.text():
                    MensCombo9 = QMessageBox()
                    MensCombo9.setIcon(QMessageBox.Warning)
                    MensCombo9.setWindowTitle("Empty NaN Tolerance")
                    MensCombo9.setText("Please, enter a valid Value")
                    returnValue = MensCombo9.exec()

                else:
                    # Filtering with a Highpass 1 Hr.
                    plt.close()                                                 # Close the existing chart.

                    carpeta = (self.label_5.text())                             # Reading the directory or file folder label.

                    # Code to detect the contents of the folder and the files that the folder contains
                    with os.scandir(carpeta) as ficheros:
                        ficheros4 = [fichero.name for fichero in ficheros if fichero.is_file()]

                    # The contents of the files in "ficheros4" is a list. This code converts them to string
                    lfiles = [str(elemento) for elemento in ficheros4]

                    # Code used to determine the name of the files contained in the folder and to be used in the loading loop
                    Iniciolfiles = lfiles[0]                                    # Detects the numeric value of the "Start" in the name
                    Finlfiles = lfiles[-1]                                      # Detects the numerical value of the "End" in the name
                    Indice1 = Iniciolfiles.rfind('.')                           # Determines the index, which will be marked by the dot at the end for the extension
                    Nombre3 = Iniciolfiles[0:Indice1]                           # Indicates the name of the file in str (minus) the index or extension (each day)

                    # Data entry from labels and fields or text boxes (this value is a string by default)
                    frec3 = (self.lineEdit_6.text())                            # reading frequency Label.
                    orden1 = (self.lineEdit_7.text())                           # Reading the Filter Order Label.


                    # Data entry for enveloped (this value is a string by default)
                    Tam = (self.lineEdit_10.text())                             # Reading the envelope window size label.
                    Tsua = (self.lineEdit_5.text())                             # Reading the Smoothing type label.
                    Tnan = (self.lineEdit_13.text())                            # Reading the NaN Tolerance label.

                    Start1 = (self.lineEdit_11.text())                          # Star Time Size label reading.
                    End1 = (self.lineEdit_12.text())                            # End Time Size label reading.

                    # Convert the string value of the input text boxes to float or integer
                    frec4=float(frec3)                                          # Converts Frequency value to float.
                    orden4=int(orden1)                                          # Converts filter order value to integer.

                    Tam1=int(Tam)                                               # Converts the envelope window size value to integer.
                    Tsua1=int(Tsua)                                             # Converts the Smoothing type value to integer.
                    Tnan1=int(Tnan)                                             # Converts the NaN Tolerance value to integer.

                    timeIn = 365

                    Start2=int(Start1)                                          # Converts the Start time window size value to an integer.
                    End2=int(End1)                                              # Converts the End time window size value to an integer.

                    Diferencia = End2 - Start2                                  # Value of the difference between end and start to obtain the number of days to calculate

                    # Function for Shannon entropy calculating
                    def calcular_entropia(datos):
                        params = stats.norm.fit(datos)
                        dist = stats.norm(*params)
                        probabilidades = dist.pdf(datos)
                        entropia = -np.sum(probabilidades * np.log2(probabilidades))
                        return entropia

                     # Function for Kurtosis calculating
                    def calcular_kurtosis(datos):
                        n = len(datos)
                        media = np.mean(datos)
                        varianza = np.var(datos)
                        desviacion_estandar = np.sqrt(varianza)

                        if desviacion_estandar == 0:
                            return 0.0
                        kurtosis = np.sum((datos - media)**4) / (n * desviacion_estandar**4) - 3.0
                        return kurtosis

                    # Function for Shannon entropy enveloped calculating
                    def nanfastsmooth(Y, w, type=1, tol=0.5):

                        """
                        Smooths vector Y with a moving average of width w, ignoring NaNs in data.

                        Parameters:
                        Y (numpy array): Input signal.
                        w (int): Window width.
                        type (int): Smooth type (1 for rectangular, 2 for triangular, 3 for pseudo-Gaussian).
                        tol (float): Tolerance to NaNs between 0 and 1.

                        Returns:
                        numpy array: Smoothed signal.
                        """
                        mask = ~np.isnan(Y)  # Create a boolean mask for non-NaN values
                        Y[mask] = nanfastsmooth_core(Y[mask], w, type, tol)  # Apply smoothing to non-NaN values
                        return Y

                    # Function for Shannon entropy enveloped type calculating. For default the value = 3
                    def nanfastsmooth_core(Y, w, type, tol):
                        if type == 1:
                            SmoothY = moving_average(Y, w)
                        elif type == 2:
                            SmoothY = moving_average(moving_average(Y, w), w)
                        elif type == 3:
                            SmoothY = moving_average(moving_average(moving_average(Y, w), w), w)

                        return SmoothY

                    def moving_average(Y, window_size):
                        return np.convolve(Y, np.ones(window_size)/window_size, mode='same')

                    def calcular_indice_frecuencias(datos, frecuencia_muestreo):
                        # Frequency filter applied
                        freq_bajas = (1, 5.5)
                        freq_altas = (6, 16)

                        datos_bajas = apply_bandpass_filter(datos, frecuencia_muestreo, freq_bajas)
                        datos_altas = apply_bandpass_filter(datos, frecuencia_muestreo, freq_altas)

                        # The energy is calculated for each signal
                        energia_bajas = np.sum(datos_bajas ** 2)
                        energia_altas = np.sum(datos_altas ** 2)

                        # The frequency index is calculated
                        indice_frecuencias = np.log(energia_altas / energia_bajas) if energia_bajas != 0 else np.nan
                        return indice_frecuencias

                    def apply_bandpass_filter(datos, frecuencia_muestreo, freq_band):
                        nyquist = 0.5 * frecuencia_muestreo
                        normal_freq_band = np.array(freq_band) / nyquist
                        b, a = signal.butter(4, normal_freq_band, btype='band')
                        datos_filtrados = signal.filtfilt(b, a, datos)
                        return datos_filtrados

                    # Start entropy and averaged entropy values
                    entropia_shannon = []
                    entropia_promediada = []
                    kurtosis_resultados = []
                    frequency_index = []

                    # Cycle for the day-by-day calculation of the entropy in the files contained in the folder, using the time range (Start to End)
                    for dia in range(Start2, End2 + 1):

                        archivo = Nombre3 + '.'+ f"{dia:003}"       # Here you select the name previously calculated plus point and the value of each Julian day

                        # If there is no file in the list, the entire day is added with a value of zero
                        if not os.path.exists(os.path.join(carpeta, archivo)):
                            for _ in range(24):  # Adds 24 hours with zero value if there is no file
                                entropia_shannon.append(0)
                                entropia_promediada.append(0)
                                kurtosis_resultados.append(0)
                                frequency_index.append(0)
                            continue

                        # Designation of the data contained in the folder files
                        st = Stream()
                        st += read(os.path.join(carpeta, archivo))
                        frecuencia_muestreo = st[0].stats.sampling_rate
                        # calculation of the Highpass filter with the parameters indicated by the user.
                        st.filter('highpass', freq=frec4, corners=orden4, zerophase=True)
                        # Data value
                        datos = st[0].data

                        # Divide the data into hours and calculate entropy for each hour.
                        for hora in range(24):
                            inicio = hora * 3600  # start of time in seconds.
                            fin = inicio + 3600  # End of time in seconds.
                            datos_hora = datos[inicio:fin]

                            if len(datos_hora) < 3600:  # If the hour is incomplete, add zeros to the end.
                                datos_hora = np.append(datos_hora, np.zeros(3600 - len(datos_hora)))

                            # Accumulator of the calculated values of the Shannon entropy and the averaged entropy.
                            entropia_shannon.append(calcular_entropia(datos_hora))
                            entropia_promediada.append(calcular_entropia(datos_hora) / len(datos_hora))
                            kurtosis_resultados.append(calcular_kurtosis(datos_hora))
                            frequency_index.append(calcular_indice_frecuencias(datos_hora, frecuencia_muestreo))

                    # Converting shannon entropy value and averaged entropy to data array.
                    entropia_shannon = np.array(entropia_shannon)
                    entropia_promediada = np.array(entropia_promediada)
                    kurtosis_resultados = np.array(kurtosis_resultados)
                    frequency_index=np.array(frequency_index)

                    # Shannon Entropy Graph. Value of non-zero indices where there is no data.
                    indices_no_cero_shannon = np.where(entropia_shannon != 0)[0]

                    indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                    indices_no_cero_frecuency = np.where(frequency_index != 0)[0]

                    indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]

                    # **** SAVE THE RESULTS FILE .CSV
                    archivoFil2 = (self.label_8.text())                         # Reading directory label.

                    # **** SAVE THE RESULTS .npy FILE FOR LATER GRAPH *****
                    TW = str(Tam1)                                              # Convert Envelope Window value to string for names.
                    F1 = (Nombre3 + '_Highpass_Filter_1hr_Time_interval_Dots_and_Time' + '_Windows=' + TW + '.csv')            # Assign F1, Capture the name of the record and add the .csv extension.

                    # Guardar resultados en archivos .npy
                    F1a = (Nombre3 + '_Highpass_Filter_1hr_Time_interval_Dots_and_Time' + '_Windows=' + TW)
                    F2 = (archivoFil2 + F1)                                     # Assigns to F2 the directory plus the previous name where the record will be stored.
                    F3 = (archivoFil2 + F1a)

                    with open(F2, 'w+', newline='') as archivo_csv:             # Each result is saved in the file, day, time and values of Shannon's entropy and averaged.
                        writer = csv.writer(archivo_csv)
                        writer.writerow(['Day', ' Hour', ' Shannon Entropy', ' Averaged Shannon Entropy', ' Kurtosis', ' Frequency Index'])

                        for dia in range(1, Diferencia + 1):                        # Save data by day and time according to the time interval (Start - End)
                            for hora in range(24):

                                writer.writerow([dia, hora, entropia_shannon[(dia - 1) * 24 + hora], entropia_promediada[(dia - 1) * 24 + hora], kurtosis_resultados[(dia - 1) * 24 + hora], frequency_index[(dia - 1) * 24 + hora] ])

                    # Use example
                    Y = entropia_shannon
                    Y = np.where(Y == 0, np.nan, Y)

                    Y1 = kurtosis_resultados
                    Y1 = np.where(Y1 == 0, np.nan, Y1)

                    Y2 = frequency_index
                    Y2 = np.where(Y2 == 0, np.nan, Y2)


                    # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                    # Graph 1 - ENTROPY BY POINTS.

                    if self.checkBox_2.isChecked():                                 # CheckBox 2 of the Initial Time is activated (This marks time on the x axis)

                        if not self.lineEdit_14.text():
                            MensCombo14 = QMessageBox()
                            MensCombo14.setIcon(QMessageBox.Warning)
                            MensCombo14.setWindowTitle("Empty Year value")
                            MensCombo14.setText("Please, enter a valid value")
                            returnValue = MensCombo14.exec()

                        elif not self.lineEdit_15.text():
                            MensCombo15 = QMessageBox()
                            MensCombo15.setIcon(QMessageBox.Warning)
                            MensCombo15.setWindowTitle("Empty Month value")
                            MensCombo15.setText("Please, enter a valid value")
                            returnValue = MensCombo15.exec()

                        elif not self.lineEdit_16.text():
                            MensCombo16 = QMessageBox()
                            MensCombo16.setIcon(QMessageBox.Warning)
                            MensCombo16.setWindowTitle("Empty Day value")
                            MensCombo16.setText("Please, enter a valid value")
                            returnValue = MensCombo16.exec()

                        else:

                            # Data entry for enveloped (this value is a string by default)
                            Anio = (self.lineEdit_14.text())                            # Reading the Year value label.
                            Mes = (self.lineEdit_15.text())                             # Reading the Month value label.
                            Dia1 = (self.lineEdit_16.text())                            # Reading the Day value label.

                            # Convert the string value of the input text boxes to  integer

                            Anio1=int(Anio)                                             # Converts the Year value to integer.
                            Mes1=int(Mes)                                               # Converts the Month value to integer.
                            Dia2=int(Dia1)                                              # Converts the NaN Day value to integer.

                            # The date vector is created
                            fecha_inicio = datetime(Anio1, Mes1, Dia2)
                            dias = [fecha_inicio + timedelta(hours=i) for i in range(len(entropia_shannon[indices_no_cero_shannon]))]

                            # "Indices_no_cero_shannon" = np.where(entropia_shannon != 0)[0]
                            st = (dias, entropia_shannon[indices_no_cero_shannon])
                            np.save(F3, st)  # Save the ".npy" file in the directory.
                            plt.close()

                            st = (dias, entropia_shannon[indices_no_cero_shannon])

                            # Save the ".npy" file in the directory.
                            np.save(F3, st)
                            plt.close()                                             # Close the existing chart.

                            # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                            # Graph 1 - ENTROPY BY POINTS.

                            plt.plot(dias, entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='ShannonEntropy: Points per hour -> 1 Hr.')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_ShannonEntropy: Each point = 1 Hr. with Highpass filter', color ="darkgreen", fontsize=18)

                            # Graph 2 - Averaged Shannon Entropy Graph.

                            fig, ax = plt.subplots(1,1)
                            indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                            plt.plot(dias, entropia_promediada[indices_no_cero_promediada], "ob", mfc="b", mec = "b", label='ShannonAveragedEntropy: Points per hour -> 1 Hr.')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Shannon Averaged Entropy: Each point = 1 Hr. with Highpass filter.', color ="darkgreen", fontsize=18)

                            # Graph 3 - Graph of Shannon Entropy with the envelope.

                            # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE.

                            fig, ax = plt.subplots(1,1)

                            y_filtered = nanfastsmooth(Y.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                            plt.plot(dias, entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='Shannon_Entropy')
                            plt.plot(dias, y_filtered[indices_no_cero_shannon], color='blue', label='Envelope')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Envelope - Shannon Entropy: Each point = 1 Hr. with Highpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            # Graph 4 - Envelope only graph.

                            fig, ax = plt.subplots(1,1)

                            plt.plot(dias, y_filtered[indices_no_cero_shannon], label='Filtered Signal', color='blue')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Only the envelope of Shannon entropy: Each point = 1 Hr. with Highpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                            # Graph 5 Frequency Index with enveloped
                            fig, ax = plt.subplots(1,1)

                            y_filtered3 = nanfastsmooth(Y2.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                            plt.plot(dias, frequency_index[indices_no_cero_frecuency], 'o-', label='Frequency Index')
                            plt.plot(dias, y_filtered3[indices_no_cero_frecuency], label='Envelope', color='red')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                            plt.title(Nombre3 + ' Frequency Index: Each point = 1 Hr. with Highpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            # Graph 6 Kurtosis with Envelope
                            fig, ax = plt.subplots(1,1)
                            indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]

                            # The date vector is created
                            fecha_inicio = datetime(Anio1, Mes1, Dia2)
                            dias2 = [fecha_inicio + timedelta(hours=i) for i in range(len(entropia_shannon[indices_no_cero_kurtosis]))]

                            y_filtered2 = nanfastsmooth(Y1.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                            plt.plot(dias2, kurtosis_resultados[indices_no_cero_kurtosis], 'o', label='Kurtosis')
                            plt.plot(dias2, y_filtered2[indices_no_cero_kurtosis], label='Envelope', color='red')
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                            plt.title(Nombre3 + ' Kurtosis: Each point = 1 Hr. with Highpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)

                            plt.show()

                    else:

                        # Plot the vectors into separate figures.
                        dias = np.arange(1, 8761 + 1)

                        st = (dias, entropia_shannon[indices_no_cero_shannon])

                        np.save(F3, st)  # Save the ".npy" file in the directory.
                        plt.close()

                        # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                        # Graph 1 - ENTROPY BY POINTS.

                        plt.plot(dias[indices_no_cero_shannon], entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='ShannonEntropy: Points per hour -> 1 Hr.')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_ShannonEntropy: Each point = 1 Hr. with Highpass filter', color ="darkgreen", fontsize=18)

                        # Graph 2 - Averaged Shannon Entropy Graph.

                        fig, ax = plt.subplots(1,1)
                        indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                        plt.plot(dias[indices_no_cero_promediada], entropia_promediada[indices_no_cero_promediada], "ob", mfc="b", mec = "b", label='ShannonAveragedEntropy: Points per hour -> 1 Hr.')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Shannon Averaged Entropy: Each point = 1 Hr. with Highpass filter.', color ="darkgreen", fontsize=18)

                        # Graph 3 - Graph of Shannon Entropy with the envelope.

                        # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE.

                        fig, ax = plt.subplots(1,1)

                        y_filtered = nanfastsmooth(Y.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                        plt.plot(dias[indices_no_cero_shannon], entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='Shannon Entropy')
                        plt.plot(dias[indices_no_cero_shannon], y_filtered[indices_no_cero_shannon], label='Envelope', color='blue')
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Envelope - Shannon Entropy: Each point = 1 Hr. with Highpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                        # Graph 4 - Envelope only graph.

                        fig, ax = plt.subplots(1,1)

                        plt.plot(dias[indices_no_cero_shannon], y_filtered[indices_no_cero_shannon], label='Filtered Signal', color='blue')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Only the envelope of Shannon entropy: Each point = 1 Hr. with Highpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                        # Graph 5 Frequency Index with Envelope
                        fig, ax = plt.subplots(1,1)

                        y_filtered3 = nanfastsmooth(Y2.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                        plt.plot(dias[indices_no_cero_frecuency], frequency_index[indices_no_cero_frecuency], 'o-', label='Frequency Index')
                        plt.plot(dias[indices_no_cero_frecuency], y_filtered3[indices_no_cero_frecuency], label='Envelope', color='red')
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                        plt.title(Nombre3 + ' Frequency Index: Each point = 1 Hr. with Highpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)

                        # Graph 6 Kurtosis with Envelope
                        fig, ax = plt.subplots(1,1)
                        indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]

                        y_filtered2 = nanfastsmooth(Y1.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                        plt.plot(dias[indices_no_cero_kurtosis], kurtosis_resultados[indices_no_cero_kurtosis], 'o', label='Kurtosis')
                        plt.plot(dias[indices_no_cero_kurtosis], y_filtered2[indices_no_cero_kurtosis], label='Envelope', color='red')
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                        plt.title(Nombre3 + ' Kurtosis: Each point = 1 Hr. with Highpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)

                        plt.show()


            else:                                           # Here the value of the entropy is calculated without the time interval (Start - End)

                if not self.label_5.text():
                    MensCombo1 = QMessageBox()
                    MensCombo1.setIcon(QMessageBox.Warning)
                    MensCombo1.setWindowTitle("Empty directory to upload records")
                    MensCombo1.setText("Please, enter a valid name of directory")
                    returnValue = MensCombo1.exec()

                elif not self.label_8.text():
                    MensCombo2 = QMessageBox()
                    MensCombo2.setIcon(QMessageBox.Warning)
                    MensCombo2.setWindowTitle("Empty path to store CSV/NPY file")
                    MensCombo2.setText("Please, enter a valid name of directory")
                    returnValue = MensCombo2.exec()

                elif not self.lineEdit_5.text():
                    MensCombo3 = QMessageBox()
                    MensCombo3.setIcon(QMessageBox.Warning)
                    MensCombo3.setWindowTitle("Empty Smoothing type")
                    MensCombo3.setText("Please, enter a valid Value")
                    returnValue = MensCombo3.exec()

                elif not self.lineEdit_6.text():
                    MensCombo4 = QMessageBox()
                    MensCombo4.setIcon(QMessageBox.Warning)
                    MensCombo4.setWindowTitle("Empty Frequency")
                    MensCombo4.setText("Please, enter a valid Value")
                    returnValue = MensCombo4.exec()

                elif not self.lineEdit_7.text():
                    MensCombo5 = QMessageBox()
                    MensCombo5.setIcon(QMessageBox.Warning)
                    MensCombo5.setWindowTitle("Empty Filter Order")
                    MensCombo5.setText("Please, enter a valid Value")
                    returnValue = MensCombo5.exec()

                elif not self.lineEdit_10.text():
                    MensCombo6 = QMessageBox()
                    MensCombo6.setIcon(QMessageBox.Warning)
                    MensCombo6.setWindowTitle("Empty Envelope Window size")
                    MensCombo6.setText("Please, enter a valid Value")
                    returnValue = MensCombo6.exec()

                elif not self.lineEdit_13.text():
                    MensCombo7 = QMessageBox()
                    MensCombo7.setIcon(QMessageBox.Warning)
                    MensCombo7.setWindowTitle("Empty NaN Tolerance")
                    MensCombo7.setText("Please, enter a valid Value")
                    returnValue = MensCombo7.exec()

                else:
                    # Filtering with a Highpass 1 Hr.
                    plt.close()                                                 # Close the existing chart.

                    carpeta = (self.label_5.text())                             # Reading the directory or file folder label.

                    # Code to detect the contents of the folder and the files that the folder contains
                    with os.scandir(carpeta) as ficheros:
                        ficheros4 = [fichero.name for fichero in ficheros if fichero.is_file()]

                    # The contents of the files in "ficheros4" is a list. This code converts them to string
                    lfiles = [str(elemento) for elemento in ficheros4]

                    # Code used to determine the name of the files contained in the folder and to be used in the loading loop
                    Iniciolfiles = lfiles[0]                                    # Detects the numeric value of the "Start" in the name
                    Finlfiles = lfiles[-1]                                      # Detects the numerical value of the "End" in the name
                    Indice1 = Iniciolfiles.rfind('.')                           # Determines the index, which will be marked by the dot at the end for the extension
                    Nombre3 = Iniciolfiles[0:Indice1]                           # Indicates the name of the file in str (minus) the index or extension (each day)

                    # Data entry from labels and fields or text boxes (this value is a string by default)
                    num_temporal_units = (self.lineEdit_5.text())               # label reading of the total number of daily files.
                    frec3 = (self.lineEdit_6.text())                            # reading frequency Label.
                    orden1 = (self.lineEdit_7.text())                           # Reading the Filter Order Label.

                    # Data entry for enveloped (this value is a string by default)
                    Tam = (self.lineEdit_10.text())                             # Reading the envelope window size label.
                    Tsua = (self.lineEdit_5.text())                             # Reading the Smoothing type label.
                    Tnan = (self.lineEdit_13.text())                            # Reading the NaN Tolerance label.

                    # Convert the string value of the input text boxes to float or integer
                    frec4=float(frec3)                                          # Converts Frequency value to float.
                    orden4=int(orden1)                                          # Converts filter order value to integer.

                    Tam1=int(Tam)                                               # Converts the envelope window size value to integer.
                    Tsua1=int(Tsua)                                             # Converts the Smoothing type value to integer.
                    Tnan1=int(Tnan)                                             # Converts the NaN Tolerance value to integer.

                    timeIn = 365

                    # Function for Shannon entropy calculating
                    def calcular_entropia(datos):
                        params = stats.norm.fit(datos)
                        dist = stats.norm(*params)
                        probabilidades = dist.pdf(datos)
                        entropia = -np.sum(probabilidades * np.log2(probabilidades))
                        return entropia

                     # Function for Kurtosis calculating
                    def calcular_kurtosis(datos):
                        n = len(datos)
                        media = np.mean(datos)
                        varianza = np.var(datos)
                        desviacion_estandar = np.sqrt(varianza)

                        if desviacion_estandar == 0:
                            return 0.0
                        kurtosis = np.sum((datos - media)**4) / (n * desviacion_estandar**4) - 3.0
                        return kurtosis

                    # Function for Shannon entropy enveloped calculating
                    def nanfastsmooth(Y, w, type=1, tol=0.5):

                        """
                        Smooths vector Y with a moving average of width w, ignoring NaNs in data.

                        Parameters:
                        Y (numpy array): Input signal.
                        w (int): Window width.
                        type (int): Smooth type (1 for rectangular, 2 for triangular, 3 for pseudo-Gaussian).
                        tol (float): Tolerance to NaNs between 0 and 1.

                        Returns:
                        numpy array: Smoothed signal.
                        """
                        mask = ~np.isnan(Y)  # Create a boolean mask for non-NaN values
                        Y[mask] = nanfastsmooth_core(Y[mask], w, type, tol)  # Apply smoothing to non-NaN values
                        return Y

                    # Function for Shannon entropy enveloped type calculating. For default the value = 3
                    def nanfastsmooth_core(Y, w, type, tol):
                        if type == 1:
                            SmoothY = moving_average(Y, w)
                        elif type == 2:
                            SmoothY = moving_average(moving_average(Y, w), w)
                        elif type == 3:
                            SmoothY = moving_average(moving_average(moving_average(Y, w), w), w)

                        return SmoothY

                    def moving_average(Y, window_size):
                        return np.convolve(Y, np.ones(window_size)/window_size, mode='same')

                    def calcular_indice_frecuencias(datos, frecuencia_muestreo):
                        # Frequency filter applied
                        freq_bajas = (1, 5.5)
                        freq_altas = (6, 16)

                        datos_bajas = apply_bandpass_filter(datos, frecuencia_muestreo, freq_bajas)
                        datos_altas = apply_bandpass_filter(datos, frecuencia_muestreo, freq_altas)

                        # The energy is calculated for each signal
                        energia_bajas = np.sum(datos_bajas ** 2)
                        energia_altas = np.sum(datos_altas ** 2)

                        # The frequency index is calculated
                        indice_frecuencias = np.log(energia_altas / energia_bajas) if energia_bajas != 0 else np.nan
                        return indice_frecuencias

                    def apply_bandpass_filter(datos, frecuencia_muestreo, freq_band):
                        nyquist = 0.5 * frecuencia_muestreo
                        normal_freq_band = np.array(freq_band) / nyquist
                        b, a = signal.butter(4, normal_freq_band, btype='band')
                        datos_filtrados = signal.filtfilt(b, a, datos)
                        return datos_filtrados

                    # Start entropy and averaged entropy values
                    entropia_shannon = []
                    entropia_promediada = []
                    kurtosis_resultados = []
                    frequency_index = []

                    # Cycle for the day-by-day calculation of the entropy in the files contained in the folder, using the time range (Start to End)
                    for dia in range(1, timeIn + 1):

                        archivo = Nombre3 + '.'+ f"{dia:003}"       # Here you select the name previously calculated plus point and the value of each Julian day

                        # If there is no file in the list, the entire day is added with a value of zero
                        if not os.path.exists(os.path.join(carpeta, archivo)):
                            for _ in range(24):  # Adds 24 hours with zero value if there is no file
                                entropia_shannon.append(0)
                                entropia_promediada.append(0)
                                kurtosis_resultados.append(0)
                                frequency_index.append(0)
                            continue

                        # Designation of the data contained in the folder files
                        st = Stream()
                        st += read(os.path.join(carpeta, archivo))
                        frecuencia_muestreo = st[0].stats.sampling_rate
                        # calculation of the Highpass filter with the parameters indicated by the user.
                        st.filter('highpass', freq=frec4, corners=orden4, zerophase=True)
                        # Data value
                        datos = st[0].data

                        # Divide the data into hours and calculate entropy for each hour.
                        for hora in range(24):
                            inicio = hora * 3600  # start of time in seconds.
                            fin = inicio + 3600  # End of time in seconds.
                            datos_hora = datos[inicio:fin]

                            if len(datos_hora) < 3600:  # If the hour is incomplete, add zeros to the end.
                                datos_hora = np.append(datos_hora, np.zeros(3600 - len(datos_hora)))

                            # Accumulator of the calculated values of the Shannon entropy and the averaged entropy.
                            entropia_shannon.append(calcular_entropia(datos_hora))
                            entropia_promediada.append(calcular_entropia(datos_hora) / len(datos_hora))
                            kurtosis_resultados.append(calcular_kurtosis(datos_hora))
                            frequency_index.append(calcular_indice_frecuencias(datos_hora, frecuencia_muestreo))

                    # Converting shannon entropy value and averaged entropy to data array.
                    entropia_shannon = np.array(entropia_shannon)
                    entropia_promediada = np.array(entropia_promediada)
                    kurtosis_resultados = np.array(kurtosis_resultados)
                    frequency_index=np.array(frequency_index)

                    # Shannon Entropy Graph. Value of non-zero indices where there is no data.
                    indices_no_cero_shannon = np.where(entropia_shannon != 0)[0]

                    indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                    indices_no_cero_frecuency = np.where(frequency_index != 0)[0]

                    indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]


                    # **** SAVE THE RESULTS FILE .CSV
                    archivoFil2 = (self.label_8.text())                         # Reading directory label.

                    # **** SAVE THE RESULTS .npy FILE FOR LATER GRAPH *****
                    TW = str(Tam1)                                              # Convert Envelope Window value to string for names.
                    F1 = (Nombre3 + '_Highpass_Filter_1hr_without_Time_interval_Dots_and_Time' + '_Windows=' + TW + '.csv')            # Assign F1, Capture the name of the record and add the .csv extension.

                    # Guardar resultados en archivos .npy
                    F1a = (Nombre3 + '_Highpass_Filter_1hr_without_Time_interval_Dots_and_Time' + '_Windows=' + TW)
                    F2 = (archivoFil2 + F1)                                     # Assigns to F2 the directory plus the previous name where the record will be stored.
                    F3 = (archivoFil2 + F1a)

                    with open(F2, 'w+', newline='') as archivo_csv:             # Each result is saved in the file, day, time and values of Shannon's entropy and averaged.
                        writer = csv.writer(archivo_csv)
                        writer.writerow(['Day', ' hour', ' Shannon Entropy', ' Averaged Shannon Entropy', ' Envelope Shannon Entropy', ' Kurtosis', ' Frequency Index'])

                        for dia in range(1, timeIn + 1):                        # Save data by day and time according to the time interval (Start - End)
                            for hora in range(24):
                                writer.writerow([dia, hora, entropia_shannon[(dia - 1) * 24 + hora], entropia_promediada[(dia - 1) * 24 + hora], kurtosis_resultados[(dia - 1) * 24 + hora], frequency_index[(dia - 1) * 24 + hora] ])

                    # Use example
                    Y = entropia_shannon
                    Y = np.where(Y == 0, np.nan, Y)

                    Y1 = kurtosis_resultados
                    Y1 = np.where(Y1 == 0, np.nan, Y1)

                    Y2 = frequency_index
                    Y2 = np.where(Y2 == 0, np.nan, Y2)

                    # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                    # Graph 1 - ENTROPY BY POINTS.

                    if self.checkBox_2.isChecked():                                 # checkBox for Initial Time

                        if not self.lineEdit_14.text():
                            MensCombo14 = QMessageBox()
                            MensCombo14.setIcon(QMessageBox.Warning)
                            MensCombo14.setWindowTitle("Empty Year value")
                            MensCombo14.setText("Please, enter a valid value")
                            returnValue = MensCombo14.exec()

                        elif not self.lineEdit_15.text():
                            MensCombo15 = QMessageBox()
                            MensCombo15.setIcon(QMessageBox.Warning)
                            MensCombo15.setWindowTitle("Empty Month value")
                            MensCombo15.setText("Please, enter a valid value")
                            returnValue = MensCombo15.exec()

                        elif not self.lineEdit_16.text():
                            MensCombo16 = QMessageBox()
                            MensCombo16.setIcon(QMessageBox.Warning)
                            MensCombo16.setWindowTitle("Empty Day value")
                            MensCombo16.setText("Please, enter a valid value")
                            returnValue = MensCombo16.exec()

                        else:

                            # Data entry for enveloped (this value is a string by default)
                            Anio = (self.lineEdit_14.text())                            # Reading the Year value label.
                            Mes = (self.lineEdit_15.text())                             # Reading the Month value label.
                            Dia1 = (self.lineEdit_16.text())                            # Reading the Day value label.

                            # Convert the string value of the input text boxes to  integer

                            Anio1=int(Anio)                                             # Converts the Year value to integer.
                            Mes1=int(Mes)                                               # Converts the Month value to integer.
                            Dia2=int(Dia1)                                              # Converts the NaN Day value to integer.

                            # The date vector is created
                            fecha_inicio = datetime(Anio1, Mes1, Dia2)
                            dias = [fecha_inicio + timedelta(hours=i) for i in range(len(entropia_shannon[indices_no_cero_shannon]))]

                            st = (dias, entropia_shannon[indices_no_cero_shannon])

                            # Save the ".npy" file in the directory.
                            np.save(F3, st)
                            plt.close()                                             # Close the existing chart.

                            # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                            # Graph 1 - ENTROPY BY POINTS.

                            plt.plot(dias, entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='Shannon Entropy')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_ShannonEntropy: Each point = 1 Hr. with Highpass filter', color ="darkgreen", fontsize=18)

                            # Graph 2 - Averaged Shannon Entropy Graph.

                            fig, ax = plt.subplots(1,1)
                            indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                            plt.plot(dias, entropia_promediada[indices_no_cero_promediada], "ob", mfc="b", mec = "b", label='ShannonAveragedEntropy: Points per hour -> 1 Hr.')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Shannon Averaged Entropy: Each point = 1 Hr. with Highpass filter.', color ="darkgreen", fontsize=18)

                            # Graph 3 - Graph of Shannon Entropy with the envelope.

                            # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE.

                            fig, ax = plt.subplots(1,1)

                            y_filtered = nanfastsmooth(Y.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                            plt.plot(dias, entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='Shannon Entropy')
                            plt.plot(dias, y_filtered[indices_no_cero_shannon], label='Envelope', color='blue')
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Envelope - Shannon Entropy: Each point = 1 Hr. with Highpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                            # Graph 4 - Envelope only graph.

                            fig, ax = plt.subplots(1,1)

                            plt.plot(dias, y_filtered[indices_no_cero_shannon], label='Filtered Signal', color='blue')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Only the envelope of Shannon entropy: Each point = 1 Hr. with Highpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                            # Graph 5 Frequency Index with Envelope
                            fig, ax = plt.subplots(1,1)

                            y_filtered3 = nanfastsmooth(Y2.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                            plt.plot(dias, frequency_index[indices_no_cero_frecuency], 'o-', label='Frequency Index')
                            plt.plot(dias, y_filtered3[indices_no_cero_frecuency], label='Envelope', color='red')
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                            plt.title(Nombre3 + ' Frequency Index: Each point = 1 Hr. with Highpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)

                            # Graph 6 Kurtosis with Envelope
                            fig, ax = plt.subplots(1,1)
                            indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]

                            # The date vector is created
                            fecha_inicio = datetime(Anio1, Mes1, Dia2)
                            dias2 = [fecha_inicio + timedelta(hours=i) for i in range(len(entropia_shannon[indices_no_cero_kurtosis]))]

                            y_filtered2 = nanfastsmooth(Y1.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                            plt.plot(dias2, kurtosis_resultados[indices_no_cero_kurtosis], 'o', label='Kurtosis')
                            plt.plot(dias2, y_filtered2[indices_no_cero_kurtosis], label='Envelope', color='red')
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                            plt.title(Nombre3 + ' Kurtosis: Each point = 1 Hr. with Highpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)

                            plt.show()

                    else:

                        # Plot the vectors into separate figures.
                        dias = np.arange(1, 8761 + 1)

                        st = (dias, entropia_shannon[indices_no_cero_shannon])

                        np.save(F3, st)  # Save the ".npy" file in the directory.
                        plt.close()

                        # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                        # Graph 1 - ENTROPY BY POINTS.

                        plt.plot(dias[indices_no_cero_shannon], entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='ShannonEntropy: Points per hour -> 1 Hr.')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_ShannonEntropy: Each point = 1 Hr. with Highpass filter', color ="darkgreen", fontsize=18)

                        # Graph 2 - Averaged Shannon Entropy Graph.

                        fig, ax = plt.subplots(1,1)
                        indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                        plt.plot(dias[indices_no_cero_promediada], entropia_promediada[indices_no_cero_promediada], "ob", mfc="b", mec = "b", label='ShannonAveragedEntropy: Points per hour -> 1hr.')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Shannon Averaged Entropy: Each point = 1 Hr. with Highpass filter.', color ="darkgreen", fontsize=18)

                        # Graph 3 - Graph of Shannon Entropy plus the envelope.

                        # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE.

                        fig, ax = plt.subplots(1,1)

                        y_filtered = nanfastsmooth(Y.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                        plt.plot(dias[indices_no_cero_shannon], entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='Shannon Entropy')
                        plt.plot(dias[indices_no_cero_shannon], y_filtered[indices_no_cero_shannon], label='Envelope', color='blue')
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Envelope - Shannon Entropy: Each point = 1 Hr. with Highpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                        # Graph 4 - Envelope only graph.

                        fig, ax = plt.subplots(1,1)

                        plt.plot(dias[indices_no_cero_shannon], y_filtered[indices_no_cero_shannon], label='Filtered Signal', color='blue')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Only the envelope of Shannon entropy: Each point = 1 Hr. with Highpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                        # Graph 5 Frequency Index with Envelope
                        fig, ax = plt.subplots(1,1)

                        y_filtered3 = nanfastsmooth(Y2.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                        plt.plot(dias[indices_no_cero_frecuency], frequency_index[indices_no_cero_frecuency], 'o-', label='Frequency Index')
                        plt.plot(dias[indices_no_cero_frecuency], y_filtered3[indices_no_cero_frecuency], label='Envelope', color='red')
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                        plt.title(Nombre3 + ' Frequency Index: Each point = 1 Hr. with Highpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)

                        # Graph 6 Kurtosis with Envelope
                        fig, ax = plt.subplots(1,1)
                        indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]
                        #dias2 = [fecha_inicio + timedelta(hours=i) for i in range(len(entropia_shannon[indices_no_cero_kurtosis]))]

                        y_filtered2 = nanfastsmooth(Y1.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                        plt.plot(dias[indices_no_cero_kurtosis], kurtosis_resultados[indices_no_cero_kurtosis], 'o', label='Kurtosis')
                        plt.plot(dias[indices_no_cero_kurtosis], y_filtered2[indices_no_cero_kurtosis], label='Envelope', color='red')
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                        plt.title(Nombre3 + ' Kurtosis: Each point = 1 Hr. with Highpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)

                        plt.show()


        except:
                plt.close()                                                 # Close the existing chart.
                msgBox = QMessageBox()
                msgBox.setIcon(QMessageBox.Warning)
                msgBox.setText("The File Does not exist, is Invalid or the CSV old file is open. Please close, try again ...")
                msgBox.setWindowTitle("Invalid Record or CSV Old file is open ")
                returnValue = msgBox.exec()
                pass


    def filtropasabanda(self):                                               # 3.- Function to execute the Bandpass filter with 1 hr. analysis window.

        try:

            # Verifying that the checkbox is true. Work with time intervals.

            if self.checkBox.isChecked() == True:

                # Verify (Validation), that the text box and label is not empty

                if not self.label_5.text():
                    MensCombo1 = QMessageBox()
                    MensCombo1.setIcon(QMessageBox.Warning)
                    MensCombo1.setWindowTitle("Empty directory to upload records")
                    MensCombo1.setText("Please, enter a valid name of directory")
                    returnValue = MensCombo1.exec()

                elif not self.label_8.text():
                    MensCombo2 = QMessageBox()
                    MensCombo2.setIcon(QMessageBox.Warning)
                    MensCombo2.setWindowTitle("Empty path to store CSV/NPY file")
                    MensCombo2.setText("Please, enter a valid name of directory")
                    returnValue = MensCombo2.exec()

                elif not self.lineEdit_5.text():
                    MensCombo3 = QMessageBox()
                    MensCombo3.setIcon(QMessageBox.Warning)
                    MensCombo3.setWindowTitle("Empty Smoothing type")
                    MensCombo3.setText("Please, enter a valid Value")
                    returnValue = MensCombo3.exec()

                elif not self.lineEdit_7.text():
                    MensCombo4 = QMessageBox()
                    MensCombo4.setIcon(QMessageBox.Warning)
                    MensCombo4.setWindowTitle("Empty Filter Order")
                    MensCombo4.setText("Please, enter a valid Value")
                    returnValue = MensCombo4.exec()

                elif not self.lineEdit_8.text():
                    MensCombo5 = QMessageBox()
                    MensCombo5.setIcon(QMessageBox.Warning)
                    MensCombo5.setWindowTitle("Empty Min. Frequency")
                    MensCombo5.setText("Please, enter a valid Value")
                    returnValue = MensCombo5.exec()

                elif not self.lineEdit_9.text():
                    MensCombo6 = QMessageBox()
                    MensCombo6.setIcon(QMessageBox.Warning)
                    MensCombo6.setWindowTitle("Empty Max. Frequency")
                    MensCombo6.setText("Please, enter a valid Value")
                    returnValue = MensCombo6.exec()

                elif not self.lineEdit_10.text():
                    MensCombo7 = QMessageBox()
                    MensCombo7.setIcon(QMessageBox.Warning)
                    MensCombo7.setWindowTitle("Empty Envelope Window size")
                    MensCombo7.setText("Please, enter a valid Value")
                    returnValue = MensCombo7.exec()

                elif not self.lineEdit_11.text():
                    MensCombo8 = QMessageBox()
                    MensCombo8.setIcon(QMessageBox.Warning)
                    MensCombo8.setWindowTitle("Empty Start time")
                    MensCombo8.setText("Please, enter a valid Value")
                    returnValue = MensCombo8.exec()

                elif not self.lineEdit_12.text():
                    MensCombo9 = QMessageBox()
                    MensCombo9.setIcon(QMessageBox.Warning)
                    MensCombo9.setWindowTitle("Empty End time")
                    MensCombo9.setText("Please, enter a valid Value")
                    returnValue = MensCombo9.exec()

                elif not self.lineEdit_13.text():
                    MensCombo10 = QMessageBox()
                    MensCombo10.setIcon(QMessageBox.Warning)
                    MensCombo10.setWindowTitle("Empty NaN Tolerance")
                    MensCombo10.setText("Please, enter a valid Value")
                    returnValue = MensCombo10.exec()

                else:
                    # Filtering with a Bandpass 1 Hr.
                    plt.close()                                                 # Close the existing chart.

                    carpeta = (self.label_5.text())                             # Reading the directory or file folder label.

                    # Code to detect the contents of the folder and the files that the folder contains
                    with os.scandir(carpeta) as ficheros:
                        ficheros4 = [fichero.name for fichero in ficheros if fichero.is_file()]

                    # The contents of the files in "ficheros4" is a list. This code converts them to string
                    lfiles = [str(elemento) for elemento in ficheros4]

                    # Code used to determine the name of the files contained in the folder and to be used in the loading loop
                    Iniciolfiles = lfiles[0]                                    # Detects the numeric value of the "Start" in the name
                    Finlfiles = lfiles[-1]                                      # Detects the numerical value of the "End" in the name
                    Indice1 = Iniciolfiles.rfind('.')                           # Determines the index, which will be marked by the dot at the end for the extension
                    Nombre3 = Iniciolfiles[0:Indice1]                           # Indicates the name of the file in str (minus) the index or extension (each day)

                    # Data entry from labels and fields or text boxes (this value is a string by default)

                    frecMin = (self.lineEdit_8.text())                          # Minimum Frequency label reading.
                    frecMax = (self.lineEdit_9.text())                          # Maximum Frequency label reading.
                    orden1 = (self.lineEdit_7.text())                           # Reading the Filter Order Label.

                    Start1 = (self.lineEdit_11.text())                          # Star Time Size label reading.
                    End1 = (self.lineEdit_12.text())                            # End Time Size label reading.

                    # Convert the string value of the input text boxes to float or integer
                    frec7=float(frecMin)                                        # Converts the Minimum Frequency value to float.
                    frec8=float(frecMax)                                        # Converts the Maximum Frequency value to float.
                    orden7=int(orden1)                                          # Converts filter order value to integer.

                     # Data entry for enveloped (this value is a string by default)
                    Tam = (self.lineEdit_10.text())                             # Reading the envelope window size label.
                    Tsua = (self.lineEdit_5.text())                             # Reading the Smoothing type label.
                    Tnan = (self.lineEdit_13.text())                            # Reading the NaN Tolerance label.

                    Tam1=int(Tam)                                               # Converts the envelope window size value to integer.
                    Tsua1=int(Tsua)                                             # Converts the Smoothing type value to integer.
                    Tnan1=int(Tnan)                                             # Converts the NaN Tolerance value to integer.

                    timeIn = 365

                    Start2=int(Start1)                                          # Converts the Start time window size value to an integer.
                    End2=int(End1)                                              # Converts the End time window size value to an integer.

                    Diferencia = End2 - Start2                                  # Value of the difference between end and start to obtain the number of days to calculate

                    # Function for Shannon entropy calculating
                    def calcular_entropia(datos):
                        params = stats.norm.fit(datos)
                        dist = stats.norm(*params)
                        probabilidades = dist.pdf(datos)
                        entropia = -np.sum(probabilidades * np.log2(probabilidades))
                        return entropia

                    # Function for Kurtosis calculating
                    def calcular_kurtosis(datos):
                        n = len(datos)
                        media = np.mean(datos)
                        varianza = np.var(datos)
                        desviacion_estandar = np.sqrt(varianza)

                        if desviacion_estandar == 0:
                            return 0.0
                        kurtosis = np.sum((datos - media)**4) / (n * desviacion_estandar**4) - 3.0
                        return kurtosis

                    # Function for Shannon entropy enveloped calculating
                    def nanfastsmooth(Y, w, type=1, tol=0.5):

                        """
                        Smooths vector Y with a moving average of width w, ignoring NaNs in data.

                        Parameters:
                        Y (numpy array): Input signal.
                        w (int): Window width.
                        type (int): Smooth type (1 for rectangular, 2 for triangular, 3 for pseudo-Gaussian).
                        tol (float): Tolerance to NaNs between 0 and 1.

                        Returns:
                        numpy array: Smoothed signal.
                        """
                        mask = ~np.isnan(Y)  # Create a boolean mask for non-NaN values
                        Y[mask] = nanfastsmooth_core(Y[mask], w, type, tol)  # Apply smoothing to non-NaN values
                        return Y

                    # Function for Shannon entropy enveloped type calculating. For default the value = 3
                    def nanfastsmooth_core(Y, w, type, tol):
                        if type == 1:
                            SmoothY = moving_average(Y, w)
                        elif type == 2:
                            SmoothY = moving_average(moving_average(Y, w), w)
                        elif type == 3:
                            SmoothY = moving_average(moving_average(moving_average(Y, w), w), w)

                        return SmoothY

                    def moving_average(Y, window_size):
                        return np.convolve(Y, np.ones(window_size)/window_size, mode='same')

                    def calcular_indice_frecuencias(datos, frecuencia_muestreo):
                        # Aplicar filtro en frecuencia
                        freq_bajas = (1, 5.5)
                        freq_altas = (6, 16)

                        datos_bajas = apply_bandpass_filter(datos, frecuencia_muestreo, freq_bajas)
                        datos_altas = apply_bandpass_filter(datos, frecuencia_muestreo, freq_altas)

                        # Calcular energía para cada señal
                        energia_bajas = np.sum(datos_bajas ** 2)
                        energia_altas = np.sum(datos_altas ** 2)

                        # Calcular índice de frecuencias
                        indice_frecuencias = np.log(energia_altas / energia_bajas) if energia_bajas != 0 else np.nan
                        return indice_frecuencias

                    def apply_bandpass_filter(datos, frecuencia_muestreo, freq_band):
                        nyquist = 0.5 * frecuencia_muestreo
                        normal_freq_band = np.array(freq_band) / nyquist
                        b, a = signal.butter(4, normal_freq_band, btype='band')
                        datos_filtrados = signal.filtfilt(b, a, datos)
                        return datos_filtrados

                    # Start entropy and averaged entropy values
                    entropia_shannon = []
                    entropia_promediada = []
                    kurtosis_resultados = []
                    frequency_index = []

                    # Cycle for the day-by-day calculation of the entropy in the files contained in the folder, using the time range (Start to End)
                    for dia in range(Start2, End2 + 1):

                        archivo = Nombre3 + '.'+ f"{dia:003}"       # Here you select the name previously calculated plus point and the value of each Julian day

                        # If there is no file in the list, the entire day is added with a value of zero
                        if not os.path.exists(os.path.join(carpeta, archivo)):
                            for _ in range(24):  # Adds 24 hours with zero value if there is no file
                                entropia_shannon.append(0)
                                entropia_promediada.append(0)
                                kurtosis_resultados.append(0)
                                frequency_index.append(0)
                            continue

                        # Designation of the data contained in the folder files
                        st = Stream()
                        st += read(os.path.join(carpeta, archivo))
                        frecuencia_muestreo = st[0].stats.sampling_rate
                        # calculation of the bandpass filter with the parameters indicated by the user.
                        st.filter('bandpass', freqmin=frec7, freqmax=frec8, corners=orden7, zerophase=True)
                        # Data value
                        datos = st[0].data

                        # Divide the data into hours and calculate entropy for each hour.
                        for hora in range(24):
                            inicio = hora * 3600  # start of time in seconds.
                            fin = inicio + 3600  # End of time in seconds.
                            datos_hora = datos[inicio:fin]

                            if len(datos_hora) < 3600:  # If the hour is incomplete, add zeros to the end.
                                datos_hora = np.append(datos_hora, np.zeros(3600 - len(datos_hora)))

                            # Accumulator of the calculated values of the Shannon entropy and the averaged entropy.
                            entropia_shannon.append(calcular_entropia(datos_hora))
                            entropia_promediada.append(calcular_entropia(datos_hora) / len(datos_hora))
                            kurtosis_resultados.append(calcular_kurtosis(datos_hora))
                            frequency_index.append(calcular_indice_frecuencias(datos_hora, frecuencia_muestreo))

                    # Converting shannon entropy value and averaged entropy to data array.
                    entropia_shannon = np.array(entropia_shannon)
                    entropia_promediada = np.array(entropia_promediada)
                    kurtosis_resultados = np.array(kurtosis_resultados)
                    frequency_index=np.array(frequency_index)

                    # Shannon Entropy Graph. Value of non-zero indices where there is no data.
                    indices_no_cero_shannon = np.where(entropia_shannon != 0)[0]

                    indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                    indices_no_cero_frecuency = np.where(frequency_index != 0)[0]

                    indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]

                    # **** SAVE THE RESULTS FILE .CSV
                    archivoFil2 = (self.label_8.text())                         # Reading directory label.

                    # **** SAVE THE RESULTS .npy FILE FOR LATER GRAPH *****
                    TW = str(Tam1)                                              # Convert Envelope Window value to string for names.
                    F1 = (Nombre3 + '_Bandpass_Filter_1hr_Time_interval_Dots_and_Time' + '_Windows=' + TW + '.csv')            # Assign F1, Capture the name of the record and add the .csv extension.

                    # Guardar resultados en archivos .npy
                    F1a = (Nombre3 + '_Bandpass_Filter_1hr_Time_interval_Dots_and_Time' + '_Windows=' + TW)
                    F2 = (archivoFil2 + F1)                                     # Assigns to F2 the directory plus the previous name where the record will be stored.
                    F3 = (archivoFil2 + F1a)

                    with open(F2, 'w+', newline='') as archivo_csv:             # Each result is saved in the file, day, time and values of Shannon's entropy and averaged.
                        writer = csv.writer(archivo_csv)
                        writer.writerow(['Day', ' hour', ' Shannon Entropy', ' Averaged Shannon Entropy', ' Enveloped Shannon Entropy', ' Kurtosis', ' Frequency Index'])

                        for dia in range(1, Diferencia + 1):                        # Save data by day and time according to the time interval (Start - End)
                            for hora in range(24):

                                writer.writerow([dia, hora, entropia_shannon[(dia - 1) * 24 + hora], entropia_promediada[(dia - 1) * 24 + hora], kurtosis_resultados[(dia - 1) * 24 + hora], frequency_index[(dia - 1) * 24 + hora] ])

                    # Use example
                    Y = entropia_shannon
                    Y = np.where(Y == 0, np.nan, Y)

                    Y1 = kurtosis_resultados
                    Y1 = np.where(Y1 == 0, np.nan, Y1)

                    Y2 = frequency_index
                    Y2 = np.where(Y2 == 0, np.nan, Y2)                                             # Close the existing chart.

                    # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                    # Graph 1 - ENTROPY BY POINTS.

                    if self.checkBox_2.isChecked():                                 # CheckBox 2 of the Initial Time is activated (This marks time on the x axis)

                        if not self.lineEdit_14.text():
                            MensCombo14 = QMessageBox()
                            MensCombo14.setIcon(QMessageBox.Warning)
                            MensCombo14.setWindowTitle("Empty Year value")
                            MensCombo14.setText("Please, enter a valid value")
                            returnValue = MensCombo14.exec()

                        elif not self.lineEdit_15.text():
                            MensCombo15 = QMessageBox()
                            MensCombo15.setIcon(QMessageBox.Warning)
                            MensCombo15.setWindowTitle("Empty Month value")
                            MensCombo15.setText("Please, enter a valid value")
                            returnValue = MensCombo15.exec()

                        elif not self.lineEdit_16.text():
                            MensCombo16 = QMessageBox()
                            MensCombo16.setIcon(QMessageBox.Warning)
                            MensCombo16.setWindowTitle("Empty Day value")
                            MensCombo16.setText("Please, enter a valid value")
                            returnValue = MensCombo16.exec()

                        else:

                            # Data entry for enveloped (this value is a string by default)
                            Anio = (self.lineEdit_14.text())                            # Reading the Year value label.
                            Mes = (self.lineEdit_15.text())                             # Reading the Month value label.
                            Dia1 = (self.lineEdit_16.text())                            # Reading the Day value label.

                            # Convert the string value of the input text boxes to  integer

                            Anio1=int(Anio)                                             # Converts the Year value to integer.
                            Mes1=int(Mes)                                               # Converts the Month value to integer.
                            Dia2=int(Dia1)                                              # Converts the NaN Day value to integer.

                            # The date vector is created
                            fecha_inicio = datetime(Anio1, Mes1, Dia2)
                            dias = [fecha_inicio + timedelta(hours=i) for i in range(len(entropia_shannon[indices_no_cero_shannon]))]

                            # "Indices_no_cero_shannon" = np.where(entropia_shannon != 0)[0]
                            st = (dias, entropia_shannon[indices_no_cero_shannon])
                            np.save(F3, st)  # Save the ".npy" file in the directory.
                            plt.close()

                            st = (dias, entropia_shannon[indices_no_cero_shannon])

                            # Save the ".npy" file in the directory.
                            np.save(F3, st)
                            plt.close()                                             # Close the existing chart.

                            # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                            # Graph 1 - ENTROPY BY POINTS.

                            plt.plot(dias, entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='ShannonEntropy: Points per hour -> 1 Hr.')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_ShannonEntropy: Each point = 1 Hr. with Bandpass filter', color ="darkgreen", fontsize=18)

                            # Graph 2 - Averaged Shannon Entropy Graph.

                            fig, ax = plt.subplots(1,1)
                            indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                            plt.plot(dias, entropia_promediada[indices_no_cero_promediada], "ob", mfc="b", mec = "b", label='ShannonAveragedEntropy: Points per hour -> 1 Hr.')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Shannon Averaged Entropy: Each point = 1 Hr. with Bandpass filter.', color ="darkgreen", fontsize=18)

                            # Graph 3 - Graph of Shannon Entropy with the envelope.

                            # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE.

                            fig, ax = plt.subplots(1,1)

                            y_filtered = nanfastsmooth(Y.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                            plt.plot(dias, entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='Shannon_Entropy')
                            plt.plot(dias, y_filtered[indices_no_cero_shannon], color='blue', label='Envelope')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Envelope - Shannon Entropy: Each point = 1 Hr. with Bandpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            # Graph 4 - Envelope only graph.

                            fig, ax = plt.subplots(1,1)

                            plt.plot(dias, y_filtered[indices_no_cero_shannon], label='Filtered Signal', color='blue')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Only the envelope of Shannon entropy: Each point = 1 Hr. with Bandpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                            # Graph 5 Frequency Index with enveloped
                            fig, ax = plt.subplots(1,1)

                            y_filtered3 = nanfastsmooth(Y2.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                            plt.plot(dias, frequency_index[indices_no_cero_frecuency], 'o-', label='Frequency Index')
                            plt.plot(dias, y_filtered3[indices_no_cero_frecuency], label='Envelope', color='red')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                            plt.title(Nombre3 + ' Frequency Index: Each point = 1 Hr. with Bandpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            # Graph 6 Kurtosis with Envelope
                            fig, ax = plt.subplots(1,1)
                            indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]

                            # The date vector is created
                            fecha_inicio = datetime(Anio1, Mes1, Dia2)
                            dias2 = [fecha_inicio + timedelta(hours=i) for i in range(len(entropia_shannon[indices_no_cero_kurtosis]))]

                            y_filtered2 = nanfastsmooth(Y1.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                            plt.plot(dias2, kurtosis_resultados[indices_no_cero_kurtosis], 'o', label='Kurtosis')
                            plt.plot(dias2, y_filtered2[indices_no_cero_kurtosis], label='Envelope', color='red')
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                            plt.title(Nombre3 + ' Kurtosis: Each point = 1 Hr. with Bandpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)

                            plt.show()

                    else:

                        # Plot the vectors into separate figures.
                        dias = np.arange(1, 8761 + 1)

                        st = (dias, entropia_shannon[indices_no_cero_shannon])

                        np.save(F3, st)  # Save the ".npy" file in the directory.
                        plt.close()

                        # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                        # Graph 1 - ENTROPY BY POINTS.

                        plt.plot(dias[indices_no_cero_shannon], entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='ShannonEntropy: Points per hour -> 1 Hr.')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_ShannonEntropy: Each point = 1 Hr. with Bandpass filter', color ="darkgreen", fontsize=18)
                        #plt.grid()

                        # Graph 2 - Averaged Shannon Entropy Graph.

                        fig, ax = plt.subplots(1,1)
                        indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                        plt.plot(dias[indices_no_cero_promediada], entropia_promediada[indices_no_cero_promediada], "ob", mfc="b", mec = "b", label='ShannonAveragedEntropy: Points per hour -> 1 Hr.')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Shannon Averaged Entropy: Each point = 1 Hr. with Bandpass filter.', color ="darkgreen", fontsize=18)

                        # Graph 3 - Graph of Shannon Entropy with the envelope.

                        # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE.

                        fig, ax = plt.subplots(1,1)

                        y_filtered = nanfastsmooth(Y.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                        plt.plot(dias[indices_no_cero_shannon], entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='Shannon Entropy')
                        plt.plot(dias[indices_no_cero_shannon], y_filtered[indices_no_cero_shannon], label='Envelope', color='blue')
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Envelope - Shannon Entropy: Each point = 1 Hr. with Bandpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                        # Graph 4 - Envelope only graph.

                        fig, ax = plt.subplots(1,1)

                        plt.plot(dias[indices_no_cero_shannon], y_filtered[indices_no_cero_shannon], label='Filtered Signal', color='blue')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Only the envelope of Shannon entropy: Each point = 1 Hr. with Bandpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                        # Graph 5 Frequency Index with Envelope
                        fig, ax = plt.subplots(1,1)

                        y_filtered3 = nanfastsmooth(Y2.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                        plt.plot(dias[indices_no_cero_frecuency], frequency_index[indices_no_cero_frecuency], 'o-', label='Frequency Index')
                        plt.plot(dias[indices_no_cero_frecuency], y_filtered3[indices_no_cero_frecuency], label='Envelope', color='red')
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                        plt.title(Nombre3 + ' Frequency Index: Each point = 1 Hr. with Bandpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)

                        # Graph 6 Kurtosis with Envelope
                        fig, ax = plt.subplots(1,1)
                        indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]

                        y_filtered2 = nanfastsmooth(Y1.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                        plt.plot(dias[indices_no_cero_kurtosis], kurtosis_resultados[indices_no_cero_kurtosis], 'o', label='Kurtosis')
                        plt.plot(dias[indices_no_cero_kurtosis], y_filtered2[indices_no_cero_kurtosis], label='Envelope', color='red')
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                        plt.title(Nombre3 + ' Kurtosis: Each point = 1 Hr. with Bandpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)

                        plt.show()

            else:                                           # Here the value of the entropy is calculated without the time interval (Start - End)

                if not self.lineEdit_5.text():
                    MensCombo1 = QMessageBox()
                    MensCombo1.setIcon(QMessageBox.Warning)
                    MensCombo1.setWindowTitle("Empty Smoothing type")
                    MensCombo1.setText("Please, enter a valid Value")
                    returnValue = MensCombo1.exec()

                elif not self.lineEdit_7.text():
                    MensCombo2 = QMessageBox()
                    MensCombo2.setIcon(QMessageBox.Warning)
                    MensCombo2.setWindowTitle("Empty Filter Order")
                    MensCombo2.setText("Please, enter a valid Value")
                    returnValue = MensCombo2.exec()

                elif not self.lineEdit_8.text():
                    MensCombo3 = QMessageBox()
                    MensCombo3.setIcon(QMessageBox.Warning)
                    MensCombo3.setWindowTitle("Empty Min. Frequency")
                    MensCombo3.setText("Please, enter a valid Value")
                    returnValue = MensCombo3.exec()

                elif not self.lineEdit_9.text():
                    MensCombo4 = QMessageBox()
                    MensCombo4.setIcon(QMessageBox.Warning)
                    MensCombo4.setWindowTitle("Empty Max. Frequency")
                    MensCombo4.setText("Please, enter a valid Value")
                    returnValue = MensCombo4.exec()

                elif not self.lineEdit_10.text():
                    MensCombo5 = QMessageBox()
                    MensCombo5.setIcon(QMessageBox.Warning)
                    MensCombo5.setWindowTitle("Empty Envelope Window size")
                    MensCombo5.setText("Please, enter a valid Value")
                    returnValue = MensCombo5.exec()

                elif not self.lineEdit_13.text():
                    MensCombo6 = QMessageBox()
                    MensCombo6.setIcon(QMessageBox.Warning)
                    MensCombo6.setWindowTitle("Empty NaN Tolerance")
                    MensCombo6.setText("Please, enter a valid Value")
                    returnValue = MensCombo6.exec()

                elif not self.label_5.text():
                    MensCombo7 = QMessageBox()
                    MensCombo7.setIcon(QMessageBox.Warning)
                    MensCombo7.setWindowTitle("Empty directory to upload records")
                    MensCombo7.setText("Please, enter a valid name of directory")
                    returnValue = MensCombo7.exec()

                elif not self.label_8.text():
                    MensCombo8 = QMessageBox()
                    MensCombo8.setIcon(QMessageBox.Warning)
                    MensCombo8.setWindowTitle("Empty path to store CSV/NPY file")
                    MensCombo8.setText("Please, enter a valid name of directory")
                    returnValue = MensCombo8.exec()

                else:
                    # Filtering with a Bandpass.
                    plt.close()                                                 # Close the existing chart.

                    carpeta = (self.label_5.text())                             # Reading the directory or file folder label.

                    # Code to detect the contents of the folder and the files that the folder contains
                    with os.scandir(carpeta) as ficheros:
                        ficheros4 = [fichero.name for fichero in ficheros if fichero.is_file()]

                    # The contents of the files in "ficheros4" is a list. This code converts them to string
                    lfiles = [str(elemento) for elemento in ficheros4]

                    # Code used to determine the name of the files contained in the folder and to be used in the loading loop
                    Iniciolfiles = lfiles[0]                                    # Detects the numeric value of the "Start" in the name
                    Finlfiles = lfiles[-1]                                      # Detects the numerical value of the "End" in the name
                    Indice1 = Iniciolfiles.rfind('.')                           # Determines the index, which will be marked by the dot at the end for the extension
                    Nombre3 = Iniciolfiles[0:Indice1]                           # Indicates the name of the file in str (minus) the index or extension (each day)

                    # Data entry from labels and fields or text boxes (this value is a string by default)
                    frecMin = (self.lineEdit_8.text())                          # Minimum Frequency label reading.
                    frecMax = (self.lineEdit_9.text())                          # Maximum Frequency label reading.
                    orden1 = (self.lineEdit_7.text())                           # Reading the Filter Order Label.

                    # Data entry for enveloped (this value is a string by default)
                    Tam = (self.lineEdit_10.text())                             # Reading the envelope window size label.
                    Tsua = (self.lineEdit_5.text())                             # Reading the Smoothing type label.
                    Tnan = (self.lineEdit_13.text())                            # Reading the NaN Tolerance label.

                    # Convert the string value of the input text boxes to float or integer
                    frec7=float(frecMin)                                        # Converts the Minimum Frequency value to float.
                    frec8=float(frecMax)                                        # Converts the Maximum Frequency value to float.
                    orden7=int(orden1)                                          # Converts filter order value to integer.

                    Tam1=int(Tam)                                               # Converts the envelope window size value to integer.
                    Tsua1=int(Tsua)                                             # Converts the Smoothing type value to integer.
                    Tnan1=int(Tnan)                                             # Converts the NaN Tolerance value to integer.

                    timeIn = 365

                    # Function for Shannon entropy calculating
                    def calcular_entropia(datos):
                        params = stats.norm.fit(datos)
                        dist = stats.norm(*params)
                        probabilidades = dist.pdf(datos)
                        entropia = -np.sum(probabilidades * np.log2(probabilidades))
                        return entropia

                    # Function for Kurtosis calculating
                    def calcular_kurtosis(datos):
                        n = len(datos)
                        media = np.mean(datos)
                        varianza = np.var(datos)
                        desviacion_estandar = np.sqrt(varianza)

                        if desviacion_estandar == 0:
                            return 0.0
                        kurtosis = np.sum((datos - media)**4) / (n * desviacion_estandar**4) - 3.0
                        return kurtosis

                    # Function for Shannon entropy enveloped calculating
                    def nanfastsmooth(Y, w, type=1, tol=0.5):

                        """
                        Smooths vector Y with a moving average of width w, ignoring NaNs in data.

                        Parameters:
                        Y (numpy array): Input signal.
                        w (int): Window width.
                        type (int): Smooth type (1 for rectangular, 2 for triangular, 3 for pseudo-Gaussian).
                        tol (float): Tolerance to NaNs between 0 and 1.

                        Returns:
                        numpy array: Smoothed signal.
                        """
                        mask = ~np.isnan(Y)  # Create a boolean mask for non-NaN values
                        Y[mask] = nanfastsmooth_core(Y[mask], w, type, tol)  # Apply smoothing to non-NaN values
                        return Y

                    # Function for Shannon entropy enveloped type calculating. For default the value = 3
                    def nanfastsmooth_core(Y, w, type, tol):
                        if type == 1:
                            SmoothY = moving_average(Y, w)
                        elif type == 2:
                            SmoothY = moving_average(moving_average(Y, w), w)
                        elif type == 3:
                            SmoothY = moving_average(moving_average(moving_average(Y, w), w), w)

                        return SmoothY

                    def moving_average(Y, window_size):
                        return np.convolve(Y, np.ones(window_size)/window_size, mode='same')

                    def calcular_indice_frecuencias(datos, frecuencia_muestreo):
                        # Aplicar filtro en frecuencia
                        freq_bajas = (1, 5.5)
                        freq_altas = (6, 16)

                        datos_bajas = apply_bandpass_filter(datos, frecuencia_muestreo, freq_bajas)
                        datos_altas = apply_bandpass_filter(datos, frecuencia_muestreo, freq_altas)

                        # Calcular energía para cada señal
                        energia_bajas = np.sum(datos_bajas ** 2)
                        energia_altas = np.sum(datos_altas ** 2)

                        # Calcular índice de frecuencias
                        indice_frecuencias = np.log(energia_altas / energia_bajas) if energia_bajas != 0 else np.nan
                        return indice_frecuencias

                    def apply_bandpass_filter(datos, frecuencia_muestreo, freq_band):
                        nyquist = 0.5 * frecuencia_muestreo
                        normal_freq_band = np.array(freq_band) / nyquist
                        b, a = signal.butter(4, normal_freq_band, btype='band')
                        datos_filtrados = signal.filtfilt(b, a, datos)
                        return datos_filtrados

                    # Start entropy and averaged entropy values
                    entropia_shannon = []
                    entropia_promediada = []
                    kurtosis_resultados = []
                    frequency_index = []

                    # Cycle for the day-by-day calculation of the entropy in the files contained in the folder, using the time range (Start to End)
                    for dia in range(1, timeIn + 1):

                        archivo = Nombre3 + '.'+ f"{dia:003}"       # Here you select the name previously calculated plus point and the value of each Julian day

                        # If there is no file in the list, the entire day is added with a value of zero
                        if not os.path.exists(os.path.join(carpeta, archivo)):
                            for _ in range(24):  # Adds 24 hours with zero value if there is no file
                                entropia_shannon.append(0)
                                entropia_promediada.append(0)
                                kurtosis_resultados.append(0)
                                frequency_index.append(0)
                            continue

                        # Designation of the data contained in the folder files
                        st = Stream()
                        st += read(os.path.join(carpeta, archivo))
                        frecuencia_muestreo = st[0].stats.sampling_rate
                        # calculation of the bandpass filter with the parameters indicated by the user.
                        st.filter('bandpass', freqmin=frec7, freqmax=frec8, corners=orden7, zerophase=True)
                        # Data value
                        datos = st[0].data

                        # Divide the data into hours and calculate entropy for each hour.
                        for hora in range(24):
                            inicio = hora * 3600  # start of time in seconds.
                            fin = inicio + 3600  # End of time in seconds.
                            datos_hora = datos[inicio:fin]

                            if len(datos_hora) < 3600:  # If the hour is incomplete, add zeros to the end.
                                datos_hora = np.append(datos_hora, np.zeros(3600 - len(datos_hora)))

                            # Accumulator of the calculated values of the Shannon entropy and the averaged entropy.
                            entropia_shannon.append(calcular_entropia(datos_hora))
                            entropia_promediada.append(calcular_entropia(datos_hora) / len(datos_hora))
                            kurtosis_resultados.append(calcular_kurtosis(datos_hora))
                            frequency_index.append(calcular_indice_frecuencias(datos_hora, frecuencia_muestreo))

                    # Converting shannon entropy value and averaged entropy to data array.
                    entropia_shannon = np.array(entropia_shannon)
                    entropia_promediada = np.array(entropia_promediada)
                    kurtosis_resultados = np.array(kurtosis_resultados)
                    frequency_index=np.array(frequency_index)

                    # Shannon Entropy Graph. Value of non-zero indices where there is no data.
                    indices_no_cero_shannon = np.where(entropia_shannon != 0)[0]

                    indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                    indices_no_cero_frecuency = np.where(frequency_index != 0)[0]

                    indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]

                    # **** SAVE THE RESULTS FILE .CSV
                    archivoFil2 = (self.label_8.text())                         # Reading directory label.

                    # **** SAVE THE RESULTS .npy FILE FOR LATER GRAPH *****
                    TW = str(Tam1)                                              # Convert Envelope Window value to string for names.
                    F1 = (Nombre3 + '_Bandpass_Filter_1hr_without_Time_interval_Dots_and_Time' + '_Windows=' + TW + '.csv')            # Assign F1, Capture the name of the record and add the .csv extension.

                    # Guardar resultados en archivos .npy
                    F1a = (Nombre3 + '_Bandpass_Filter_1hr_without_Time_interval_Dots_and_Time' + '_Windows=' + TW)
                    F2 = (archivoFil2 + F1)                                     # Assigns to F2 the directory plus the previous name where the record will be stored.
                    F3 = (archivoFil2 + F1a)

                    with open(F2, 'w+', newline='') as archivo_csv:             # Each result is saved in the file, day, time and values of Shannon's entropy and averaged.
                        writer = csv.writer(archivo_csv)
                        writer.writerow(['Day', ' hour', ' Shannon Entropy', ' Averaged Shannon Entropy', ' Enveloped Shannon Entropy', ' Kurtosis', ' Frequency Index'])

                        for dia in range(1, timeIn + 1):                        # Save data by day and time according to the time interval (Start - End)
                            for hora in range(24):
                                writer.writerow([dia, hora, entropia_shannon[(dia - 1) * 24 + hora], entropia_promediada[(dia - 1) * 24 + hora], kurtosis_resultados[(dia - 1) * 24 + hora], frequency_index[(dia - 1) * 24 + hora] ])

                    # Use example
                    Y = entropia_shannon
                    Y = np.where(Y == 0, np.nan, Y)

                    Y1 = kurtosis_resultados
                    Y1 = np.where(Y1 == 0, np.nan, Y1)

                    Y2 = frequency_index
                    Y2 = np.where(Y2 == 0, np.nan, Y2)                                             # Close the existing chart.

                    if self.checkBox_2.isChecked():                                 # CheckBox 2 of the Initial Time is activated (This marks time on the x axis)

                        if not self.lineEdit_14.text():
                            MensCombo14 = QMessageBox()
                            MensCombo14.setIcon(QMessageBox.Warning)
                            MensCombo14.setWindowTitle("Empty Year value")
                            MensCombo14.setText("Please, enter a valid value")
                            returnValue = MensCombo14.exec()

                        elif not self.lineEdit_15.text():
                            MensCombo15 = QMessageBox()
                            MensCombo15.setIcon(QMessageBox.Warning)
                            MensCombo15.setWindowTitle("Empty Month value")
                            MensCombo15.setText("Please, enter a valid value")
                            returnValue = MensCombo15.exec()

                        elif not self.lineEdit_16.text():
                            MensCombo16 = QMessageBox()
                            MensCombo16.setIcon(QMessageBox.Warning)
                            MensCombo16.setWindowTitle("Empty Day value")
                            MensCombo16.setText("Please, enter a valid value")
                            returnValue = MensCombo16.exec()

                        else:

                            # Data entry for enveloped (this value is a string by default)
                            Anio = (self.lineEdit_14.text())                            # Reading the Year value label.
                            Mes = (self.lineEdit_15.text())                             # Reading the Month value label.
                            Dia1 = (self.lineEdit_16.text())                            # Reading the Day value label.

                            # Convert the string value of the input text boxes to  integer

                            Anio1=int(Anio)                                             # Converts the Year value to integer.
                            Mes1=int(Mes)                                               # Converts the Month value to integer.
                            Dia2=int(Dia1)                                              # Converts the NaN Day value to integer.

                            # The date vector is created
                            fecha_inicio = datetime(Anio1, Mes1, Dia2)
                            dias = [fecha_inicio + timedelta(hours=i) for i in range(len(entropia_shannon[indices_no_cero_shannon]))]

                            # "Indices_no_cero_shannon" = np.where(entropia_shannon != 0)[0]
                            st = (dias, entropia_shannon[indices_no_cero_shannon])
                            np.save(F3, st)  # Save the ".npy" file in the directory.
                            plt.close()

                            st = (dias, entropia_shannon[indices_no_cero_shannon])

                            # Save the ".npy" file in the directory.
                            np.save(F3, st)
                            plt.close()                                             # Close the existing chart.

                            # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                            # Graph 1 - ENTROPY BY POINTS.

                            plt.plot(dias, entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='ShannonEntropy: Points per hour -> 1 Hr.')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_ShannonEntropy: Each point = 1 Hr. with Bandpass filter', color ="darkgreen", fontsize=18)
                            #plt.grid()
                            plt.show()

                            # Graph 2 - Averaged Shannon Entropy Graph.

                            fig, ax = plt.subplots(1,1)
                            indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                            plt.plot(dias, entropia_promediada[indices_no_cero_promediada], "ob", mfc="b", mec = "b", label='ShannonAveragedEntropy: Points per hour -> 1 Hr.')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Shannon Averaged Entropy: Each point = 1 Hr. with Bandpass filter.', color ="darkgreen", fontsize=18)

                            # Graph 3 - Graph of Shannon Entropy with the envelope.

                            # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE.

                            fig, ax = plt.subplots(1,1)

                            y_filtered = nanfastsmooth(Y.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                            plt.plot(dias, entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='Shannon_Entropy')
                            plt.plot(dias, y_filtered[indices_no_cero_shannon], color='blue', label='Envelope')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Envelope - Shannon Entropy: Each point = 1 Hr. with Bandpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            # Graph 4 - Envelope only graph.

                            fig, ax = plt.subplots(1,1)

                            plt.plot(dias, y_filtered[indices_no_cero_shannon], label='Filtered Signal', color='blue')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Only the envelope of Shannon entropy: Each point = 1 Hr. with Bandpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                            # Graph 5 Frequency Index with enveloped
                            fig, ax = plt.subplots(1,1)

                            y_filtered3 = nanfastsmooth(Y2.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                            plt.plot(dias, frequency_index[indices_no_cero_frecuency], 'o-', label='Frequency Index')
                            plt.plot(dias, y_filtered3[indices_no_cero_frecuency], label='Envelope', color='red')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                            plt.title(Nombre3 + ' Frequency Index: Each point = 1 Hr. with Bandpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            # Graph 6 Kurtosis with Envelope
                            fig, ax = plt.subplots(1,1)
                            indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]

                            # The date vector is created
                            fecha_inicio = datetime(Anio1, Mes1, Dia2)
                            dias2 = [fecha_inicio + timedelta(hours=i) for i in range(len(entropia_shannon[indices_no_cero_kurtosis]))]

                            y_filtered2 = nanfastsmooth(Y1.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                            plt.plot(dias2, kurtosis_resultados[indices_no_cero_kurtosis], 'o', label='Kurtosis')
                            plt.plot(dias2, y_filtered2[indices_no_cero_kurtosis], label='Envelope', color='red')
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                            plt.title(Nombre3 + ' Kurtosis: Each point = 1 Hr. with Bandpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)

                            plt.show()

                    else:

                        # Plot the vectors into separate figures.
                        dias = np.arange(1, 8761*6+1)

                        st = (dias, entropia_shannon[indices_no_cero_shannon])

                        np.save(F3, st)  # Save the ".npy" file in the directory.
                        plt.close()

                        # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                        # Graph 1 - ENTROPY BY POINTS.

                        plt.plot(dias[indices_no_cero_shannon], entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='ShannonEntropy: Points per hour -> 1 Hr.')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_ShannonEntropy: Each point = 1 Hr. with Bandpass filter', color ="darkgreen", fontsize=18)

                        # Graph 2 - Averaged Shannon Entropy Graph.

                        fig, ax = plt.subplots(1,1)
                        indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                        plt.plot(dias[indices_no_cero_promediada], entropia_promediada[indices_no_cero_promediada], "ob", mfc="b", mec = "b", label='ShannonAveragedEntropy: Points per hour -> 1 Hr.')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Shannon Averaged Entropy: Each point = 1 Hr. with Bandpass filter.', color ="darkgreen", fontsize=18)

                        # Graph 3 - Graph of Shannon Entropy with the envelope.

                        # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE.

                        fig, ax = plt.subplots(1,1)

                        y_filtered = nanfastsmooth(Y.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                        plt.plot(dias[indices_no_cero_shannon], entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='Shannon Entropy')
                        plt.plot(dias[indices_no_cero_shannon], y_filtered[indices_no_cero_shannon], label='Envelope', color='blue')
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Envelope - Shannon Entropy: Each point = 1 Hr. with Bandpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                        # Graph 4 - Envelope only graph.

                        fig, ax = plt.subplots(1,1)

                        plt.plot(dias[indices_no_cero_shannon], y_filtered[indices_no_cero_shannon], label='Filtered Signal', color='blue')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Only the envelope of Shannon entropy: Each point = 1 Hr. with Bandpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                        # Graph 5 Frequency Index with Envelope
                        fig, ax = plt.subplots(1,1)

                        y_filtered3 = nanfastsmooth(Y2.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                        plt.plot(dias[indices_no_cero_frecuency], frequency_index[indices_no_cero_frecuency], 'o-', label='Frequency Index')
                        plt.plot(dias[indices_no_cero_frecuency], y_filtered3[indices_no_cero_frecuency], label='Envelope', color='red')
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                        plt.title(Nombre3 + ' Frequency Index: Each point = 1 Hr. with Bandpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)

                        # Graph 6 Kurtosis with Envelope
                        fig, ax = plt.subplots(1,1)
                        indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]
                        #dias2 = [fecha_inicio + timedelta(hours=i) for i in range(len(entropia_shannon[indices_no_cero_kurtosis]))]

                        y_filtered2 = nanfastsmooth(Y1.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                        plt.plot(dias[indices_no_cero_kurtosis], kurtosis_resultados[indices_no_cero_kurtosis], 'o', label='Kurtosis')
                        plt.plot(dias[indices_no_cero_kurtosis], y_filtered2[indices_no_cero_kurtosis], label='Envelope', color='red')
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                        plt.title(Nombre3 + ' Kurtosis: Each point = 1 Hr. with Bandpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)

                        plt.show()

        except:                         # In any other case of invalid or empty inputs
                plt.close()                                                 # Close the existing chart.
                msgBox = QMessageBox()
                msgBox.setIcon(QMessageBox.Warning)
                msgBox.setText("The File Does not exist, is Invalid or the CSV old file is open. Please close, try again ...")
                msgBox.setWindowTitle("Invalid Record inputs or CSV Old file is open ")
                returnValue = msgBox.exec()
                pass

    def filtrobandstop(self):                                               # 4.- Function to execute the Bandstop filter with 1 hr. analysis window.

        try:

            # Verifying that the checkbox is true. Work with time intervals.

            if self.checkBox.isChecked() == True:

                # Verify (Validation), that the text box and label is not empty

                if not self.label_5.text():
                    MensCombo1 = QMessageBox()
                    MensCombo1.setIcon(QMessageBox.Warning)
                    MensCombo1.setWindowTitle("Empty directory to upload records")
                    MensCombo1.setText("Please, enter a valid name of directory")
                    returnValue = MensCombo1.exec()

                elif not self.label_8.text():
                    MensCombo2 = QMessageBox()
                    MensCombo2.setIcon(QMessageBox.Warning)
                    MensCombo2.setWindowTitle("Empty path to store CSV/NPY file")
                    MensCombo2.setText("Please, enter a valid name of directory")
                    returnValue = MensCombo2.exec()

                elif not self.lineEdit_5.text():
                    MensCombo3 = QMessageBox()
                    MensCombo3.setIcon(QMessageBox.Warning)
                    MensCombo3.setWindowTitle("Empty Smoothing type")
                    MensCombo3.setText("Please, enter a valid Value")
                    returnValue = MensCombo3.exec()

                elif not self.lineEdit_7.text():
                    MensCombo4 = QMessageBox()
                    MensCombo4.setIcon(QMessageBox.Warning)
                    MensCombo4.setWindowTitle("Empty Filter Order")
                    MensCombo4.setText("Please, enter a valid Value")
                    returnValue = MensCombo4.exec()

                elif not self.lineEdit_8.text():
                    MensCombo5 = QMessageBox()
                    MensCombo5.setIcon(QMessageBox.Warning)
                    MensCombo5.setWindowTitle("Empty Min. Frequency")
                    MensCombo5.setText("Please, enter a valid Value")
                    returnValue = MensCombo5.exec()

                elif not self.lineEdit_9.text():
                    MensCombo6 = QMessageBox()
                    MensCombo6.setIcon(QMessageBox.Warning)
                    MensCombo6.setWindowTitle("Empty Max. Frequency")
                    MensCombo6.setText("Please, enter a valid Value")
                    returnValue = MensCombo6.exec()

                elif not self.lineEdit_10.text():
                    MensCombo7 = QMessageBox()
                    MensCombo7.setIcon(QMessageBox.Warning)
                    MensCombo7.setWindowTitle("Empty Envelope Window size")
                    MensCombo7.setText("Please, enter a valid Value")
                    returnValue = MensCombo7.exec()

                elif not self.lineEdit_11.text():
                    MensCombo8 = QMessageBox()
                    MensCombo8.setIcon(QMessageBox.Warning)
                    MensCombo8.setWindowTitle("Empty Start time")
                    MensCombo8.setText("Please, enter a valid Value")
                    returnValue = MensCombo8.exec()

                elif not self.lineEdit_12.text():
                    MensCombo9 = QMessageBox()
                    MensCombo9.setIcon(QMessageBox.Warning)
                    MensCombo9.setWindowTitle("Empty End time")
                    MensCombo9.setText("Please, enter a valid Value")
                    returnValue = MensCombo9.exec()

                elif not self.lineEdit_13.text():
                    MensCombo10 = QMessageBox()
                    MensCombo10.setIcon(QMessageBox.Warning)
                    MensCombo10.setWindowTitle("Empty NaN Tolerance")
                    MensCombo10.setText("Please, enter a valid Value")
                    returnValue = MensCombo10.exec()

                else:
                    # Filtering with a Bandstop 1 Hr.
                    plt.close()                                                 # Close the existing chart.

                    carpeta = (self.label_5.text())                             # Reading the directory or file folder label.

                    # Code to detect the contents of the folder and the files that the folder contains
                    with os.scandir(carpeta) as ficheros:
                        ficheros4 = [fichero.name for fichero in ficheros if fichero.is_file()]

                    # The contents of the files in "ficheros4" is a list. This code converts them to string
                    lfiles = [str(elemento) for elemento in ficheros4]

                    # Code used to determine the name of the files contained in the folder and to be used in the loading loop
                    Iniciolfiles = lfiles[0]                                    # Detects the numeric value of the "Start" in the name
                    Finlfiles = lfiles[-1]                                      # Detects the numerical value of the "End" in the name
                    Indice1 = Iniciolfiles.rfind('.')                           # Determines the index, which will be marked by the dot at the end for the extension
                    Nombre3 = Iniciolfiles[0:Indice1]                           # Indicates the name of the file in str (minus) the index or extension (each day)

                    # Data entry from labels and fields or text boxes (this value is a string by default)

                    frecMin = (self.lineEdit_8.text())                          # Minimum Frequency label reading.
                    frecMax = (self.lineEdit_9.text())                          # Maximum Frequency label reading.
                    orden1 = (self.lineEdit_7.text())                           # Reading the Filter Order Label.

                    Start1 = (self.lineEdit_11.text())                          # Star Time Size label reading.
                    End1 = (self.lineEdit_12.text())                            # End Time Size label reading.

                    # Convert the string value of the input text boxes to float or integer
                    frec7=float(frecMin)                                        # Converts the Minimum Frequency value to float.
                    frec8=float(frecMax)                                        # Converts the Maximum Frequency value to float.
                    orden7=int(orden1)                                          # Converts filter order value to integer.

                     # Data entry for enveloped (this value is a string by default)
                    Tam = (self.lineEdit_10.text())                             # Reading the envelope window size label.
                    Tsua = (self.lineEdit_5.text())                             # Reading the Smoothing type label.
                    Tnan = (self.lineEdit_13.text())                            # Reading the NaN Tolerance label.

                    Tam1=int(Tam)                                               # Converts the envelope window size value to integer.
                    Tsua1=int(Tsua)                                             # Converts the Smoothing type value to integer.
                    Tnan1=int(Tnan)                                             # Converts the NaN Tolerance value to integer.

                    timeIn = 365

                    Start2=int(Start1)                                          # Converts the Start time window size value to an integer.
                    End2=int(End1)                                              # Converts the End time window size value to an integer.

                    Diferencia = End2 - Start2                                  # Value of the difference between end and start to obtain the number of days to calculate

                    # Function for Shannon entropy calculating
                    def calcular_entropia(datos):
                        params = stats.norm.fit(datos)
                        dist = stats.norm(*params)
                        probabilidades = dist.pdf(datos)
                        entropia = -np.sum(probabilidades * np.log2(probabilidades))
                        return entropia

                    # Function for Kurtosis calculating
                    def calcular_kurtosis(datos):
                        n = len(datos)
                        media = np.mean(datos)
                        varianza = np.var(datos)
                        desviacion_estandar = np.sqrt(varianza)

                        if desviacion_estandar == 0:
                            return 0.0
                        kurtosis = np.sum((datos - media)**4) / (n * desviacion_estandar**4) - 3.0
                        return kurtosis

                    # Function for Shannon entropy enveloped calculating
                    def nanfastsmooth(Y, w, type=1, tol=0.5):

                        """
                        Smooths vector Y with a moving average of width w, ignoring NaNs in data.

                        Parameters:
                        Y (numpy array): Input signal.
                        w (int): Window width.
                        type (int): Smooth type (1 for rectangular, 2 for triangular, 3 for pseudo-Gaussian).
                        tol (float): Tolerance to NaNs between 0 and 1.

                        Returns:
                        numpy array: Smoothed signal.
                        """
                        mask = ~np.isnan(Y)  # Create a boolean mask for non-NaN values
                        Y[mask] = nanfastsmooth_core(Y[mask], w, type, tol)  # Apply smoothing to non-NaN values
                        return Y

                    # Function for Shannon entropy enveloped type calculating. For default the value = 3
                    def nanfastsmooth_core(Y, w, type, tol):
                        if type == 1:
                            SmoothY = moving_average(Y, w)
                        elif type == 2:
                            SmoothY = moving_average(moving_average(Y, w), w)
                        elif type == 3:
                            SmoothY = moving_average(moving_average(moving_average(Y, w), w), w)

                        return SmoothY

                    def moving_average(Y, window_size):
                        return np.convolve(Y, np.ones(window_size)/window_size, mode='same')

                    def calcular_indice_frecuencias(datos, frecuencia_muestreo):
                        # Aplicar filtro en frecuencia
                        freq_bajas = (1, 5.5)
                        freq_altas = (6, 16)

                        datos_bajas = apply_bandpass_filter(datos, frecuencia_muestreo, freq_bajas)
                        datos_altas = apply_bandpass_filter(datos, frecuencia_muestreo, freq_altas)

                        # Calcular energía para cada señal
                        energia_bajas = np.sum(datos_bajas ** 2)
                        energia_altas = np.sum(datos_altas ** 2)

                        # Calcular índice de frecuencias
                        indice_frecuencias = np.log(energia_altas / energia_bajas) if energia_bajas != 0 else np.nan
                        return indice_frecuencias

                    def apply_bandpass_filter(datos, frecuencia_muestreo, freq_band):
                        nyquist = 0.5 * frecuencia_muestreo
                        normal_freq_band = np.array(freq_band) / nyquist
                        b, a = signal.butter(4, normal_freq_band, btype='band')
                        datos_filtrados = signal.filtfilt(b, a, datos)
                        return datos_filtrados

                    # Start entropy and averaged entropy values
                    entropia_shannon = []
                    entropia_promediada = []
                    kurtosis_resultados = []
                    frequency_index = []

                    # Cycle for the day-by-day calculation of the entropy in the files contained in the folder, using the time range (Start to End)
                    for dia in range(Start2, End2 + 1):

                        archivo = Nombre3 + '.'+ f"{dia:003}"       # Here you select the name previously calculated plus point and the value of each Julian day

                        # If there is no file in the list, the entire day is added with a value of zero
                        if not os.path.exists(os.path.join(carpeta, archivo)):
                            for _ in range(24):  # Adds 24 hours with zero value if there is no file
                                entropia_shannon.append(0)
                                entropia_promediada.append(0)
                                kurtosis_resultados.append(0)
                                frequency_index.append(0)
                            continue

                        # Designation of the data contained in the folder files
                        st = Stream()
                        st += read(os.path.join(carpeta, archivo))
                        frecuencia_muestreo = st[0].stats.sampling_rate
                        # calculation of the Bandstop filter with the parameters indicated by the user.
                        st.filter('bandstop', freqmin=frec7, freqmax=frec8, corners=orden7, zerophase=True)
                        # Data value
                        datos = st[0].data

                        # Divide the data into hours and calculate entropy for each hour.
                        for hora in range(24):
                            inicio = hora * 3600  # start of time in seconds.
                            fin = inicio + 3600  # End of time in seconds.
                            datos_hora = datos[inicio:fin]

                            if len(datos_hora) < 3600:  # If the hour is incomplete, add zeros to the end.
                                datos_hora = np.append(datos_hora, np.zeros(3600 - len(datos_hora)))

                            # Accumulator of the calculated values of the Shannon entropy and the averaged entropy.
                            entropia_shannon.append(calcular_entropia(datos_hora))
                            entropia_promediada.append(calcular_entropia(datos_hora) / len(datos_hora))
                            kurtosis_resultados.append(calcular_kurtosis(datos_hora))
                            frequency_index.append(calcular_indice_frecuencias(datos_hora, frecuencia_muestreo))

                    # Converting shannon entropy value and averaged entropy to data array.
                    entropia_shannon = np.array(entropia_shannon)
                    entropia_promediada = np.array(entropia_promediada)
                    kurtosis_resultados = np.array(kurtosis_resultados)
                    frequency_index=np.array(frequency_index)

                    # Shannon Entropy Graph. Value of non-zero indices where there is no data.
                    indices_no_cero_shannon = np.where(entropia_shannon != 0)[0]

                    indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                    indices_no_cero_frecuency = np.where(frequency_index != 0)[0]

                    indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]

                    # **** SAVE THE RESULTS FILE .CSV
                    archivoFil2 = (self.label_8.text())                         # Reading directory label.

                    # **** SAVE THE RESULTS .npy FILE FOR LATER GRAPH *****
                    TW = str(Tam1)                                              # Convert Envelope Window value to string for names.
                    F1 = (Nombre3 + '_Bandstop_Filter_1hr_Time_interval_Dots_and_Time' + '_Windows=' + TW + '.csv')            # Assign F1, Capture the name of the record and add the .csv extension.

                    # Guardar resultados en archivos .npy
                    F1a = (Nombre3 + '_Bandstop_Filter_1hr_Time_interval_Dots_and_Time' + '_Windows=' + TW)
                    F2 = (archivoFil2 + F1)                                     # Assigns to F2 the directory plus the previous name where the record will be stored.
                    F3 = (archivoFil2 + F1a)

                    with open(F2, 'w+', newline='') as archivo_csv:             # Each result is saved in the file, day, time and values of Shannon's entropy and averaged.
                        writer = csv.writer(archivo_csv)
                        writer.writerow(['Day', ' hour', ' Shannon Entropy', ' Averaged Shannon Entropy', ' Enveloped Shannon Entropy', ' Kurtosis', ' Frequency Index'])

                        for dia in range(1, Diferencia + 1):                        # Save data by day and time according to the time interval (Start - End)
                            for hora in range(24):

                                writer.writerow([dia, hora, entropia_shannon[(dia - 1) * 24 + hora], entropia_promediada[(dia - 1) * 24 + hora], kurtosis_resultados[(dia - 1) * 24 + hora], frequency_index[(dia - 1) * 24 + hora] ])

                    # Use example
                    Y = entropia_shannon
                    Y = np.where(Y == 0, np.nan, Y)

                    Y1 = kurtosis_resultados
                    Y1 = np.where(Y1 == 0, np.nan, Y1)

                    Y2 = frequency_index
                    Y2 = np.where(Y2 == 0, np.nan, Y2)                                             # Close the existing chart.

                    # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                    # Graph 1 - ENTROPY BY POINTS.

                    if self.checkBox_2.isChecked():                                 # CheckBox 2 of the Initial Time is activated (This marks time on the x axis)

                        if not self.lineEdit_14.text():
                            MensCombo14 = QMessageBox()
                            MensCombo14.setIcon(QMessageBox.Warning)
                            MensCombo14.setWindowTitle("Empty Year value")
                            MensCombo14.setText("Please, enter a valid value")
                            returnValue = MensCombo14.exec()

                        elif not self.lineEdit_15.text():
                            MensCombo15 = QMessageBox()
                            MensCombo15.setIcon(QMessageBox.Warning)
                            MensCombo15.setWindowTitle("Empty Month value")
                            MensCombo15.setText("Please, enter a valid value")
                            returnValue = MensCombo15.exec()

                        elif not self.lineEdit_16.text():
                            MensCombo16 = QMessageBox()
                            MensCombo16.setIcon(QMessageBox.Warning)
                            MensCombo16.setWindowTitle("Empty Day value")
                            MensCombo16.setText("Please, enter a valid value")
                            returnValue = MensCombo16.exec()

                        else:

                            # Data entry for enveloped (this value is a string by default)
                            Anio = (self.lineEdit_14.text())                            # Reading the Year value label.
                            Mes = (self.lineEdit_15.text())                             # Reading the Month value label.
                            Dia1 = (self.lineEdit_16.text())                            # Reading the Day value label.

                            # Convert the string value of the input text boxes to  integer

                            Anio1=int(Anio)                                             # Converts the Year value to integer.
                            Mes1=int(Mes)                                               # Converts the Month value to integer.
                            Dia2=int(Dia1)                                              # Converts the NaN Day value to integer.

                            # The date vector is created
                            fecha_inicio = datetime(Anio1, Mes1, Dia2)
                            dias = [fecha_inicio + timedelta(hours=i) for i in range(len(entropia_shannon[indices_no_cero_shannon]))]

                            # "Indices_no_cero_shannon" = np.where(entropia_shannon != 0)[0]
                            st = (dias, entropia_shannon[indices_no_cero_shannon])
                            np.save(F3, st)  # Save the ".npy" file in the directory.
                            plt.close()

                            st = (dias, entropia_shannon[indices_no_cero_shannon])

                            # Save the ".npy" file in the directory.
                            np.save(F3, st)
                            plt.close()                                             # Close the existing chart.

                            # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                            # Graph 1 - ENTROPY BY POINTS.

                            plt.plot(dias, entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='ShannonEntropy: Points per hour -> 1 Hr.')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_ShannonEntropy: Each point = 1 Hr. with Bandstop filter', color ="darkgreen", fontsize=18)

                            # Graph 2 - Averaged Shannon Entropy Graph.

                            fig, ax = plt.subplots(1,1)
                            indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                            plt.plot(dias, entropia_promediada[indices_no_cero_promediada], "ob", mfc="b", mec = "b", label='ShannonAveragedEntropy: Points per hour -> 1 Hr.')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Shannon Averaged Entropy: Each point = 1 Hr. with Bandstop filter.', color ="darkgreen", fontsize=18)

                            # Graph 3 - Graph of Shannon Entropy with the envelope.

                            # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE.

                            fig, ax = plt.subplots(1,1)

                            y_filtered = nanfastsmooth(Y.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                            plt.plot(dias, entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='Shannon_Entropy')
                            plt.plot(dias, y_filtered[indices_no_cero_shannon], color='blue', label='Envelope')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Envelope - Shannon Entropy: Each point = 1 Hr. with Bandstop filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            # Graph 4 - Envelope only graph.

                            fig, ax = plt.subplots(1,1)

                            plt.plot(dias, y_filtered[indices_no_cero_shannon], label='Filtered Signal', color='blue')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Only the envelope of Shannon entropy: Each point = 1 Hr. with Bandstop filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                            # Graph 5 Frequency Index with enveloped
                            fig, ax = plt.subplots(1,1)

                            y_filtered3 = nanfastsmooth(Y2.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                            plt.plot(dias, frequency_index[indices_no_cero_frecuency], 'o-', label='Frequency Index')
                            plt.plot(dias, y_filtered3[indices_no_cero_frecuency], label='Envelope', color='red')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                            plt.title(Nombre3 + ' Frequency Index: Each point = 1 Hr. with Bandstop filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            # Graph 6 Kurtosis with Envelope
                            fig, ax = plt.subplots(1,1)
                            indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]

                            # The date vector is created
                            fecha_inicio = datetime(Anio1, Mes1, Dia2)
                            dias2 = [fecha_inicio + timedelta(hours=i) for i in range(len(entropia_shannon[indices_no_cero_kurtosis]))]

                            y_filtered2 = nanfastsmooth(Y1.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                            plt.plot(dias2, kurtosis_resultados[indices_no_cero_kurtosis], 'o', label='Kurtosis')
                            plt.plot(dias2, y_filtered2[indices_no_cero_kurtosis], label='Envelope', color='red')
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                            plt.title(Nombre3 + ' Kurtosis: Each point = 1 Hr. with Bandstop filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)

                            plt.show()

                    else:

                        # Plot the vectors into separate figures.
                        dias = np.arange(1, 8761 + 1)

                        st = (dias, entropia_shannon[indices_no_cero_shannon])

                        np.save(F3, st)  # Save the ".npy" file in the directory.
                        plt.close()

                        # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                        # Graph 1 - ENTROPY BY POINTS.

                        plt.plot(dias[indices_no_cero_shannon], entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='ShannonEntropy: Points per hour -> 1 Hr.')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_ShannonEntropy: Each point = 1 Hr. with Bandstop filter', color ="darkgreen", fontsize=18)

                        # Graph 2 - Averaged Shannon Entropy Graph.

                        fig, ax = plt.subplots(1,1)
                        indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                        plt.plot(dias[indices_no_cero_promediada], entropia_promediada[indices_no_cero_promediada], "ob", mfc="b", mec = "b", label='ShannonAveragedEntropy: Points per hour -> 1 Hr.')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Shannon Averaged Entropy: Each point = 1 Hr. with Bandstop filter.', color ="darkgreen", fontsize=18)

                        # Graph 3 - Graph of Shannon Entropy with the envelope.

                        # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE.

                        fig, ax = plt.subplots(1,1)

                        y_filtered = nanfastsmooth(Y.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                        plt.plot(dias[indices_no_cero_shannon], entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='Shannon Entropy')
                        plt.plot(dias[indices_no_cero_shannon], y_filtered[indices_no_cero_shannon], label='Envelope', color='blue')
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Envelope - Shannon Entropy: Each point = 1 Hr. with Bandstop filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                        # Graph 4 - Envelope only graph.

                        fig, ax = plt.subplots(1,1)

                        plt.plot(dias[indices_no_cero_shannon], y_filtered[indices_no_cero_shannon], label='Filtered Signal', color='blue')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Only the envelope of Shannon entropy: Each point = 1 Hr. with Bandstop filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                        # Graph 5 Frequency Index with Envelope
                        fig, ax = plt.subplots(1,1)

                        y_filtered3 = nanfastsmooth(Y2.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                        plt.plot(dias[indices_no_cero_frecuency], frequency_index[indices_no_cero_frecuency], 'o-', label='Frequency Index')
                        plt.plot(dias[indices_no_cero_frecuency], y_filtered3[indices_no_cero_frecuency], label='Envelope', color='red')
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                        plt.title(Nombre3 + ' Frequency Index: Each point = 1 Hr. with Bandstop filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)

                        # Graph 6 Kurtosis with Envelope
                        fig, ax = plt.subplots(1,1)
                        indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]
                        #dias2 = [fecha_inicio + timedelta(hours=i) for i in range(len(entropia_shannon[indices_no_cero_kurtosis]))]

                        y_filtered2 = nanfastsmooth(Y1.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                        plt.plot(dias[indices_no_cero_kurtosis], kurtosis_resultados[indices_no_cero_kurtosis], 'o', label='Kurtosis')
                        plt.plot(dias[indices_no_cero_kurtosis], y_filtered2[indices_no_cero_kurtosis], label='Envelope', color='red')
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                        plt.title(Nombre3 + ' Kurtosis: Each point = 1 Hr. with Bandstop filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)

                        plt.show()

            else:                                           # Here the value of the entropy is calculated without the time interval (Start - End)

                if not self.lineEdit_5.text():
                    MensCombo1 = QMessageBox()
                    MensCombo1.setIcon(QMessageBox.Warning)
                    MensCombo1.setWindowTitle("Empty Smoothing type")
                    MensCombo1.setText("Please, enter a valid Value")
                    returnValue = MensCombo1.exec()

                elif not self.lineEdit_7.text():
                    MensCombo2 = QMessageBox()
                    MensCombo2.setIcon(QMessageBox.Warning)
                    MensCombo2.setWindowTitle("Empty Filter Order")
                    MensCombo2.setText("Please, enter a valid Value")
                    returnValue = MensCombo2.exec()

                elif not self.lineEdit_8.text():
                    MensCombo3 = QMessageBox()
                    MensCombo3.setIcon(QMessageBox.Warning)
                    MensCombo3.setWindowTitle("Empty Min. Frequency")
                    MensCombo3.setText("Please, enter a valid Value")
                    returnValue = MensCombo3.exec()

                elif not self.lineEdit_9.text():
                    MensCombo4 = QMessageBox()
                    MensCombo4.setIcon(QMessageBox.Warning)
                    MensCombo4.setWindowTitle("Empty Max. Frequency")
                    MensCombo4.setText("Please, enter a valid Value")
                    returnValue = MensCombo4.exec()

                elif not self.lineEdit_10.text():
                    MensCombo5 = QMessageBox()
                    MensCombo5.setIcon(QMessageBox.Warning)
                    MensCombo5.setWindowTitle("Empty Envelope Window size")
                    MensCombo5.setText("Please, enter a valid Value")
                    returnValue = MensCombo5.exec()

                elif not self.lineEdit_13.text():
                    MensCombo6 = QMessageBox()
                    MensCombo6.setIcon(QMessageBox.Warning)
                    MensCombo6.setWindowTitle("Empty NaN Tolerance")
                    MensCombo6.setText("Please, enter a valid Value")
                    returnValue = MensCombo6.exec()

                elif not self.label_5.text():
                    MensCombo7 = QMessageBox()
                    MensCombo7.setIcon(QMessageBox.Warning)
                    MensCombo7.setWindowTitle("Empty directory to upload records")
                    MensCombo7.setText("Please, enter a valid name of directory")
                    returnValue = MensCombo7.exec()

                elif not self.label_8.text():
                    MensCombo8 = QMessageBox()
                    MensCombo8.setIcon(QMessageBox.Warning)
                    MensCombo8.setWindowTitle("Empty path to store CSV/NPY file")
                    MensCombo8.setText("Please, enter a valid name of directory")
                    returnValue = MensCombo8.exec()

                else:
                    # Filtering with a Bandstop 1 Hr.
                    plt.close()                                                 # Close the existing chart.

                    carpeta = (self.label_5.text())                             # Reading the directory or file folder label.

                    # Code to detect the contents of the folder and the files that the folder contains
                    with os.scandir(carpeta) as ficheros:
                        ficheros4 = [fichero.name for fichero in ficheros if fichero.is_file()]

                    # The contents of the files in "ficheros4" is a list. This code converts them to string
                    lfiles = [str(elemento) for elemento in ficheros4]

                    # Code used to determine the name of the files contained in the folder and to be used in the loading loop
                    Iniciolfiles = lfiles[0]                                    # Detects the numeric value of the "Start" in the name
                    Finlfiles = lfiles[-1]                                      # Detects the numerical value of the "End" in the name
                    Indice1 = Iniciolfiles.rfind('.')                           # Determines the index, which will be marked by the dot at the end for the extension
                    Nombre3 = Iniciolfiles[0:Indice1]                           # Indicates the name of the file in str (minus) the index or extension (each day)

                    # Data entry from labels and fields or text boxes (this value is a string by default)
                    frecMin = (self.lineEdit_8.text())                          # Minimum Frequency label reading.
                    frecMax = (self.lineEdit_9.text())                          # Maximum Frequency label reading.
                    orden1 = (self.lineEdit_7.text())                           # Reading the Filter Order Label.

                    # Data entry for enveloped (this value is a string by default)
                    Tam = (self.lineEdit_10.text())                             # Reading the envelope window size label.
                    Tsua = (self.lineEdit_5.text())                             # Reading the Smoothing type label.
                    Tnan = (self.lineEdit_13.text())                            # Reading the NaN Tolerance label.

                    # Convert the string value of the input text boxes to float or integer
                    frec7=float(frecMin)                                        # Converts the Minimum Frequency value to float.
                    frec8=float(frecMax)                                        # Converts the Maximum Frequency value to float.
                    orden7=int(orden1)                                          # Converts filter order value to integer.

                    Tam1=int(Tam)                                               # Converts the envelope window size value to integer.
                    Tsua1=int(Tsua)                                             # Converts the Smoothing type value to integer.
                    Tnan1=int(Tnan)                                             # Converts the NaN Tolerance value to integer.

                    timeIn = 365

                    # Function for Shannon entropy calculating
                    def calcular_entropia(datos):
                        params = stats.norm.fit(datos)
                        dist = stats.norm(*params)
                        probabilidades = dist.pdf(datos)
                        entropia = -np.sum(probabilidades * np.log2(probabilidades))
                        return entropia

                    # Function for Kurtosis calculating
                    def calcular_kurtosis(datos):
                        n = len(datos)
                        media = np.mean(datos)
                        varianza = np.var(datos)
                        desviacion_estandar = np.sqrt(varianza)

                        if desviacion_estandar == 0:
                            return 0.0
                        kurtosis = np.sum((datos - media)**4) / (n * desviacion_estandar**4) - 3.0
                        return kurtosis

                    # Function for Shannon entropy enveloped calculating
                    def nanfastsmooth(Y, w, type=1, tol=0.5):

                        """
                        Smooths vector Y with a moving average of width w, ignoring NaNs in data.

                        Parameters:
                        Y (numpy array): Input signal.
                        w (int): Window width.
                        type (int): Smooth type (1 for rectangular, 2 for triangular, 3 for pseudo-Gaussian).
                        tol (float): Tolerance to NaNs between 0 and 1.

                        Returns:
                        numpy array: Smoothed signal.
                        """
                        mask = ~np.isnan(Y)  # Create a boolean mask for non-NaN values
                        Y[mask] = nanfastsmooth_core(Y[mask], w, type, tol)  # Apply smoothing to non-NaN values
                        return Y

                    # Function for Shannon entropy enveloped type calculating. For default the value = 3
                    def nanfastsmooth_core(Y, w, type, tol):
                        if type == 1:
                            SmoothY = moving_average(Y, w)
                        elif type == 2:
                            SmoothY = moving_average(moving_average(Y, w), w)
                        elif type == 3:
                            SmoothY = moving_average(moving_average(moving_average(Y, w), w), w)

                        return SmoothY

                    def moving_average(Y, window_size):
                        return np.convolve(Y, np.ones(window_size)/window_size, mode='same')

                    def calcular_indice_frecuencias(datos, frecuencia_muestreo):
                        # Aplicar filtro en frecuencia
                        freq_bajas = (1, 5.5)
                        freq_altas = (6, 16)

                        datos_bajas = apply_bandpass_filter(datos, frecuencia_muestreo, freq_bajas)
                        datos_altas = apply_bandpass_filter(datos, frecuencia_muestreo, freq_altas)

                        # Calcular energía para cada señal
                        energia_bajas = np.sum(datos_bajas ** 2)
                        energia_altas = np.sum(datos_altas ** 2)

                        # Calcular índice de frecuencias
                        indice_frecuencias = np.log(energia_altas / energia_bajas) if energia_bajas != 0 else np.nan
                        return indice_frecuencias

                    def apply_bandpass_filter(datos, frecuencia_muestreo, freq_band):
                        nyquist = 0.5 * frecuencia_muestreo
                        normal_freq_band = np.array(freq_band) / nyquist
                        b, a = signal.butter(4, normal_freq_band, btype='band')
                        datos_filtrados = signal.filtfilt(b, a, datos)
                        return datos_filtrados

                    # Start entropy and averaged entropy values
                    entropia_shannon = []
                    entropia_promediada = []
                    kurtosis_resultados = []
                    frequency_index = []

                    # Cycle for the day-by-day calculation of the entropy in the files contained in the folder, using the time range (Start to End)
                    for dia in range(1, timeIn + 1):

                        archivo = Nombre3 + '.'+ f"{dia:003}"       # Here you select the name previously calculated plus point and the value of each Julian day

                        # If there is no file in the list, the entire day is added with a value of zero
                        if not os.path.exists(os.path.join(carpeta, archivo)):
                            for _ in range(24):  # Adds 24 hours with zero value if there is no file
                                entropia_shannon.append(0)
                                entropia_promediada.append(0)
                                kurtosis_resultados.append(0)
                                frequency_index.append(0)
                            continue

                        # Designation of the data contained in the folder files
                        st = Stream()
                        st += read(os.path.join(carpeta, archivo))
                        frecuencia_muestreo = st[0].stats.sampling_rate
                        # calculation of the Bandstop filter with the parameters indicated by the user.
                        st.filter('bandstop', freqmin=frec7, freqmax=frec8, corners=orden7, zerophase=True)
                        # Data value
                        datos = st[0].data

                        # Divide the data into hours and calculate entropy for each hour.
                        for hora in range(24):
                            inicio = hora * 3600  # start of time in seconds.
                            fin = inicio + 3600  # End of time in seconds.
                            datos_hora = datos[inicio:fin]

                            if len(datos_hora) < 3600:  # If the hour is incomplete, add zeros to the end.
                                datos_hora = np.append(datos_hora, np.zeros(3600 - len(datos_hora)))

                            # Accumulator of the calculated values of the Shannon entropy and the averaged entropy.
                            entropia_shannon.append(calcular_entropia(datos_hora))
                            entropia_promediada.append(calcular_entropia(datos_hora) / len(datos_hora))
                            kurtosis_resultados.append(calcular_kurtosis(datos_hora))
                            frequency_index.append(calcular_indice_frecuencias(datos_hora, frecuencia_muestreo))

                    # Converting shannon entropy value and averaged entropy to data array.
                    entropia_shannon = np.array(entropia_shannon)
                    entropia_promediada = np.array(entropia_promediada)
                    kurtosis_resultados = np.array(kurtosis_resultados)
                    frequency_index=np.array(frequency_index)

                    # Shannon Entropy Graph. Value of non-zero indices where there is no data.
                    indices_no_cero_shannon = np.where(entropia_shannon != 0)[0]

                    indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                    indices_no_cero_frecuency = np.where(frequency_index != 0)[0]

                    indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]

                    # **** SAVE THE RESULTS FILE .CSV
                    archivoFil2 = (self.label_8.text())                         # Reading directory label.

                    # **** SAVE THE RESULTS .npy FILE FOR LATER GRAPH *****
                    TW = str(Tam1)                                              # Convert Envelope Window value to string for names.
                    F1 = (Nombre3 + '_Bandstop_Filter_1hr_without_Time_interval_Dots_and_Time' + '_Windows=' + TW + '.csv')            # Assign F1, Capture the name of the record and add the .csv extension.

                    # Guardar resultados en archivos .npy
                    F1a = (Nombre3 + '_Bandstop_Filter_1hr_without_Time_interval_Dots_and_Time' + '_Windows=' + TW)
                    F2 = (archivoFil2 + F1)                                     # Assigns to F2 the directory plus the previous name where the record will be stored.
                    F3 = (archivoFil2 + F1a)

                    with open(F2, 'w+', newline='') as archivo_csv:             # Each result is saved in the file, day, time and values of Shannon's entropy and averaged.
                        writer = csv.writer(archivo_csv)
                        writer.writerow(['Day', ' hour', ' Shannon Entropy', ' Averaged Shannon Entropy', ' Enveloped Shannon Entropy', ' Kurtosis', ' Frequency Index'])

                        for dia in range(1, timeIn + 1):                        # Save data by day and time according to the time interval (Start - End)
                            for hora in range(24):
                                writer.writerow([dia, hora, entropia_shannon[(dia - 1) * 24 + hora], entropia_promediada[(dia - 1) * 24 + hora], kurtosis_resultados[(dia - 1) * 24 + hora], frequency_index[(dia - 1) * 24 + hora] ])

                    # Use example
                    Y = entropia_shannon
                    Y = np.where(Y == 0, np.nan, Y)

                    Y1 = kurtosis_resultados
                    Y1 = np.where(Y1 == 0, np.nan, Y1)

                    Y2 = frequency_index
                    Y2 = np.where(Y2 == 0, np.nan, Y2)                                             # Close the existing chart.

                    if self.checkBox_2.isChecked():                                 # CheckBox 2 of the Initial Time is activated (This marks time on the x axis)

                        if not self.lineEdit_14.text():
                            MensCombo14 = QMessageBox()
                            MensCombo14.setIcon(QMessageBox.Warning)
                            MensCombo14.setWindowTitle("Empty Year value")
                            MensCombo14.setText("Please, enter a valid value")
                            returnValue = MensCombo14.exec()

                        elif not self.lineEdit_15.text():
                            MensCombo15 = QMessageBox()
                            MensCombo15.setIcon(QMessageBox.Warning)
                            MensCombo15.setWindowTitle("Empty Month value")
                            MensCombo15.setText("Please, enter a valid value")
                            returnValue = MensCombo15.exec()

                        elif not self.lineEdit_16.text():
                            MensCombo16 = QMessageBox()
                            MensCombo16.setIcon(QMessageBox.Warning)
                            MensCombo16.setWindowTitle("Empty Day value")
                            MensCombo16.setText("Please, enter a valid value")
                            returnValue = MensCombo16.exec()

                        else:

                            # Data entry for enveloped (this value is a string by default)
                            Anio = (self.lineEdit_14.text())                            # Reading the Year value label.
                            Mes = (self.lineEdit_15.text())                             # Reading the Month value label.
                            Dia1 = (self.lineEdit_16.text())                            # Reading the Day value label.

                            # Convert the string value of the input text boxes to  integer

                            Anio1=int(Anio)                                             # Converts the Year value to integer.
                            Mes1=int(Mes)                                               # Converts the Month value to integer.
                            Dia2=int(Dia1)                                              # Converts the NaN Day value to integer.

                            # The date vector is created
                            fecha_inicio = datetime(Anio1, Mes1, Dia2)
                            dias = [fecha_inicio + timedelta(hours=i) for i in range(len(entropia_shannon[indices_no_cero_shannon]))]

                            # "Indices_no_cero_shannon" = np.where(entropia_shannon != 0)[0]
                            st = (dias, entropia_shannon[indices_no_cero_shannon])
                            np.save(F3, st)  # Save the ".npy" file in the directory.
                            plt.close()

                            st = (dias, entropia_shannon[indices_no_cero_shannon])

                            # Save the ".npy" file in the directory.
                            np.save(F3, st)
                            plt.close()                                             # Close the existing chart.

                            # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                            # Graph 1 - ENTROPY BY POINTS.

                            plt.plot(dias, entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='ShannonEntropy: Points per hour -> 1 Hr.')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_ShannonEntropy: Each point = 1 Hr. with Bandstop filter', color ="darkgreen", fontsize=18)

                            # Graph 2 - Averaged Shannon Entropy Graph.

                            fig, ax = plt.subplots(1,1)
                            indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                            plt.plot(dias, entropia_promediada[indices_no_cero_promediada], "ob", mfc="b", mec = "b", label='ShannonAveragedEntropy: Points per hour -> 1 Hr.')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Shannon Averaged Entropy: Each point = 1 Hr. with Bandstop filter.', color ="darkgreen", fontsize=18)

                            # Graph 3 - Graph of Shannon Entropy with the envelope.

                            # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE.

                            fig, ax = plt.subplots(1,1)

                            y_filtered = nanfastsmooth(Y.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                            plt.plot(dias, entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='Shannon_Entropy')
                            plt.plot(dias, y_filtered[indices_no_cero_shannon], color='blue', label='Envelope')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Envelope - Shannon Entropy: Each point = 1 Hr. with Bandstop filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            # Graph 4 - Envelope only graph.

                            fig, ax = plt.subplots(1,1)

                            plt.plot(dias, y_filtered[indices_no_cero_shannon], label='Filtered Signal', color='blue')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Only the envelope of Shannon entropy: Each point = 1 Hr. with Bandstop filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                            # Graph 5 Frequency Index with enveloped
                            fig, ax = plt.subplots(1,1)

                            y_filtered3 = nanfastsmooth(Y2.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                            plt.plot(dias, frequency_index[indices_no_cero_frecuency], 'o-', label='Frequency Index')
                            plt.plot(dias, y_filtered3[indices_no_cero_frecuency], label='Envelope', color='red')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                            plt.title(Nombre3 + ' Frequency Index: Each point = 1 Hr. with Bandstop filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            # Graph 6 Kurtosis with Envelope
                            fig, ax = plt.subplots(1,1)
                            indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]

                            # The date vector is created
                            fecha_inicio = datetime(Anio1, Mes1, Dia2)
                            dias2 = [fecha_inicio + timedelta(hours=i) for i in range(len(entropia_shannon[indices_no_cero_kurtosis]))]

                            y_filtered2 = nanfastsmooth(Y1.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                            plt.plot(dias2, kurtosis_resultados[indices_no_cero_kurtosis], 'o', label='Kurtosis')
                            plt.plot(dias2, y_filtered2[indices_no_cero_kurtosis], label='Envelope', color='red')
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                            plt.title(Nombre3 + ' Kurtosis: Each point = 1 Hr. with Bandstop filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)

                            plt.show()

                    else:

                        # Plot the vectors into separate figures.
                        dias = np.arange(1, 8761 + 1)

                        st = (dias, entropia_shannon[indices_no_cero_shannon])

                        np.save(F3, st)  # Save the ".npy" file in the directory.
                        plt.close()

                        # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                        # Graph 1 - ENTROPY BY POINTS.

                        plt.plot(dias[indices_no_cero_shannon], entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='ShannonEntropy: Points per hour -> 1 Hr.')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_ShannonEntropy: Each point = 1 Hr. with Bandstop filter', color ="darkgreen", fontsize=18)

                        # Graph 2 - Averaged Shannon Entropy Graph.

                        fig, ax = plt.subplots(1,1)
                        indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                        plt.plot(dias[indices_no_cero_promediada], entropia_promediada[indices_no_cero_promediada], "ob", mfc="b", mec = "b", label='ShannonAveragedEntropy: Points per hour -> 1 Hr.')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Shannon Averaged Entropy: Each point = 1 Hr. with Bandstop filter.', color ="darkgreen", fontsize=18)

                        # Graph 3 - Graph of Shannon Entropy with the envelope.

                        # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE.

                        fig, ax = plt.subplots(1,1)

                        y_filtered = nanfastsmooth(Y.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                        plt.plot(dias[indices_no_cero_shannon], entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='Shannon Entropy')
                        plt.plot(dias[indices_no_cero_shannon], y_filtered[indices_no_cero_shannon], label='Envelope', color='blue')
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Envelope - Shannon Entropy: Each point = 1 Hr. with Bandstop filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                        # Graph 4 - Envelope only graph.

                        fig, ax = plt.subplots(1,1)

                        plt.plot(dias[indices_no_cero_shannon], y_filtered[indices_no_cero_shannon], label='Filtered Signal', color='blue')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Only the envelope of Shannon entropy: Each point = 1 Hr. with Bandstop filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                        # Graph 5 Frequency Index with Envelope
                        fig, ax = plt.subplots(1,1)

                        y_filtered3 = nanfastsmooth(Y2.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                        plt.plot(dias[indices_no_cero_frecuency], frequency_index[indices_no_cero_frecuency], 'o-', label='Frequency Index')
                        plt.plot(dias[indices_no_cero_frecuency], y_filtered3[indices_no_cero_frecuency], label='Envelope', color='red')
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                        plt.title(Nombre3 + ' Frequency Index: Each point = 1 Hr. with Bandstop filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)

                        # Graph 6 Kurtosis with Envelope
                        fig, ax = plt.subplots(1,1)
                        indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]
                        #dias2 = [fecha_inicio + timedelta(hours=i) for i in range(len(entropia_shannon[indices_no_cero_kurtosis]))]

                        y_filtered2 = nanfastsmooth(Y1.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                        plt.plot(dias[indices_no_cero_kurtosis], kurtosis_resultados[indices_no_cero_kurtosis], 'o', label='Kurtosis')
                        plt.plot(dias[indices_no_cero_kurtosis], y_filtered2[indices_no_cero_kurtosis], label='Envelope', color='red')
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                        plt.title(Nombre3 + ' Kurtosis: Each point = 1 Hr. with Bandstop filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)

                        plt.show()

        except:                         # In any other case of invalid or empty inputs
                plt.close()                                                 # Close the existing chart.
                msgBox = QMessageBox()
                msgBox.setIcon(QMessageBox.Warning)
                msgBox.setText("The File Does not exist, is Invalid or the CSV old file is open. Please close, try again ...")
                msgBox.setWindowTitle("Invalid Record inputs or CSV Old file is open ")
                returnValue = msgBox.exec()
                pass

    """ Functions to 10 minutes analysis windows """


    def filtropasobajo10(self):                                               # 5.- Function to execute the Lowpass filter with 10 m. analysis window.

        try:

            # Verifying that the checkbox is true. Work with time intervals.

            if self.checkBox.isChecked() == True:           # checkBox for Time interval

                # Verify (Validation), that the text box and label is not empty

                if not self.label_5.text():
                    MensCombo1 = QMessageBox()
                    MensCombo1.setIcon(QMessageBox.Warning)
                    MensCombo1.setWindowTitle("Empty directory to upload records")
                    MensCombo1.setText("Please, enter a valid name of directory")
                    returnValue = MensCombo1.exec()

                elif not self.label_8.text():
                    MensCombo2 = QMessageBox()
                    MensCombo2.setIcon(QMessageBox.Warning)
                    MensCombo2.setWindowTitle("Empty path to store CSV/NPY file")
                    MensCombo2.setText("Please, enter a valid name of directory")
                    returnValue = MensCombo2.exec()

                elif not self.lineEdit_5.text():
                    MensCombo3 = QMessageBox()
                    MensCombo3.setIcon(QMessageBox.Warning)
                    MensCombo3.setWindowTitle("Empty Smoothing type")
                    MensCombo3.setText("Please, enter a valid Value")
                    returnValue = MensCombo3.exec()

                elif not self.lineEdit_6.text():
                    MensCombo4 = QMessageBox()
                    MensCombo4.setIcon(QMessageBox.Warning)
                    MensCombo4.setWindowTitle("Empty Frequency")
                    MensCombo4.setText("Please, enter a valid Value")
                    returnValue = MensCombo4.exec()

                elif not self.lineEdit_7.text():
                    MensCombo5 = QMessageBox()
                    MensCombo5.setIcon(QMessageBox.Warning)
                    MensCombo5.setWindowTitle("Empty Filter Order")
                    MensCombo5.setText("Please, enter a valid Value")
                    returnValue = MensCombo5.exec()

                elif not self.lineEdit_10.text():
                    MensCombo6 = QMessageBox()
                    MensCombo6.setIcon(QMessageBox.Warning)
                    MensCombo6.setWindowTitle("Empty Envelope Window size")
                    MensCombo6.setText("Please, enter a valid Value")
                    returnValue = MensCombo6.exec()

                elif not self.lineEdit_11.text():
                    MensCombo7 = QMessageBox()
                    MensCombo7.setIcon(QMessageBox.Warning)
                    MensCombo7.setWindowTitle("Empty Start time")
                    MensCombo7.setText("Please, enter a valid Value")
                    returnValue = MensCombo7.exec()

                elif not self.lineEdit_12.text():
                    MensCombo8 = QMessageBox()
                    MensCombo8.setIcon(QMessageBox.Warning)
                    MensCombo8.setWindowTitle("Empty End time")
                    MensCombo8.setText("Please, enter a valid Value")
                    returnValue = MensCombo8.exec()

                elif not self.lineEdit_13.text():
                    MensCombo9 = QMessageBox()
                    MensCombo9.setIcon(QMessageBox.Warning)
                    MensCombo9.setWindowTitle("Empty NaN Tolerance")
                    MensCombo9.setText("Please, enter a valid Value")
                    returnValue = MensCombo9.exec()

                else:
                    # Filtering with a Lowpass 10 min.
                    plt.close()                                                 # Close the existing chart.

                    carpeta = (self.label_5.text())                             # Reading the directory or file folder label.

                    # Code to detect the contents of the folder and the files that the folder contains
                    with os.scandir(carpeta) as ficheros:
                        ficheros4 = [fichero.name for fichero in ficheros if fichero.is_file()]

                    # The contents of the files in "ficheros4" is a list. This code converts them to string
                    lfiles = [str(elemento) for elemento in ficheros4]

                    # Code used to determine the name of the files contained in the folder and to be used in the loading loop
                    Iniciolfiles = lfiles[0]                                    # Detects the numeric value of the "Start" in the name
                    Finlfiles = lfiles[-1]                                      # Detects the numerical value of the "End" in the name
                    Indice1 = Iniciolfiles.rfind('.')                           # Determines the index, which will be marked by the dot at the end for the extension
                    Nombre3 = Iniciolfiles[0:Indice1]                           # Indicates the name of the file in str (minus) the index or extension (each day)

                    # Data entry from labels and fields or text boxes (this value is a string by default)
                    frec3 = (self.lineEdit_6.text())                            # reading frequency Label.
                    orden1 = (self.lineEdit_7.text())                           # Reading the Filter Order Label.

                    # Data entry for enveloped (this value is a string by default)
                    Tam = (self.lineEdit_10.text())                             # Reading the envelope window size label.
                    Tsua = (self.lineEdit_5.text())                             # Reading the Smoothing type label.
                    Tnan = (self.lineEdit_13.text())                            # Reading the NaN Tolerance label.

                    Start1 = (self.lineEdit_11.text())                          # Star Time Size label reading.
                    End1 = (self.lineEdit_12.text())                            # End Time Size label reading.

                    # Convert the string value of the input text boxes to float or integer
                    frec4=float(frec3)                                          # Converts Frequency value to float.
                    orden4=int(orden1)                                          # Converts filter order value to integer.

                    Tam1=int(Tam)                                               # Converts the envelope window size value to integer.
                    Tsua1=int(Tsua)                                             # Converts the Smoothing type value to integer.
                    Tnan1=int(Tnan)                                             # Converts the NaN Tolerance value to integer.

                    timeIn = 365

                    Start2=int(Start1)                                          # Converts the Start time window size value to an integer.
                    End2=int(End1)                                              # Converts the End time window size value to an integer.

                    Diferencia = End2 - Start2                                  # Value of the difference between end and start to obtain the number of days to calculate

                    # Function for Shannon entropy calculating
                    def calcular_entropia(datos):
                        params = stats.norm.fit(datos)
                        dist = stats.norm(*params)
                        probabilidades = dist.pdf(datos)
                        entropia = -np.sum(probabilidades * np.log2(probabilidades))
                        return entropia

                    # Function for Kurtosis calculating
                    def calcular_kurtosis(datos):
                        n = len(datos)
                        media = np.mean(datos)
                        varianza = np.var(datos)
                        desviacion_estandar = np.sqrt(varianza)

                        if desviacion_estandar == 0:
                            return 0.0
                        kurtosis = np.sum((datos - media)**4) / (n * desviacion_estandar**4) - 3.0
                        return kurtosis

                    # Function for Shannon entropy enveloped calculating
                    def nanfastsmooth(Y, w, type=1, tol=0.5):

                        """
                        Smooths vector Y with a moving average of width w, ignoring NaNs in data.

                        Parameters:
                        Y (numpy array): Input signal.
                        w (int): Window width.
                        type (int): Smooth type (1 for rectangular, 2 for triangular, 3 for pseudo-Gaussian).
                        tol (float): Tolerance to NaNs between 0 and 1.

                        Returns:
                        numpy array: Smoothed signal.
                        """
                        mask = ~np.isnan(Y)  # Create a boolean mask for non-NaN values
                        Y[mask] = nanfastsmooth_core(Y[mask], w, type, tol)  # Apply smoothing to non-NaN values
                        return Y

                    # Function for Shannon entropy enveloped type calculating. For default the value = 3
                    def nanfastsmooth_core(Y, w, type, tol):
                        if type == 1:
                            SmoothY = moving_average(Y, w)
                        elif type == 2:
                            SmoothY = moving_average(moving_average(Y, w), w)
                        elif type == 3:
                            SmoothY = moving_average(moving_average(moving_average(Y, w), w), w)

                        return SmoothY

                    def moving_average(Y, window_size):
                        return np.convolve(Y, np.ones(window_size)/window_size, mode='same')

                    def calcular_indice_frecuencias(datos, frecuencia_muestreo):
                        # Aplicar filtro en frecuencia
                        freq_bajas = (1, 5.5)
                        freq_altas = (6, 16)

                        datos_bajas = apply_bandpass_filter(datos, frecuencia_muestreo, freq_bajas)
                        datos_altas = apply_bandpass_filter(datos, frecuencia_muestreo, freq_altas)

                        # Calcular energía para cada señal
                        energia_bajas = np.sum(datos_bajas ** 2)
                        energia_altas = np.sum(datos_altas ** 2)

                        # Calcular índice de frecuencias
                        indice_frecuencias = np.log(energia_altas / energia_bajas) if energia_bajas != 0 else np.nan
                        return indice_frecuencias

                    def apply_bandpass_filter(datos, frecuencia_muestreo, freq_band):
                        nyquist = 0.5 * frecuencia_muestreo
                        normal_freq_band = np.array(freq_band) / nyquist
                        b, a = signal.butter(4, normal_freq_band, btype='band')
                        datos_filtrados = signal.filtfilt(b, a, datos)
                        return datos_filtrados

                    # Start entropy and averaged entropy values
                    entropia_shannon = []
                    entropia_promediada = []
                    kurtosis_resultados = []
                    frequency_index = []

                    # Cycle for the day-by-day calculation of the entropy in the files contained in the folder, using the time range (Start to End)
                    for dia in range(Start2, End2 + 1):

                        archivo = Nombre3 + '.'+ f"{dia:003}"       # Here you select the name previously calculated plus point and the value of each Julian day

                        # If there is no file in the list, the entire day is added with a value of zero
                        if not os.path.exists(os.path.join(carpeta, archivo)):
                            for _ in range(24*6):  # Adds 24 hours with zero value if there is no file
                                entropia_shannon.append(0)
                                entropia_promediada.append(0)
                                kurtosis_resultados.append(0)
                                frequency_index.append(0)
                            continue

                        # Designation of the data contained in the folder files
                        st = Stream()
                        st += read(os.path.join(carpeta, archivo))
                        frecuencia_muestreo = st[0].stats.sampling_rate
                        # calculation of the Lowpass filter with the parameters indicated by the user.
                        st.filter('lowpass', freq=frec4, corners=orden4, zerophase=True)
                        # Data value
                        datos = st[0].data

                        # Divide the data into hours and calculate entropy for each hour.
                        for hora in range(24*6):
                            inicio = hora * 600 * 100  # start of time in seconds.
                            fin = inicio + 600 * 100  # End of time in seconds.
                            datos_hora = datos[inicio:fin]

                            if len(datos_hora) < 600 * 100:  # If the hour is incomplete, add zeros to the end.
                                datos_hora = np.append(datos_hora, np.zeros(600 * 100 - len(datos_hora)))

                            # Accumulator of the calculated values of the Shannon entropy and the averaged entropy.
                            entropia_shannon.append(calcular_entropia(datos_hora))
                            entropia_promediada.append(calcular_entropia(datos_hora) / len(datos_hora))
                            kurtosis_resultados.append(calcular_kurtosis(datos_hora))
                            frequency_index.append(calcular_indice_frecuencias(datos_hora, frecuencia_muestreo))

                    # Converting shannon entropy value and averaged entropy to data array.
                    entropia_shannon = np.array(entropia_shannon)
                    entropia_promediada = np.array(entropia_promediada)
                    kurtosis_resultados = np.array(kurtosis_resultados)
                    frequency_index=np.array(frequency_index)

                    # Shannon Entropy Graph. Value of non-zero indices where there is no data.
                    indices_no_cero_shannon = np.where(entropia_shannon != 0)[0]

                    indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                    indices_no_cero_frecuency = np.where(frequency_index != 0)[0]

                    indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]

                    # **** READ THE LABEL, FOR SAVE THE RESULTS FILE .CSV
                    archivoFil2 = (self.label_8.text())                         # Reading directory label.

                    # **** SAVE THE RESULTS .csv and .npy FILE FOR LATER GRAPH *****
                    TW = str(Tam1)                                              # Convert Envelope Window value to string for names.
                    F1 = (Nombre3 + '_Highpass_Filter_10m ' + '_Windows=' + TW + '.csv')            # Assign F1, Capture the name of the record and add the .csv extension.

                    # Guardar resultados en archivos .npy
                    F1a = (Nombre3 + '_Highpass_Filter_10m' + '_Windows=' + TW)
                    F2 = (archivoFil2 + F1)                                     # Assigns to F2 the directory plus the previous name where the record will be stored.
                    F3 = (archivoFil2 + F1a)


                    # **** SAVE THE RESULTS FILE .CSV ***
                    with open(F2, 'w+', newline='') as archivo_csv:             # Each result is saved in the file, day, time and values of Shannon's entropy and averaged.
                        writer = csv.writer(archivo_csv)
                        writer.writerow(['Day', ' Hour', ' Shannon Entropy', ' Averaged Shannon Entropy', ' Envelope Shannon Entropy', ' Kurtosis', ' Frequency Index'])

                        for dia in range(1, Diferencia + 1):                        # Save data by day and time according to the time interval (Start - End)
                            for hora in range(24*6):
                                writer.writerow([dia, hora, entropia_shannon[(dia - 1) * 24*6 + hora], entropia_promediada[(dia - 1) * 24*6 + hora], kurtosis_resultados[(dia - 1) * 24*6 + hora], frequency_index[(dia - 1) * 24*6 + hora] ])

                    # Use example
                    Y = entropia_shannon
                    Y = np.where(Y == 0, np.nan, Y)

                    Y1 = kurtosis_resultados
                    Y1 = np.where(Y1 == 0, np.nan, Y1)

                    Y2 = frequency_index
                    Y2 = np.where(Y2 == 0, np.nan, Y2)

                    # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                    if self.checkBox_2.isChecked():                                 # checkBox for Initial Time

                        if not self.lineEdit_14.text():
                            MensCombo14 = QMessageBox()
                            MensCombo14.setIcon(QMessageBox.Warning)
                            MensCombo14.setWindowTitle("Empty Year value")
                            MensCombo14.setText("Please, enter a valid value")
                            returnValue = MensCombo14.exec()

                        elif not self.lineEdit_15.text():
                            MensCombo15 = QMessageBox()
                            MensCombo15.setIcon(QMessageBox.Warning)
                            MensCombo15.setWindowTitle("Empty Month value")
                            MensCombo15.setText("Please, enter a valid value")
                            returnValue = MensCombo15.exec()

                        elif not self.lineEdit_16.text():
                            MensCombo16 = QMessageBox()
                            MensCombo16.setIcon(QMessageBox.Warning)
                            MensCombo16.setWindowTitle("Empty Day value")
                            MensCombo16.setText("Please, enter a valid value")
                            returnValue = MensCombo16.exec()

                        else:

                            # Data entry for enveloped (this value is a string by default)
                            Anio = (self.lineEdit_14.text())                            # Reading the Year value label.
                            Mes = (self.lineEdit_15.text())                             # Reading the Month value label.
                            Dia1 = (self.lineEdit_16.text())                            # Reading the Day value label.

                            # Convert the string value of the input text boxes to  integer

                            Anio1=int(Anio)                                             # Converts the Year value to integer.
                            Mes1=int(Mes)                                               # Converts the Month value to integer.
                            Dia2=int(Dia1)                                              # Converts the NaN Day value to integer.

                            # Dates vector create
                            fecha_inicio = datetime(Anio1, Mes1, Dia2)
                            dias = [fecha_inicio + timedelta(minutes=(10*i)) for i in range(len(entropia_shannon[indices_no_cero_shannon]))]

                            st = (dias, entropia_shannon[indices_no_cero_shannon])

                            # Save the ".npy" file in the directory.
                            np.save(F3, st)
                            plt.close()                                             # Close the existing chart.


                            # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                            # Graph 1 - ENTROPY BY POINTS.

                            plt.plot(dias, entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='ShannonEntropy: Points per hour -> 10 min')
                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_ShannonEntropy: Each point = 10 min. with Lowpass filter', color ="darkgreen", fontsize=18)

                            # Graph 2 - Averaged Shannon Entropy Graph.

                            fig, ax = plt.subplots(1,1)
                            indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                            plt.plot(dias, entropia_promediada[indices_no_cero_promediada], "ob", mfc="b", mec = "b", label='ShannonAveragedEntropy: Points per hour -> 10 min')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Shannon Averaged Entropy: Each point = 10 min. with Lowpass filter.', color ="darkgreen", fontsize=18)

                            # Graph 3 - Graph of Shannon Entropy plus the envelope.

                            # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE.

                            fig, ax = plt.subplots(1,1)

                            y_filtered = nanfastsmooth(Y.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                            plt.plot(dias, entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='Shannon Entropy')
                            plt.plot(dias, y_filtered[indices_no_cero_shannon], label='Envelope', color='blue')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Envelope - Shannon Entropy: Each point = 10 min. with Lowpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            # Graph 4 - Envelope only graph.

                            fig, ax = plt.subplots(1,1)

                            plt.plot(dias, y_filtered[indices_no_cero_shannon], label='Filtered Signal', color='blue')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Only the envelope of Shannon entropy: Each point = 10 min. with Lowpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                            # Graph 5 Frequency Index con envolvente
                            fig, ax = plt.subplots(1,1)

                            y_filtered3 = nanfastsmooth(Y2.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                            plt.plot(dias, frequency_index[indices_no_cero_frecuency], 'o-', label='Frequency Index')
                            plt.plot(dias, y_filtered3[indices_no_cero_frecuency], label='Envelope', color='red')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                            plt.title(Nombre3 + ' Frequency Index: Each point = 10 min. with Lowpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            # Graph 6 Kurtosis with envelope
                            fig, ax = plt.subplots(1,1)
                            #indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]

                            # Dates vector create
                            fecha_inicio = datetime(Anio1, Mes1, Dia2)
                            dias2 = [fecha_inicio + timedelta(minutes=(10*i)) for i in range(len(entropia_shannon[indices_no_cero_kurtosis]))]

                            y_filtered2 = nanfastsmooth(Y1.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                            plt.plot(dias2, kurtosis_resultados[indices_no_cero_kurtosis], 'o', label='Kurtosis')
                            plt.plot(dias2, y_filtered2[indices_no_cero_kurtosis], label='Envelope', color='red')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                            plt.title(Nombre3 + ' Kurtosis: Each point = 10 min. with Lowpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            plt.show()

                    else:

                        # Plot the vectors into separate figures.
                        dias = np.arange(1, 8761*6+1)

                        st = (dias, entropia_shannon[indices_no_cero_shannon])

                        np.save(F3, st)  # Save the ".npy" file in the directory.
                        plt.close()

                        # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                        # Graph 1 - ENTROPY BY POINTS.

                        plt.plot(dias[indices_no_cero_shannon], entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='ShannonEntropy: Points per hour -> 10 min')

                        #plt.plot(dias, entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='ShannonEntropy: Points per hour -> 1 hr')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_ShannonEntropy: Each point = 10 min. with Lowpass filter', color ="darkgreen", fontsize=18)

                        # Graph 2 - Averaged Shannon Entropy Graph.

                        fig, ax = plt.subplots(1,1)
                        indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                        plt.plot(dias[indices_no_cero_promediada], entropia_promediada[indices_no_cero_promediada], "ob", mfc="b", mec = "b", label='ShannonAveragedEntropy: Points per hour -> 10 min')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Shannon Averaged Entropy: Each point = 10 min. with Lowpass filter.', color ="darkgreen", fontsize=18)


                        # Graph 3 - Graph of Shannon Entropy plus the envelope.

                        # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE.

                        fig, ax = plt.subplots(1,1)

                        y_filtered = nanfastsmooth(Y.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                        plt.plot(dias[indices_no_cero_shannon], entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='Shannon Entropy')
                        plt.plot(dias[indices_no_cero_shannon], y_filtered[indices_no_cero_shannon], label='Envelope', color='blue')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Envelope - Shannon Entropy: Each point = 10 min. with Lowpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        # Graph 4 - Envelope only graph.

                        fig, ax = plt.subplots(1,1)

                        plt.plot(dias[indices_no_cero_shannon], y_filtered[indices_no_cero_shannon], label='Filtered Signal', color='blue')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Only the envelope of Shannon entropy: Each point = 10 min. with Lowpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                        # Graph 5 Frequency Index con envolvente
                        fig, ax = plt.subplots(1,1)

                        y_filtered3 = nanfastsmooth(Y2.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                        plt.plot(dias[indices_no_cero_frecuency], frequency_index[indices_no_cero_frecuency], 'o-', label='Frequency Index')
                        plt.plot(dias[indices_no_cero_frecuency], y_filtered3[indices_no_cero_frecuency], label='Envelope', color='red')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                        plt.title(Nombre3 + ' Frequency Index: Each point = 10 min. with Lowpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        # Graph 6 Kurtosis with envelope
                        fig, ax = plt.subplots(1,1)
                        #indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]

                        y_filtered2 = nanfastsmooth(Y1.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                        plt.plot(dias[indices_no_cero_kurtosis], kurtosis_resultados[indices_no_cero_kurtosis], 'o', label='Kurtosis')
                        plt.plot(dias[indices_no_cero_kurtosis], y_filtered2[indices_no_cero_kurtosis], label='Envelope', color='red')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                        plt.title(Nombre3 + ' Kurtosis: Each point = 10 min. with Lowpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        plt.show()

            else:                                           # Here the value of the entropy is calculated without the time interval (Start - End)

                if not self.label_5.text():
                    MensCombo1 = QMessageBox()
                    MensCombo1.setIcon(QMessageBox.Warning)
                    MensCombo1.setWindowTitle("Empty directory to upload records")
                    MensCombo1.setText("Please, enter a valid name of directory")
                    returnValue = MensCombo1.exec()

                elif not self.label_8.text():
                    MensCombo2 = QMessageBox()
                    MensCombo2.setIcon(QMessageBox.Warning)
                    MensCombo2.setWindowTitle("Empty path to store CSV/NPY file")
                    MensCombo2.setText("Please, enter a valid name of directory")
                    returnValue = MensCombo2.exec()

                elif not self.lineEdit_5.text():
                    MensCombo3 = QMessageBox()
                    MensCombo3.setIcon(QMessageBox.Warning)
                    MensCombo3.setWindowTitle("Empty Smoothing type")
                    MensCombo3.setText("Please, enter a valid Value")
                    returnValue = MensCombo3.exec()

                elif not self.lineEdit_6.text():
                    MensCombo4 = QMessageBox()
                    MensCombo4.setIcon(QMessageBox.Warning)
                    MensCombo4.setWindowTitle("Empty Frequency")
                    MensCombo4.setText("Please, enter a valid Value")
                    returnValue = MensCombo4.exec()

                elif not self.lineEdit_7.text():
                    MensCombo5 = QMessageBox()
                    MensCombo5.setIcon(QMessageBox.Warning)
                    MensCombo5.setWindowTitle("Empty Filter Order")
                    MensCombo5.setText("Please, enter a valid Value")
                    returnValue = MensCombo5.exec()

                elif not self.lineEdit_10.text():
                    MensCombo6 = QMessageBox()
                    MensCombo6.setIcon(QMessageBox.Warning)
                    MensCombo6.setWindowTitle("Empty Envelope Window size")
                    MensCombo6.setText("Please, enter a valid Value")
                    returnValue = MensCombo6.exec()

                elif not self.lineEdit_13.text():
                    MensCombo7 = QMessageBox()
                    MensCombo7.setIcon(QMessageBox.Warning)
                    MensCombo7.setWindowTitle("Empty NaN Tolerance")
                    MensCombo7.setText("Please, enter a valid Value")
                    returnValue = MensCombo7.exec()

                else:
                    # Filtering with a Lowpass 10 min.
                    plt.close()                                                 # Close the existing chart.

                    carpeta = (self.label_5.text())                             # Reading the directory or file folder label.

                    # Code to detect the contents of the folder and the files that the folder contains
                    with os.scandir(carpeta) as ficheros:
                        ficheros4 = [fichero.name for fichero in ficheros if fichero.is_file()]

                    # The contents of the files in "ficheros4" is a list. This code converts them to string
                    lfiles = [str(elemento) for elemento in ficheros4]

                    # Code used to determine the name of the files contained in the folder and to be used in the loading loop
                    Iniciolfiles = lfiles[0]                                    # Detects the numeric value of the "Start" in the name
                    Finlfiles = lfiles[-1]                                      # Detects the numerical value of the "End" in the name
                    Indice1 = Iniciolfiles.rfind('.')                           # Determines the index, which will be marked by the dot at the end for the extension
                    Nombre3 = Iniciolfiles[0:Indice1]                           # Indicates the name of the file in str (minus) the index or extension (each day)

                    # Data entry from labels and fields or text boxes (this value is a string by default)
                    frec3 = (self.lineEdit_6.text())                            # reading frequency Label.
                    orden1 = (self.lineEdit_7.text())                           # Reading the Filter Order Label.


                    # Data entry for enveloped (this value is a string by default)
                    Tam = (self.lineEdit_10.text())                             # Reading the envelope window size label.
                    Tsua = (self.lineEdit_5.text())                             # Reading the Smoothing type label.
                    Tnan = (self.lineEdit_13.text())                            # Reading the NaN Tolerance label.

                    # Convert the string value of the input text boxes to float or integer
                    frec4=float(frec3)                                          # Converts Frequency value to float.
                    orden4=int(orden1)                                          # Converts filter order value to integer.

                    Tam1=int(Tam)                                               # Converts the envelope window size value to integer.
                    Tsua1=int(Tsua)                                             # Converts the Smoothing type value to integer.
                    Tnan1=int(Tnan)                                             # Converts the NaN Tolerance value to integer.

                    timeIn = 365

                    # Function for Shannon entropy calculating
                    def calcular_entropia(datos):
                        params = stats.norm.fit(datos)
                        dist = stats.norm(*params)
                        probabilidades = dist.pdf(datos)
                        entropia = -np.sum(probabilidades * np.log2(probabilidades))
                        return entropia

                    # Function for Kurtosis calculating
                    def calcular_kurtosis(datos):
                        n = len(datos)
                        media = np.mean(datos)
                        varianza = np.var(datos)
                        desviacion_estandar = np.sqrt(varianza)

                        if desviacion_estandar == 0:
                            return 0.0
                        kurtosis = np.sum((datos - media)**4) / (n * desviacion_estandar**4) - 3.0
                        return kurtosis

                    # Function for Shannon entropy enveloped calculating
                    def nanfastsmooth(Y, w, type=1, tol=0.5):

                        """
                        Smooths vector Y with a moving average of width w, ignoring NaNs in data.

                        Parameters:
                        Y (numpy array): Input signal.
                        w (int): Window width.
                        type (int): Smooth type (1 for rectangular, 2 for triangular, 3 for pseudo-Gaussian).
                        tol (float): Tolerance to NaNs between 0 and 1.

                        Returns:
                        numpy array: Smoothed signal.
                        """
                        mask = ~np.isnan(Y)  # Create a boolean mask for non-NaN values
                        Y[mask] = nanfastsmooth_core(Y[mask], w, type, tol)  # Apply smoothing to non-NaN values
                        return Y

                    # Function for Shannon entropy enveloped type calculating. For default the value = 3
                    def nanfastsmooth_core(Y, w, type, tol):
                        if type == 1:
                            SmoothY = moving_average(Y, w)
                        elif type == 2:
                            SmoothY = moving_average(moving_average(Y, w), w)
                        elif type == 3:
                            SmoothY = moving_average(moving_average(moving_average(Y, w), w), w)

                        return SmoothY

                    def moving_average(Y, window_size):
                        return np.convolve(Y, np.ones(window_size)/window_size, mode='same')

                    def calcular_indice_frecuencias(datos, frecuencia_muestreo):
                        # Aplicar filtro en frecuencia
                        freq_bajas = (1, 5.5)
                        freq_altas = (6, 16)

                        datos_bajas = apply_bandpass_filter(datos, frecuencia_muestreo, freq_bajas)
                        datos_altas = apply_bandpass_filter(datos, frecuencia_muestreo, freq_altas)

                        # Calcular energía para cada señal
                        energia_bajas = np.sum(datos_bajas ** 2)
                        energia_altas = np.sum(datos_altas ** 2)

                        # Calcular índice de frecuencias
                        indice_frecuencias = np.log(energia_altas / energia_bajas) if energia_bajas != 0 else np.nan
                        return indice_frecuencias

                    def apply_bandpass_filter(datos, frecuencia_muestreo, freq_band):
                        nyquist = 0.5 * frecuencia_muestreo
                        normal_freq_band = np.array(freq_band) / nyquist
                        b, a = signal.butter(4, normal_freq_band, btype='band')
                        datos_filtrados = signal.filtfilt(b, a, datos)
                        return datos_filtrados

                    # Start entropy and averaged entropy values
                    entropia_shannon = []
                    entropia_promediada = []
                    kurtosis_resultados = []
                    frequency_index = []

                    # Cycle for the day-by-day calculation of the entropy in the files contained in the folder, using the time range (Start to End)
                    for dia in range(1, timeIn + 1):

                        archivo = Nombre3 + '.'+ f"{dia:003}"       # Here you select the name previously calculated plus point and the value of each Julian day

                        # If there is no file in the list, the entire day is added with a value of zero
                        if not os.path.exists(os.path.join(carpeta, archivo)):
                            for _ in range(24*6):  # Adds 24 hours with zero value if there is no file
                                entropia_shannon.append(0)
                                entropia_promediada.append(0)
                                kurtosis_resultados.append(0)
                                frequency_index.append(0)
                            continue

                        # Designation of the data contained in the folder files
                        st = Stream()
                        st += read(os.path.join(carpeta, archivo))
                        frecuencia_muestreo = st[0].stats.sampling_rate
                        # calculation of the Lowpass filter with the parameters indicated by the user.
                        st.filter('lowpass', freq=frec4, corners=orden4, zerophase=True)
                        # Data value
                        datos = st[0].data

                        # Divide the data into hours and calculate entropy for each hour.
                        for hora in range(24*6):
                            inicio = hora * 600 * 100  # start of time in seconds.
                            fin = inicio + 600 * 100  # End of time in seconds.
                            datos_hora = datos[inicio:fin]

                            if len(datos_hora) < 600 * 100:  # If the hour is incomplete, add zeros to the end.
                                datos_hora = np.append(datos_hora, np.zeros(600 * 100 - len(datos_hora)))

                            # Accumulator of the calculated values of the Shannon entropy and the averaged entropy.
                            entropia_shannon.append(calcular_entropia(datos_hora))
                            entropia_promediada.append(calcular_entropia(datos_hora) / len(datos_hora))
                            kurtosis_resultados.append(calcular_kurtosis(datos_hora))
                            frequency_index.append(calcular_indice_frecuencias(datos_hora, frecuencia_muestreo))

                    # Converting shannon entropy value and averaged entropy to data array.
                    entropia_shannon = np.array(entropia_shannon)
                    entropia_promediada = np.array(entropia_promediada)
                    kurtosis_resultados = np.array(kurtosis_resultados)
                    frequency_index=np.array(frequency_index)

                    # Shannon Entropy Graph. Value of non-zero indices where there is no data.
                    indices_no_cero_shannon = np.where(entropia_shannon != 0)[0]

                    indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                    indices_no_cero_frecuency = np.where(frequency_index != 0)[0]

                    indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]

                    # **** SAVE THE RESULTS FILE .CSV
                    archivoFil2 = (self.label_8.text())                         # Reading directory label.

                   # **** SAVE THE RESULTS  .CSV and .NPY FILE FOR LATER GRAPH *****
                    TW = str(Tam1)                                              # Convert Envelope Window value to string for names.
                    F1 = (Nombre3 + '_Lowpass_Filter_10m ' + '_Windows=' + TW + '.csv')            # Assign F1, Capture the name of the record and add the .csv extension.

                    F1a = (Nombre3 + '_Lowpass_Filter_10m' + '_Windows=' + TW)
                    F2 = (archivoFil2 + F1)                                     # Assigns to F2 the directory plus the previous name where the record will be stored.
                    F3 = (archivoFil2 + F1a)


                    # **** SAVE THE RESULTS FILE .CSV ***
                    with open(F2, 'w+', newline='') as archivo_csv:             # Each result is saved in the file, day, time and values of Shannon's entropy and averaged.
                        writer = csv.writer(archivo_csv)
                        writer.writerow(['Day', ' hour', ' Shannon Entropy', ' Averaged Shannon Entropy', ' Envelope Shannon Entropy', ' Kurtosis', ' Frequency Index'])

                        for dia in range(1, timeIn + 1):                        # Save data by day and time according to the time interval (Start - End)
                            for hora in range(24*6):
                                writer.writerow([dia, hora, entropia_shannon[(dia - 1) * 24*6 + hora], entropia_promediada[(dia - 1) * 24*6 + hora], kurtosis_resultados[(dia - 1) * 24*6 + hora], frequency_index[(dia - 1) * 24*6 + hora] ])


                    # Use example
                    Y = entropia_shannon
                    Y = np.where(Y == 0, np.nan, Y)

                    Y1 = kurtosis_resultados
                    Y1 = np.where(Y1 == 0, np.nan, Y1)

                    Y2 = frequency_index
                    Y2 = np.where(Y2 == 0, np.nan, Y2)

                    if self.checkBox_2.isChecked():                                 # checkBox for Initial Time

                        if not self.lineEdit_14.text():
                            MensCombo14 = QMessageBox()
                            MensCombo14.setIcon(QMessageBox.Warning)
                            MensCombo14.setWindowTitle("Empty Year value")
                            MensCombo14.setText("Please, enter a valid value")
                            returnValue = MensCombo14.exec()

                        elif not self.lineEdit_15.text():
                            MensCombo15 = QMessageBox()
                            MensCombo15.setIcon(QMessageBox.Warning)
                            MensCombo15.setWindowTitle("Empty Month value")
                            MensCombo15.setText("Please, enter a valid value")
                            returnValue = MensCombo15.exec()

                        elif not self.lineEdit_16.text():
                            MensCombo16 = QMessageBox()
                            MensCombo16.setIcon(QMessageBox.Warning)
                            MensCombo16.setWindowTitle("Empty Day value")
                            MensCombo16.setText("Please, enter a valid value")
                            returnValue = MensCombo16.exec()

                        else:

                            # Data entry for enveloped (this value is a string by default)
                            Anio = (self.lineEdit_14.text())                            # Reading the Year value label.
                            Mes = (self.lineEdit_15.text())                             # Reading the Month value label.
                            Dia1 = (self.lineEdit_16.text())                            # Reading the Day value label.

                            # Convert the string value of the input text boxes to  integer

                            Anio1=int(Anio)                                             # Converts the Year value to integer.
                            Mes1=int(Mes)                                               # Converts the Month value to integer.
                            Dia2=int(Dia1)                                              # Converts the NaN Day value to integer.

                            # Dates vector create
                            fecha_inicio = datetime(Anio1, Mes1, Dia2)
                            dias = [fecha_inicio + timedelta(minutes=(6*i)) for i in range(len(entropia_shannon[indices_no_cero_shannon]))]

                            st = (dias, entropia_shannon[indices_no_cero_shannon])

                            # Save the ".npy" file in the directory.
                            np.save(F3, st)
                            plt.close()                                             # Close the existing chart.

                            # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                            # Graph 1 - ENTROPY BY POINTS.

                            plt.plot(dias, entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='ShannonEntropy: Points per hour -> 10 min')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_ShannonEntropy: Each point = 10 min. with Lowpass filter', color ="darkgreen", fontsize=18)

                            # Graph 2 - Averaged Shannon Entropy Graph.

                            fig, ax = plt.subplots(1,1)
                            indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                            plt.plot(dias, entropia_promediada[indices_no_cero_promediada], "ob", mfc="b", mec = "b", label='ShannonAveragedEntropy: Points per hour -> 10 min')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Shannon Averaged Entropy: Each point = 10 min. with Lowpass filter.', color ="darkgreen", fontsize=18)

                            # Graph 3 - Graph of Shannon Entropy plus the envelope.

                            # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE.

                            fig, ax = plt.subplots(1,1)

                            y_filtered = nanfastsmooth(Y.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                            plt.plot(dias, entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='Shannon Entropy')
                            plt.plot(dias, y_filtered[indices_no_cero_shannon], label='Envelope', color='blue')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Envelope - Shannon Entropy: Each point = 10 min. with Lowpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            # Graph 4 - Envelope only graph.

                            fig, ax = plt.subplots(1,1)

                            plt.plot(dias, y_filtered[indices_no_cero_shannon], label='Filtered Signal', color='blue')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Only the envelope of Shannon entropy: Each point = 10 min. with Lowpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                            # Graph 5 Frequency Index con envolvente
                            fig, ax = plt.subplots(1,1)

                            y_filtered3 = nanfastsmooth(Y2.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                            plt.plot(dias, frequency_index[indices_no_cero_frecuency], 'o-', label='Frequency Index')
                            plt.plot(dias, y_filtered3[indices_no_cero_frecuency], label='Envelope', color='red')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                            plt.title(Nombre3 + ' Frequency Index: Each point = 10 min. with Lowpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            # Graph 6 Kurtosis with envelope
                            fig, ax = plt.subplots(1,1)
                            #indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]

                            # Dates vector create
                            fecha_inicio = datetime(Anio1, Mes1, Dia2)
                            dias2 = [fecha_inicio + timedelta(minutes=(10*i)) for i in range(len(entropia_shannon[indices_no_cero_kurtosis]))]

                            y_filtered2 = nanfastsmooth(Y1.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                            plt.plot(dias2, kurtosis_resultados[indices_no_cero_kurtosis], 'o', label='Kurtosis')
                            plt.plot(dias2, y_filtered2[indices_no_cero_kurtosis], label='Envelope', color='red')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                            plt.title(Nombre3 + ' Kurtosis: Each point = 10 min. with Lowpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            plt.show()

                    else:

                        # Plot the vectors into separate figures.
                        dias = np.arange(1, 8761*6+1)

                        st = (dias, entropia_shannon[indices_no_cero_shannon])

                        np.save(F3, st)  # Save the ".npy" file in the directory.
                        plt.close()

                        # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                        # Graph 1 - ENTROPY BY POINTS.

                        plt.plot(dias[indices_no_cero_shannon], entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='ShannonEntropy: Points per hour -> 10 min')

                        #plt.plot(dias, entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='ShannonEntropy: Points per hour -> 1 hr')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_ShannonEntropy: Each point = 10 min. with Lowpass filter', color ="darkgreen", fontsize=18)

                        # Graph 2 - Averaged Shannon Entropy Graph.

                        fig, ax = plt.subplots(1,1)
                        indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                        plt.plot(dias[indices_no_cero_promediada], entropia_promediada[indices_no_cero_promediada], "ob", mfc="b", mec = "b", label='ShannonAveragedEntropy: Points per hour -> 10 min')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Shannon Averaged Entropy: Each point = 10 min. with Lowpass filter.', color ="darkgreen", fontsize=18)

                        # Graph 3 - Graph of Shannon Entropy plus the envelope.

                        # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE.

                        fig, ax = plt.subplots(1,1)

                        y_filtered = nanfastsmooth(Y.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                        plt.plot(dias[indices_no_cero_shannon], entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='Shannon Entropy')
                        plt.plot(dias[indices_no_cero_shannon], y_filtered[indices_no_cero_shannon], label='Envelope', color='blue')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Envelope - Shannon Entropy: Each point = 10 min. with Lowpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        # Graph 4 - Envelope only graph.

                        fig, ax = plt.subplots(1,1)

                        plt.plot(dias[indices_no_cero_shannon], y_filtered[indices_no_cero_shannon], label='Filtered Signal', color='blue')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Only the envelope of Shannon entropy: Each point = 10 min. with Lowpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                        # Graph 5 Frequency Index con envolvente
                        fig, ax = plt.subplots(1,1)

                        y_filtered3 = nanfastsmooth(Y2.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                        plt.plot(dias[indices_no_cero_frecuency], frequency_index[indices_no_cero_frecuency], 'o-', label='Frequency Index')
                        plt.plot(dias[indices_no_cero_frecuency], y_filtered3[indices_no_cero_frecuency], label='Envelope', color='red')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                        plt.title(Nombre3 + ' Frequency Index: Each point = 10 min. with Lowpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        # Graph 6 Kurtosis with enveloped
                        fig, ax = plt.subplots(1,1)
                        #indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]

                        y_filtered2 = nanfastsmooth(Y1.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                        plt.plot(dias[indices_no_cero_kurtosis], kurtosis_resultados[indices_no_cero_kurtosis], 'o', label='Kurtosis')
                        plt.plot(dias[indices_no_cero_kurtosis], y_filtered2[indices_no_cero_kurtosis], label='Envelope', color='red')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                        plt.title(Nombre3 + ' Kurtosis: Each point = 10 min. with Lowpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        plt.show()

        except:                         # In any other case of invalid or empty inputs
                plt.close()                                                 # Close the existing chart.
                msgBox = QMessageBox()
                msgBox.setIcon(QMessageBox.Warning)
                msgBox.setText("The File Does not exist, is Invalid or the CSV old file is open. Please close, try again ...")
                msgBox.setWindowTitle("Invalid Record inputs or CSV Old file is open ")
                returnValue = msgBox.exec()
                pass


    def filtropasoalto10(self):                                               # 6.- Function to execute the Highpass filter with 10 m. analysis window

        try:

            # Verifying that the checkbox is true. Work with time intervals.

            if self.checkBox.isChecked() == True:           # checkBox for Time interval

                # Verify (Validation), that the text box and label is not empty

                if not self.label_5.text():
                    MensCombo1 = QMessageBox()
                    MensCombo1.setIcon(QMessageBox.Warning)
                    MensCombo1.setWindowTitle("Empty directory to upload records")
                    MensCombo1.setText("Please, enter a valid name of directory")
                    returnValue = MensCombo1.exec()

                elif not self.label_8.text():
                    MensCombo2 = QMessageBox()
                    MensCombo2.setIcon(QMessageBox.Warning)
                    MensCombo2.setWindowTitle("Empty path to store CSV/NPY file")
                    MensCombo2.setText("Please, enter a valid name of directory")
                    returnValue = MensCombo2.exec()

                elif not self.lineEdit_5.text():
                    MensCombo3 = QMessageBox()
                    MensCombo3.setIcon(QMessageBox.Warning)
                    MensCombo3.setWindowTitle("Empty Smoothing type")
                    MensCombo3.setText("Please, enter a valid Value")
                    returnValue = MensCombo3.exec()

                elif not self.lineEdit_6.text():
                    MensCombo4 = QMessageBox()
                    MensCombo4.setIcon(QMessageBox.Warning)
                    MensCombo4.setWindowTitle("Empty Frequency")
                    MensCombo4.setText("Please, enter a valid Value")
                    returnValue = MensCombo4.exec()

                elif not self.lineEdit_7.text():
                    MensCombo5 = QMessageBox()
                    MensCombo5.setIcon(QMessageBox.Warning)
                    MensCombo5.setWindowTitle("Empty Filter Order")
                    MensCombo5.setText("Please, enter a valid Value")
                    returnValue = MensCombo5.exec()

                elif not self.lineEdit_10.text():
                    MensCombo6 = QMessageBox()
                    MensCombo6.setIcon(QMessageBox.Warning)
                    MensCombo6.setWindowTitle("Empty Envelope Window size")
                    MensCombo6.setText("Please, enter a valid Value")
                    returnValue = MensCombo6.exec()

                elif not self.lineEdit_11.text():
                    MensCombo7 = QMessageBox()
                    MensCombo7.setIcon(QMessageBox.Warning)
                    MensCombo7.setWindowTitle("Empty Start time")
                    MensCombo7.setText("Please, enter a valid Value")
                    returnValue = MensCombo7.exec()

                elif not self.lineEdit_12.text():
                    MensCombo8 = QMessageBox()
                    MensCombo8.setIcon(QMessageBox.Warning)
                    MensCombo8.setWindowTitle("Empty End time")
                    MensCombo8.setText("Please, enter a valid Value")
                    returnValue = MensCombo8.exec()

                elif not self.lineEdit_13.text():
                    MensCombo9 = QMessageBox()
                    MensCombo9.setIcon(QMessageBox.Warning)
                    MensCombo9.setWindowTitle("Empty NaN Tolerance")
                    MensCombo9.setText("Please, enter a valid Value")
                    returnValue = MensCombo9.exec()

                else:
                    # Filtering with a Highpass 10 min.
                    plt.close()                                                 # Close the existing chart.

                    carpeta = (self.label_5.text())                             # Reading the directory or file folder label.

                    # Code to detect the contents of the folder and the files that the folder contains
                    with os.scandir(carpeta) as ficheros:
                        ficheros4 = [fichero.name for fichero in ficheros if fichero.is_file()]

                    # The contents of the files in "ficheros4" is a list. This code converts them to string
                    lfiles = [str(elemento) for elemento in ficheros4]

                    # Code used to determine the name of the files contained in the folder and to be used in the loading loop
                    Iniciolfiles = lfiles[0]                                    # Detects the numeric value of the "Start" in the name
                    Finlfiles = lfiles[-1]                                      # Detects the numerical value of the "End" in the name
                    Indice1 = Iniciolfiles.rfind('.')                           # Determines the index, which will be marked by the dot at the end for the extension
                    Nombre3 = Iniciolfiles[0:Indice1]                           # Indicates the name of the file in str (minus) the index or extension (each day)

                    # Data entry from labels and fields or text boxes (this value is a string by default)
                    frec3 = (self.lineEdit_6.text())                            # reading frequency Label.
                    orden1 = (self.lineEdit_7.text())                           # Reading the Filter Order Label.


                    # Data entry for enveloped (this value is a string by default)
                    Tam = (self.lineEdit_10.text())                             # Reading the envelope window size label.
                    Tsua = (self.lineEdit_5.text())                             # Reading the Smoothing type label.
                    Tnan = (self.lineEdit_13.text())                            # Reading the NaN Tolerance label.

                    Start1 = (self.lineEdit_11.text())                          # Star Time Size label reading.
                    End1 = (self.lineEdit_12.text())                            # End Time Size label reading.

                    # Convert the string value of the input text boxes to float or integer
                    frec4=float(frec3)                                          # Converts Frequency value to float.
                    orden4=int(orden1)                                          # Converts filter order value to integer.

                    Tam1=int(Tam)                                               # Converts the envelope window size value to integer.
                    Tsua1=int(Tsua)                                             # Converts the Smoothing type value to integer.
                    Tnan1=int(Tnan)                                             # Converts the NaN Tolerance value to integer.

                    timeIn = 365

                    Start2=int(Start1)                                          # Converts the Start time window size value to an integer.
                    End2=int(End1)                                              # Converts the End time window size value to an integer.

                    Diferencia = End2 - Start2                                  # Value of the difference between end and start to obtain the number of days to calculate

                    # Function for Shannon entropy calculating
                    def calcular_entropia(datos):
                        params = stats.norm.fit(datos)
                        dist = stats.norm(*params)
                        probabilidades = dist.pdf(datos)
                        entropia = -np.sum(probabilidades * np.log2(probabilidades))
                        return entropia

                    # Function for Kurtosis calculating
                    def calcular_kurtosis(datos):
                        n = len(datos)
                        media = np.mean(datos)
                        varianza = np.var(datos)
                        desviacion_estandar = np.sqrt(varianza)

                        if desviacion_estandar == 0:
                            return 0.0
                        kurtosis = np.sum((datos - media)**4) / (n * desviacion_estandar**4) - 3.0
                        return kurtosis

                    # Function for Shannon entropy enveloped calculating
                    def nanfastsmooth(Y, w, type=1, tol=0.5):

                        """
                        Smooths vector Y with a moving average of width w, ignoring NaNs in data.

                        Parameters:
                        Y (numpy array): Input signal.
                        w (int): Window width.
                        type (int): Smooth type (1 for rectangular, 2 for triangular, 3 for pseudo-Gaussian).
                        tol (float): Tolerance to NaNs between 0 and 1.

                        Returns:
                        numpy array: Smoothed signal.
                        """
                        mask = ~np.isnan(Y)  # Create a boolean mask for non-NaN values
                        Y[mask] = nanfastsmooth_core(Y[mask], w, type, tol)  # Apply smoothing to non-NaN values
                        return Y

                    # Function for Shannon entropy enveloped type calculating. For default the value = 3
                    def nanfastsmooth_core(Y, w, type, tol):
                        if type == 1:
                            SmoothY = moving_average(Y, w)
                        elif type == 2:
                            SmoothY = moving_average(moving_average(Y, w), w)
                        elif type == 3:
                            SmoothY = moving_average(moving_average(moving_average(Y, w), w), w)

                        return SmoothY

                    def moving_average(Y, window_size):
                        return np.convolve(Y, np.ones(window_size)/window_size, mode='same')

                    def calcular_indice_frecuencias(datos, frecuencia_muestreo):
                        # Aplicar filtro en frecuencia
                        freq_bajas = (1, 5.5)
                        freq_altas = (6, 16)

                        datos_bajas = apply_bandpass_filter(datos, frecuencia_muestreo, freq_bajas)
                        datos_altas = apply_bandpass_filter(datos, frecuencia_muestreo, freq_altas)

                        # Calcular energía para cada señal
                        energia_bajas = np.sum(datos_bajas ** 2)
                        energia_altas = np.sum(datos_altas ** 2)

                        # Calcular índice de frecuencias
                        indice_frecuencias = np.log(energia_altas / energia_bajas) if energia_bajas != 0 else np.nan
                        return indice_frecuencias

                    def apply_bandpass_filter(datos, frecuencia_muestreo, freq_band):
                        nyquist = 0.5 * frecuencia_muestreo
                        normal_freq_band = np.array(freq_band) / nyquist
                        b, a = signal.butter(4, normal_freq_band, btype='band')
                        datos_filtrados = signal.filtfilt(b, a, datos)
                        return datos_filtrados

                    # Start entropy and averaged entropy values
                    entropia_shannon = []
                    entropia_promediada = []
                    kurtosis_resultados = []
                    frequency_index = []

                    # Cycle for the day-by-day calculation of the entropy in the files contained in the folder, using the time range (Start to End)
                    for dia in range(Start2, End2 + 1):

                        archivo = Nombre3 + '.'+ f"{dia:003}"       # Here you select the name previously calculated plus point and the value of each Julian day

                        # If there is no file in the list, the entire day is added with a value of zero
                        if not os.path.exists(os.path.join(carpeta, archivo)):
                            for _ in range(24*6):  # Adds 24 hours with zero value if there is no file
                                entropia_shannon.append(0)
                                entropia_promediada.append(0)
                                kurtosis_resultados.append(0)
                                frequency_index.append(0)
                            continue

                        # Designation of the data contained in the folder files
                        st = Stream()
                        st += read(os.path.join(carpeta, archivo))
                        frecuencia_muestreo = st[0].stats.sampling_rate
                        # calculation of the Highpass filter with the parameters indicated by the user.
                        st.filter('highpass', freq=frec4, corners=orden4, zerophase=True)
                        # Data value
                        datos = st[0].data

                        # Divide the data into hours and calculate entropy for each hour.
                        for hora in range(24*6):
                            inicio = hora * 600 * 100  # start of time in seconds.
                            fin = inicio + 600 * 100  # End of time in seconds.
                            datos_hora = datos[inicio:fin]

                            if len(datos_hora) < 600 * 100:  # If the hour is incomplete, add zeros to the end.
                                datos_hora = np.append(datos_hora, np.zeros(600 * 100 - len(datos_hora)))

                            # Accumulator of the calculated values of the Shannon entropy and the averaged entropy.
                            entropia_shannon.append(calcular_entropia(datos_hora))
                            entropia_promediada.append(calcular_entropia(datos_hora) / len(datos_hora))
                            kurtosis_resultados.append(calcular_kurtosis(datos_hora))
                            frequency_index.append(calcular_indice_frecuencias(datos_hora, frecuencia_muestreo))

                    # Converting shannon entropy value and averaged entropy to data array.
                    entropia_shannon = np.array(entropia_shannon)
                    entropia_promediada = np.array(entropia_promediada)
                    kurtosis_resultados = np.array(kurtosis_resultados)
                    frequency_index=np.array(frequency_index)

                    # Shannon Entropy Graph. Value of non-zero indices where there is no data.
                    indices_no_cero_shannon = np.where(entropia_shannon != 0)[0]

                    indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                    indices_no_cero_frecuency = np.where(frequency_index != 0)[0]

                    indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]

                    # **** READ THE LABEL, FOR SAVE THE RESULTS FILE .CSV
                    archivoFil2 = (self.label_8.text())                         # Reading directory label.

                    # **** SAVE THE RESULTS .csv and .npy FILE FOR LATER GRAPH *****
                    TW = str(Tam1)                                              # Convert Envelope Window value to string for names.
                    F1 = (Nombre3 + '_Highpass_Filter_10m ' + '_Windows=' + TW + '.csv')            # Assign F1, Capture the name of the record and add the .csv extension.

                    # Guardar resultados en archivos .npy
                    F1a = (Nombre3 + '_Highpass_Filter_10m' + '_Windows=' + TW)
                    F2 = (archivoFil2 + F1)                                     # Assigns to F2 the directory plus the previous name where the record will be stored.
                    F3 = (archivoFil2 + F1a)


                    # **** SAVE THE RESULTS FILE .CSV ***
                    with open(F2, 'w+', newline='') as archivo_csv:             # Each result is saved in the file, day, time and values of Shannon's entropy and averaged.
                        writer = csv.writer(archivo_csv)
                        writer.writerow(['Day', ' Hour', ' Shannon Entropy', ' Averaged Shannon Entropy', ' Envelope Shannon Entropy', ' Kurtosis', ' Frequency Index'])

                        for dia in range(1, Diferencia + 1):                        # Save data by day and time according to the time interval (Start - End)
                            for hora in range(24*6):
                                writer.writerow([dia, hora, entropia_shannon[(dia - 1) * 24*6 + hora], entropia_promediada[(dia - 1) * 24*6 + hora], kurtosis_resultados[(dia - 1) * 24*6 + hora], frequency_index[(dia - 1) * 24*6 + hora] ])

                    # Use example
                    Y = entropia_shannon
                    Y = np.where(Y == 0, np.nan, Y)

                    Y1 = kurtosis_resultados
                    Y1 = np.where(Y1 == 0, np.nan, Y1)

                    Y2 = frequency_index
                    Y2 = np.where(Y2 == 0, np.nan, Y2)

                    # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                    # Graph 1 - ENTROPY BY POINTS.

                    if self.checkBox_2.isChecked():                                 # checkBox for Initial Time

                        if not self.lineEdit_14.text():
                            MensCombo14 = QMessageBox()
                            MensCombo14.setIcon(QMessageBox.Warning)
                            MensCombo14.setWindowTitle("Empty Year value")
                            MensCombo14.setText("Please, enter a valid value")
                            returnValue = MensCombo14.exec()

                        elif not self.lineEdit_15.text():
                            MensCombo15 = QMessageBox()
                            MensCombo15.setIcon(QMessageBox.Warning)
                            MensCombo15.setWindowTitle("Empty Month value")
                            MensCombo15.setText("Please, enter a valid value")
                            returnValue = MensCombo15.exec()

                        elif not self.lineEdit_16.text():
                            MensCombo16 = QMessageBox()
                            MensCombo16.setIcon(QMessageBox.Warning)
                            MensCombo16.setWindowTitle("Empty Day value")
                            MensCombo16.setText("Please, enter a valid value")
                            returnValue = MensCombo16.exec()

                        else:

                            # Data entry for enveloped (this value is a string by default)
                            Anio = (self.lineEdit_14.text())                            # Reading the Year value label.
                            Mes = (self.lineEdit_15.text())                             # Reading the Month value label.
                            Dia1 = (self.lineEdit_16.text())                            # Reading the Day value label.

                            # Convert the string value of the input text boxes to  integer

                            Anio1=int(Anio)                                             # Converts the Year value to integer.
                            Mes1=int(Mes)                                               # Converts the Month value to integer.
                            Dia2=int(Dia1)                                              # Converts the NaN Day value to integer.

                            # Dates vector create
                            fecha_inicio = datetime(Anio1, Mes1, Dia2)
                            dias = [fecha_inicio + timedelta(minutes=(10*i)) for i in range(len(entropia_shannon[indices_no_cero_shannon]))]

                            st = (dias, entropia_shannon[indices_no_cero_shannon])

                            # Save the ".npy" file in the directory.
                            np.save(F3, st)
                            plt.close()                                             # Close the existing chart.

                            # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                            # Graph 1 - ENTROPY BY POINTS.

                            plt.plot(dias, entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='Shannon Entropy: Points per hour -> 10 min')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_ShannonEntropy: Each point = 10 min. with Highpass filter', color ="darkgreen", fontsize=18)

                            # Graph 2 - Averaged Shannon Entropy Graph.

                            fig, ax = plt.subplots(1,1)
                            indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                            plt.plot(dias, entropia_promediada[indices_no_cero_promediada], "ob", mfc="b", mec = "b", label='ShannonAveragedEntropy: Points per hour -> 10 min')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Shannon Averaged Entropy: Each point = 10 min. with Highpass filter.', color ="darkgreen", fontsize=18)

                            # Graph 3 - Graph of Shannon Entropy plus the envelope.

                            # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE.

                            fig, ax = plt.subplots(1,1)

                            y_filtered = nanfastsmooth(Y.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                            plt.plot(dias, entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='Shannon Entropy')
                            plt.plot(dias, y_filtered[indices_no_cero_shannon], label='Envelope', color='blue')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Envelope - Shannon Entropy: Each point = 10 min. with Highpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            # Graph 4 - Envelope only graph.

                            fig, ax = plt.subplots(1,1)

                            plt.plot(dias, y_filtered[indices_no_cero_shannon], label='Filtered Signal', color='blue')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Only the envelope of Shannon entropy: Each point = 10 min. with Highpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                            # Graph 5 Frequency Index con envolvente
                            fig, ax = plt.subplots(1,1)

                            y_filtered3 = nanfastsmooth(Y2.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                            plt.plot(dias, frequency_index[indices_no_cero_frecuency], 'o-', label='Frequency Index')
                            plt.plot(dias, y_filtered3[indices_no_cero_frecuency], label='Envelope', color='red')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                            plt.title(Nombre3 + ' Frequency Index: Each point = 10 min. with Highpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            # Graph 6 Kurtosis with envelope
                            fig, ax = plt.subplots(1,1)
                            indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]

                            # Dates vector create
                            fecha_inicio = datetime(Anio1, Mes1, Dia2)
                            dias2 = [fecha_inicio + timedelta(minutes=(10*i)) for i in range(len(entropia_shannon[indices_no_cero_kurtosis]))]

                            y_filtered2 = nanfastsmooth(Y1.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                            plt.plot(dias2, kurtosis_resultados[indices_no_cero_kurtosis], 'o', label='Kurtosis')
                            plt.plot(dias2, y_filtered2[indices_no_cero_kurtosis], label='Envelope', color='red')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                            plt.title(Nombre3 + ' Kurtosis: Each point = 10 min. with Highpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            plt.show()

                    else:

                        # Plot the vectors into separate figures.
                        dias = np.arange(1, 8761*6+1)

                        st = (dias, entropia_shannon[indices_no_cero_shannon])

                        np.save(F3, st)  # Save the ".npy" file in the directory.
                        plt.close()

                        # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                        # Graph 1 - ENTROPY BY POINTS.

                        plt.plot(dias[indices_no_cero_shannon], entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='ShannonEntropy: Points per hour -> 10 min')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_ShannonEntropy: Each point = 10 min. with Highpass filter', color ="darkgreen", fontsize=18)

                        # Graph 2 - Averaged Shannon Entropy Graph.

                        fig, ax = plt.subplots(1,1)
                        indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                        plt.plot(dias[indices_no_cero_promediada], entropia_promediada[indices_no_cero_promediada], "ob", mfc="b", mec = "b", label='ShannonAveragedEntropy: Points per hour -> 10 min')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Shannon Averaged Entropy: Each point = 10 min. with Highpass filter.', color ="darkgreen", fontsize=18)

                        # Graph 3 - Graph of Shannon Entropy plus the envelope.

                        # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE.

                        fig, ax = plt.subplots(1,1)

                        y_filtered = nanfastsmooth(Y.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                        plt.plot(dias[indices_no_cero_shannon], entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='Shannon Entropy')
                        plt.plot(dias[indices_no_cero_shannon], y_filtered[indices_no_cero_shannon], label='Envelope', color='blue')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Envelope - Shannon Entropy: Each point = 10 min. with Highpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        # Graph 4 - Envelope only graph.

                        fig, ax = plt.subplots(1,1)

                        plt.plot(dias[indices_no_cero_shannon], y_filtered[indices_no_cero_shannon], label='Filtered Signal', color='blue')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Only the envelope of Shannon entropy: Each point = 10 min. with Highpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                        # Graph 5 Frequency Index con envolvente
                        fig, ax = plt.subplots(1,1)

                        y_filtered3 = nanfastsmooth(Y2.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                        plt.plot(dias[indices_no_cero_frecuency], frequency_index[indices_no_cero_frecuency], 'o-', label='Frequency Index')
                        plt.plot(dias[indices_no_cero_frecuency], y_filtered3[indices_no_cero_frecuency], label='Envelope', color='red')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                        plt.title(Nombre3 + ' Frequency Index: Each point = 10 min. with Highpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        # Graph 6 Kurtosis with envelope
                        fig, ax = plt.subplots(1,1)
                        indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]

                        y_filtered2 = nanfastsmooth(Y1.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                        plt.plot(dias[indices_no_cero_kurtosis], kurtosis_resultados[indices_no_cero_kurtosis], 'o', label='Kurtosis')
                        plt.plot(dias[indices_no_cero_kurtosis], y_filtered2[indices_no_cero_kurtosis], label='Envelope', color='red')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                        plt.title(Nombre3 + ' Kurtosis: Each point = 10 min. with Highpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        plt.show()

            else:                                           # Here the value of the entropy is calculated without the time interval (Start - End)

                if not self.label_5.text():
                    MensCombo1 = QMessageBox()
                    MensCombo1.setIcon(QMessageBox.Warning)
                    MensCombo1.setWindowTitle("Empty directory to upload records")
                    MensCombo1.setText("Please, enter a valid name of directory")
                    returnValue = MensCombo1.exec()

                elif not self.label_8.text():
                    MensCombo2 = QMessageBox()
                    MensCombo2.setIcon(QMessageBox.Warning)
                    MensCombo2.setWindowTitle("Empty path to store CSV/NPY file")
                    MensCombo2.setText("Please, enter a valid name of directory")
                    returnValue = MensCombo2.exec()

                elif not self.lineEdit_5.text():
                    MensCombo3 = QMessageBox()
                    MensCombo3.setIcon(QMessageBox.Warning)
                    MensCombo3.setWindowTitle("Empty Smoothing type")
                    MensCombo3.setText("Please, enter a valid Value")
                    returnValue = MensCombo3.exec()

                elif not self.lineEdit_6.text():
                    MensCombo4 = QMessageBox()
                    MensCombo4.setIcon(QMessageBox.Warning)
                    MensCombo4.setWindowTitle("Empty Frequency")
                    MensCombo4.setText("Please, enter a valid Value")
                    returnValue = MensCombo4.exec()

                elif not self.lineEdit_7.text():
                    MensCombo5 = QMessageBox()
                    MensCombo5.setIcon(QMessageBox.Warning)
                    MensCombo5.setWindowTitle("Empty Filter Order")
                    MensCombo5.setText("Please, enter a valid Value")
                    returnValue = MensCombo5.exec()

                elif not self.lineEdit_10.text():
                    MensCombo6 = QMessageBox()
                    MensCombo6.setIcon(QMessageBox.Warning)
                    MensCombo6.setWindowTitle("Empty Envelope Window size")
                    MensCombo6.setText("Please, enter a valid Value")
                    returnValue = MensCombo6.exec()

                elif not self.lineEdit_13.text():
                    MensCombo7 = QMessageBox()
                    MensCombo7.setIcon(QMessageBox.Warning)
                    MensCombo7.setWindowTitle("Empty NaN Tolerance")
                    MensCombo7.setText("Please, enter a valid Value")
                    returnValue = MensCombo7.exec()

                else:
                    # Filtering with a Highpass 10 min.
                    plt.close()                                                 # Close the existing chart.

                    carpeta = (self.label_5.text())                             # Reading the directory or file folder label.

                    # Code to detect the contents of the folder and the files that the folder contains
                    with os.scandir(carpeta) as ficheros:
                        ficheros4 = [fichero.name for fichero in ficheros if fichero.is_file()]

                    # The contents of the files in "ficheros4" is a list. This code converts them to string
                    lfiles = [str(elemento) for elemento in ficheros4]

                    # Code used to determine the name of the files contained in the folder and to be used in the loading loop
                    Iniciolfiles = lfiles[0]                                    # Detects the numeric value of the "Start" in the name
                    Finlfiles = lfiles[-1]                                      # Detects the numerical value of the "End" in the name
                    Indice1 = Iniciolfiles.rfind('.')                           # Determines the index, which will be marked by the dot at the end for the extension
                    Nombre3 = Iniciolfiles[0:Indice1]                           # Indicates the name of the file in str (minus) the index or extension (each day)

                    # Data entry from labels and fields or text boxes (this value is a string by default)
                    frec3 = (self.lineEdit_6.text())                            # reading frequency Label.
                    orden1 = (self.lineEdit_7.text())                           # Reading the Filter Order Label.

                    # Data entry for enveloped (this value is a string by default)
                    Tam = (self.lineEdit_10.text())                             # Reading the envelope window size label.
                    Tsua = (self.lineEdit_5.text())                             # Reading the Smoothing type label.
                    Tnan = (self.lineEdit_13.text())                            # Reading the NaN Tolerance label.

                    # Convert the string value of the input text boxes to float or integer
                    frec4=float(frec3)                                          # Converts Frequency value to float.
                    orden4=int(orden1)                                          # Converts filter order value to integer.

                    Tam1=int(Tam)                                               # Converts the envelope window size value to integer.
                    Tsua1=int(Tsua)                                             # Converts the Smoothing type value to integer.
                    Tnan1=int(Tnan)                                             # Converts the NaN Tolerance value to integer.

                    timeIn = 365

                    # Function for Shannon entropy calculating
                    def calcular_entropia(datos):
                        params = stats.norm.fit(datos)
                        dist = stats.norm(*params)
                        probabilidades = dist.pdf(datos)
                        entropia = -np.sum(probabilidades * np.log2(probabilidades))
                        return entropia

                    # Function for Kurtosis calculating
                    def calcular_kurtosis(datos):
                        n = len(datos)
                        media = np.mean(datos)
                        varianza = np.var(datos)
                        desviacion_estandar = np.sqrt(varianza)

                        if desviacion_estandar == 0:
                            return 0.0
                        kurtosis = np.sum((datos - media)**4) / (n * desviacion_estandar**4) - 3.0
                        return kurtosis

                    # Function for Shannon entropy enveloped calculating
                    def nanfastsmooth(Y, w, type=1, tol=0.5):

                        """
                        Smooths vector Y with a moving average of width w, ignoring NaNs in data.

                        Parameters:
                        Y (numpy array): Input signal.
                        w (int): Window width.
                        type (int): Smooth type (1 for rectangular, 2 for triangular, 3 for pseudo-Gaussian).
                        tol (float): Tolerance to NaNs between 0 and 1.

                        Returns:
                        numpy array: Smoothed signal.
                        """
                        mask = ~np.isnan(Y)  # Create a boolean mask for non-NaN values
                        Y[mask] = nanfastsmooth_core(Y[mask], w, type, tol)  # Apply smoothing to non-NaN values
                        return Y

                    # Function for Shannon entropy enveloped type calculating. For default the value = 3
                    def nanfastsmooth_core(Y, w, type, tol):
                        if type == 1:
                            SmoothY = moving_average(Y, w)
                        elif type == 2:
                            SmoothY = moving_average(moving_average(Y, w), w)
                        elif type == 3:
                            SmoothY = moving_average(moving_average(moving_average(Y, w), w), w)

                        return SmoothY

                    def moving_average(Y, window_size):
                        return np.convolve(Y, np.ones(window_size)/window_size, mode='same')

                    def calcular_indice_frecuencias(datos, frecuencia_muestreo):
                        # Aplicar filtro en frecuencia
                        freq_bajas = (1, 5.5)
                        freq_altas = (6, 16)

                        datos_bajas = apply_bandpass_filter(datos, frecuencia_muestreo, freq_bajas)
                        datos_altas = apply_bandpass_filter(datos, frecuencia_muestreo, freq_altas)

                        # Calcular energía para cada señal
                        energia_bajas = np.sum(datos_bajas ** 2)
                        energia_altas = np.sum(datos_altas ** 2)

                        # Calcular índice de frecuencias
                        indice_frecuencias = np.log(energia_altas / energia_bajas) if energia_bajas != 0 else np.nan
                        return indice_frecuencias

                    def apply_bandpass_filter(datos, frecuencia_muestreo, freq_band):
                        nyquist = 0.5 * frecuencia_muestreo
                        normal_freq_band = np.array(freq_band) / nyquist
                        b, a = signal.butter(4, normal_freq_band, btype='band')
                        datos_filtrados = signal.filtfilt(b, a, datos)
                        return datos_filtrados

                    # Start entropy and averaged entropy values
                    entropia_shannon = []
                    entropia_promediada = []
                    kurtosis_resultados = []
                    frequency_index = []

                    # Cycle for the day-by-day calculation of the entropy in the files contained in the folder, using the time range (Start to End)
                    for dia in range(1, timeIn + 1):

                        archivo = Nombre3 + '.'+ f"{dia:003}"       # Here you select the name previously calculated plus point and the value of each Julian day

                        # If there is no file in the list, the entire day is added with a value of zero
                        if not os.path.exists(os.path.join(carpeta, archivo)):
                            for _ in range(24*6):  # Adds 24 hours with zero value if there is no file
                                entropia_shannon.append(0)
                                entropia_promediada.append(0)
                                kurtosis_resultados.append(0)
                                frequency_index.append(0)
                            continue

                        # Designation of the data contained in the folder files
                        st = Stream()
                        st += read(os.path.join(carpeta, archivo))
                        frecuencia_muestreo = st[0].stats.sampling_rate
                        # calculation of the Highpass filter with the parameters indicated by the user.
                        st.filter('highpass', freq=frec4, corners=orden4, zerophase=True)
                        # Data value
                        datos = st[0].data

                        # Divide the data into hours and calculate entropy for each hour.
                        for hora in range(24*6):
                            inicio = hora * 600 * 100  # start of time in seconds.
                            fin = inicio + 600 * 100  # End of time in seconds.
                            datos_hora = datos[inicio:fin]

                            if len(datos_hora) < 600 * 100:  # If the hour is incomplete, add zeros to the end.
                                datos_hora = np.append(datos_hora, np.zeros(600 * 100 - len(datos_hora)))

                            # Accumulator of the calculated values of the Shannon entropy and the averaged entropy.
                            entropia_shannon.append(calcular_entropia(datos_hora))
                            entropia_promediada.append(calcular_entropia(datos_hora) / len(datos_hora))
                            kurtosis_resultados.append(calcular_kurtosis(datos_hora))
                            frequency_index.append(calcular_indice_frecuencias(datos_hora, frecuencia_muestreo))

                    # Converting shannon entropy value and averaged entropy to data array.
                    entropia_shannon = np.array(entropia_shannon)
                    entropia_promediada = np.array(entropia_promediada)
                    kurtosis_resultados = np.array(kurtosis_resultados)
                    frequency_index=np.array(frequency_index)

                    # Shannon Entropy Graph. Value of non-zero indices where there is no data.
                    indices_no_cero_shannon = np.where(entropia_shannon != 0)[0]

                    indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                    indices_no_cero_frecuency = np.where(frequency_index != 0)[0]

                    indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]

                    # **** SAVE THE RESULTS FILE .CSV
                    archivoFil2 = (self.label_8.text())                         # Reading directory label.

                   # **** SAVE THE RESULTS  .CSV and .NPY FILE FOR LATER GRAPH *****
                    TW = str(Tam1)                                              # Convert Envelope Window value to string for names.
                    F1 = (Nombre3 + '_Highpass_Filter_10m ' + '_Windows=' + TW + '.csv')            # Assign F1, Capture the name of the record and add the .csv extension.

                    F1a = (Nombre3 + '_Highpass_Filter_10m' + '_Windows=' + TW)
                    F2 = (archivoFil2 + F1)                                     # Assigns to F2 the directory plus the previous name where the record will be stored.
                    F3 = (archivoFil2 + F1a)


                    # **** SAVE THE RESULTS FILE .CSV ***
                    with open(F2, 'w+', newline='') as archivo_csv:             # Each result is saved in the file, day, time and values of Shannon's entropy and averaged.
                        writer = csv.writer(archivo_csv)
                        writer.writerow(['Day', ' hour', ' Shannon Entropy', ' Averaged Shannon Entropy', ' Envelope Shannon Entropy', ' Kurtosis', ' Frequency Index'])

                        for dia in range(1, timeIn + 1):                        # Save data by day and time according to the time interval (Start - End)
                            for hora in range(24*6):
                                writer.writerow([dia, hora, entropia_shannon[(dia - 1) * 24*6 + hora], entropia_promediada[(dia - 1) * 24*6 + hora], kurtosis_resultados[(dia - 1) * 24*6 + hora], frequency_index[(dia - 1) * 24*6 + hora] ])

                    # Use example
                    Y = entropia_shannon
                    Y = np.where(Y == 0, np.nan, Y)

                    Y1 = kurtosis_resultados
                    Y1 = np.where(Y1 == 0, np.nan, Y1)

                    Y2 = frequency_index
                    Y2 = np.where(Y2 == 0, np.nan, Y2)

                    if self.checkBox_2.isChecked():                                 # checkBox for Initial Time

                        if not self.lineEdit_14.text():
                            MensCombo14 = QMessageBox()
                            MensCombo14.setIcon(QMessageBox.Warning)
                            MensCombo14.setWindowTitle("Empty Year value")
                            MensCombo14.setText("Please, enter a valid value")
                            returnValue = MensCombo14.exec()

                        elif not self.lineEdit_15.text():
                            MensCombo15 = QMessageBox()
                            MensCombo15.setIcon(QMessageBox.Warning)
                            MensCombo15.setWindowTitle("Empty Month value")
                            MensCombo15.setText("Please, enter a valid value")
                            returnValue = MensCombo15.exec()

                        elif not self.lineEdit_16.text():
                            MensCombo16 = QMessageBox()
                            MensCombo16.setIcon(QMessageBox.Warning)
                            MensCombo16.setWindowTitle("Empty Day value")
                            MensCombo16.setText("Please, enter a valid value")
                            returnValue = MensCombo16.exec()

                        else:

                            # Data entry for enveloped (this value is a string by default)
                            Anio = (self.lineEdit_14.text())                            # Reading the Year value label.
                            Mes = (self.lineEdit_15.text())                             # Reading the Month value label.
                            Dia1 = (self.lineEdit_16.text())                            # Reading the Day value label.

                            # Convert the string value of the input text boxes to  integer

                            Anio1=int(Anio)                                             # Converts the Year value to integer.
                            Mes1=int(Mes)                                               # Converts the Month value to integer.
                            Dia2=int(Dia1)                                              # Converts the NaN Day value to integer.

                            # Dates vector create
                            fecha_inicio = datetime(Anio1, Mes1, Dia2)
                            dias = [fecha_inicio + timedelta(minutes=(10*i)) for i in range(len(entropia_shannon[indices_no_cero_shannon]))]

                            st = (dias, entropia_shannon[indices_no_cero_shannon])

                            # Save the ".npy" file in the directory.
                            np.save(F3, st)
                            plt.close()                                             # Close the existing chart.

                            # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                            # Graph 1 - ENTROPY BY POINTS.

                            plt.plot(dias, entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='ShannonEntropy: Points per hour -> 10 min')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_ShannonEntropy: Each point = 10 min. with Highpass filter', color ="darkgreen", fontsize=18)

                            # Graph 2 - Averaged Shannon Entropy Graph.

                            fig, ax = plt.subplots(1,1)
                            indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                            plt.plot(dias, entropia_promediada[indices_no_cero_promediada], "ob", mfc="b", mec = "b", label='ShannonAveragedEntropy: Points per hour -> 10 min')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Shannon Averaged Entropy: Each point = 10 min. with Highpass filter.', color ="darkgreen", fontsize=18)

                            # Graph 3 - Graph of Shannon Entropy plus the envelope.

                            # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE.

                            fig, ax = plt.subplots(1,1)

                            y_filtered = nanfastsmooth(Y.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                            plt.plot(dias, entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='Shannon Entropy')
                            plt.plot(dias, y_filtered[indices_no_cero_shannon], label='Envelope', color='blue')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Envelope - Shannon Entropy: Each point = 10 min. with Highpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            # Graph 4 - Envelope only graph.

                            fig, ax = plt.subplots(1,1)

                            plt.plot(dias, y_filtered[indices_no_cero_shannon], label='Filtered Signal', color='blue')


                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Only the envelope of Shannon entropy: Each point = 10 min. with Highpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                            # Graph 5 Frequency Index con envolvente
                            fig, ax = plt.subplots(1,1)

                            y_filtered3 = nanfastsmooth(Y2.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                            plt.plot(dias, frequency_index[indices_no_cero_frecuency], 'o-', label='Frequency Index')
                            plt.plot(dias, y_filtered3[indices_no_cero_frecuency], label='Envelope', color='red')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                            plt.title(Nombre3 + ' Frequency Index: Each point = 10 min. with Highpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            # Graph 6 Kurtosis with envelope
                            fig, ax = plt.subplots(1,1)
                            indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]

                            # Dates vector create
                            fecha_inicio = datetime(Anio1, Mes1, Dia2)
                            dias2 = [fecha_inicio + timedelta(minutes=(10*i)) for i in range(len(entropia_shannon[indices_no_cero_kurtosis]))]

                            y_filtered2 = nanfastsmooth(Y1.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                            plt.plot(dias2, kurtosis_resultados[indices_no_cero_kurtosis], 'o', label='Kurtosis')
                            plt.plot(dias2, y_filtered2[indices_no_cero_kurtosis], label='Envelope', color='red')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                            plt.title(Nombre3 + ' Kurtosis: Each point = 10 min. with Highpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            plt.show()

                    else:

                        # Plot the vectors into separate figures.
                        dias = np.arange(1, 8761*6+1)

                        st = (dias, entropia_shannon[indices_no_cero_shannon])

                        np.save(F3, st)  # Save the ".npy" file in the directory.
                        plt.close()

                        # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                        # Graph 1 - ENTROPY BY POINTS.

                        plt.plot(dias[indices_no_cero_shannon], entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='ShannonEntropy: Points per hour -> 10 min')

                        #plt.plot(dias, entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='ShannonEntropy: Points per hour -> 1 hr')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_ShannonEntropy: Each point = 10 min. with Highpass filter', color ="darkgreen", fontsize=18)
                        #plt.grid()

                        # Graph 2 - Averaged Shannon Entropy Graph.

                        fig, ax = plt.subplots(1,1)
                        indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                        plt.plot(dias[indices_no_cero_promediada], entropia_promediada[indices_no_cero_promediada], "ob", mfc="b", mec = "b", label='ShannonAveragedEntropy: Points per hour -> 10 min')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Shannon Averaged Entropy: Each point = 10 min. with Highpass filter.', color ="darkgreen", fontsize=18)


                        # Graph 3 - Graph of Shannon Entropy plus the envelope.

                        # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE.

                        fig, ax = plt.subplots(1,1)

                        y_filtered = nanfastsmooth(Y.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                        plt.plot(dias[indices_no_cero_shannon], entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='Shannon Entropy')
                        plt.plot(dias[indices_no_cero_shannon], y_filtered[indices_no_cero_shannon], label='Envelope', color='blue')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Envelope - Shannon Entropy: Each point = 10 min. with Highpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        # Graph 4 - Envelope only graph.

                        fig, ax = plt.subplots(1,1)

                        plt.plot(dias[indices_no_cero_shannon], y_filtered[indices_no_cero_shannon], label='Filtered Signal', color='blue')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Only the envelope of Shannon entropy: Each point = 10 min. with Highpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                        # Graph 5 Frequency Index con envolvente
                        fig, ax = plt.subplots(1,1)

                        y_filtered3 = nanfastsmooth(Y2.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                        plt.plot(dias[indices_no_cero_frecuency], frequency_index[indices_no_cero_frecuency], 'o-', label='Frequency Index')
                        plt.plot(dias[indices_no_cero_frecuency], y_filtered3[indices_no_cero_frecuency], label='Envelope', color='red')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                        plt.title(Nombre3 + ' Frequency Index: Each point = 10 min. with Highpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        # Graph 6 Kurtosis with envelope
                        fig, ax = plt.subplots(1,1)
                        indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]

                        y_filtered2 = nanfastsmooth(Y1.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                        plt.plot(dias[indices_no_cero_kurtosis], kurtosis_resultados[indices_no_cero_kurtosis], 'o', label='Kurtosis')
                        plt.plot(dias[indices_no_cero_kurtosis], y_filtered2[indices_no_cero_kurtosis], label='Envelope', color='red')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                        plt.title(Nombre3 + ' Kurtosis: Each point = 10 min. with Highpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        plt.show()

        except:                         # In any other case of invalid or empty inputs
                plt.close()                                                 # Close the existing chart.
                msgBox = QMessageBox()
                msgBox.setIcon(QMessageBox.Warning)
                msgBox.setText("The File Does not exist, is Invalid or the CSV old file is open. Please close, try again ...")
                msgBox.setWindowTitle("Invalid Record inputs or CSV Old file is open ")
                returnValue = msgBox.exec()
                pass


    def filtropasabanda10(self):                                               # 7.- Function to execute the Bandpass filter with 10 m. analysis window

        try:

            if self.checkBox.isChecked() == True:           # checkBox for Time interval

                # Verify (Validation), that the text box and label is not empty

                if not self.label_5.text():
                    MensCombo1 = QMessageBox()
                    MensCombo1.setIcon(QMessageBox.Warning)
                    MensCombo1.setWindowTitle("Empty directory to upload records")
                    MensCombo1.setText("Please, enter a valid name of directory")
                    returnValue = MensCombo1.exec()

                elif not self.label_8.text():
                    MensCombo2 = QMessageBox()
                    MensCombo2.setIcon(QMessageBox.Warning)
                    MensCombo2.setWindowTitle("Empty path to store CSV/NPY file")
                    MensCombo2.setText("Please, enter a valid name of directory")
                    returnValue = MensCombo2.exec()

                elif not self.lineEdit_5.text():
                    MensCombo3 = QMessageBox()
                    MensCombo3.setIcon(QMessageBox.Warning)
                    MensCombo3.setWindowTitle("Empty Smoothing type")
                    MensCombo3.setText("Please, enter a valid Value")
                    returnValue = MensCombo3.exec()

                elif not self.lineEdit_7.text():
                    MensCombo4 = QMessageBox()
                    MensCombo4.setIcon(QMessageBox.Warning)
                    MensCombo4.setWindowTitle("Empty Filter Order")
                    MensCombo4.setText("Please, enter a valid Value")
                    returnValue = MensCombo4.exec()

                elif not self.lineEdit_8.text():
                    MensCombo5 = QMessageBox()
                    MensCombo5.setIcon(QMessageBox.Warning)
                    MensCombo5.setWindowTitle("Empty Min. Frequency")
                    MensCombo5.setText("Please, enter a valid Value")
                    returnValue = MensCombo5.exec()

                elif not self.lineEdit_9.text():
                    MensCombo6 = QMessageBox()
                    MensCombo6.setIcon(QMessageBox.Warning)
                    MensCombo6.setWindowTitle("Empty Max. Frequency")
                    MensCombo6.setText("Please, enter a valid Value")
                    returnValue = MensCombo6.exec()

                elif not self.lineEdit_10.text():
                    MensCombo7 = QMessageBox()
                    MensCombo7.setIcon(QMessageBox.Warning)
                    MensCombo7.setWindowTitle("Empty Envelope Window size")
                    MensCombo7.setText("Please, enter a valid Value")
                    returnValue = MensCombo7.exec()

                elif not self.lineEdit_11.text():
                    MensCombo8 = QMessageBox()
                    MensCombo8.setIcon(QMessageBox.Warning)
                    MensCombo8.setWindowTitle("Empty Start time")
                    MensCombo8.setText("Please, enter a valid Value")
                    returnValue = MensCombo8.exec()

                elif not self.lineEdit_12.text():
                    MensCombo9 = QMessageBox()
                    MensCombo9.setIcon(QMessageBox.Warning)
                    MensCombo9.setWindowTitle("Empty End time")
                    MensCombo9.setText("Please, enter a valid Value")
                    returnValue = MensCombo9.exec()

                elif not self.lineEdit_13.text():
                    MensCombo10 = QMessageBox()
                    MensCombo10.setIcon(QMessageBox.Warning)
                    MensCombo10.setWindowTitle("Empty NaN Tolerance")
                    MensCombo10.setText("Please, enter a valid Value")
                    returnValue = MensCombo10.exec()

                else:
                    # Filtering with a Bandpass 10 min.
                    plt.close()                                                 # Close the existing chart.

                    carpeta = (self.label_5.text())                             # Reading the directory or file folder label.

                    # Code to detect the contents of the folder and the files that the folder contains
                    with os.scandir(carpeta) as ficheros:
                        ficheros4 = [fichero.name for fichero in ficheros if fichero.is_file()]

                    # The contents of the files in "ficheros4" is a list. This code converts them to string
                    lfiles = [str(elemento) for elemento in ficheros4]

                    # Code used to determine the name of the files contained in the folder and to be used in the loading loop
                    Iniciolfiles = lfiles[0]                                    # Detects the numeric value of the "Start" in the name
                    Finlfiles = lfiles[-1]                                      # Detects the numerical value of the "End" in the name
                    Indice1 = Iniciolfiles.rfind('.')                           # Determines the index, which will be marked by the dot at the end for the extension
                    Nombre3 = Iniciolfiles[0:Indice1]                           # Indicates the name of the file in str (minus) the index or extension (each day)

                    # Data entry from labels and fields or text boxes (this value is a string by default)
                    #num_temporal_units = (self.lineEdit_5.text())               # label reading of the total number of daily files.
                    frecMin = (self.lineEdit_8.text())                          # Minimum Frequency label reading.
                    frecMax = (self.lineEdit_9.text())                          # Maximum Frequency label reading.
                    orden1 = (self.lineEdit_7.text())                           # Reading the Filter Order Label.
                    Tam = (self.lineEdit_10.text())                             # Reading the envelope window size label.
                    Start1 = (self.lineEdit_11.text())                          # Star Time Size label reading.
                    End1 = (self.lineEdit_12.text())                            # End Time Size label reading.

                    # Convert the string value of the input text boxes to float or integer
                    frec7=float(frecMin)                                        # Converts the Minimum Frequency value to float.
                    frec8=float(frecMax)                                        # Converts the Maximum Frequency value to float.
                    orden7=int(orden1)                                          # Converts filter order value to integer.

                    #timeIn=int(num_temporal_units)                              # Converts the value of the total number of daily files to an integer.

                    # Data entry for enveloped (this value is a string by default)
                    Tam = (self.lineEdit_10.text())                             # Reading the envelope window size label.
                    Tsua = (self.lineEdit_5.text())                             # Reading the Smoothing type label.
                    Tnan = (self.lineEdit_13.text())                            # Reading the NaN Tolerance label.

                    Tam1=int(Tam)                                               # Converts the envelope window size value to integer.
                    Tsua1=int(Tsua)                                             # Converts the Smoothing type value to integer.
                    Tnan1=int(Tnan)                                             # Converts the NaN Tolerance value to integer.

                    timeIn = 365

                    Start2=int(Start1)                                          # Converts the Start time window size value to an integer.
                    End2=int(End1)                                              # Converts the End time window size value to an integer.

                    Diferencia = End2 - Start2                                  # Value of the difference between end and start to obtain the number of days to calculate

                    # *** Functions ***

                    # Function for Shannon entropy calculating
                    def calcular_entropia(datos):
                        params = stats.norm.fit(datos)
                        dist = stats.norm(*params)
                        probabilidades = dist.pdf(datos)
                        entropia = -np.sum(probabilidades * np.log2(probabilidades))
                        return entropia

                    # Function for Kurtosis calculating
                    def calcular_kurtosis(datos):
                        n = len(datos)
                        media = np.mean(datos)
                        varianza = np.var(datos)
                        desviacion_estandar = np.sqrt(varianza)

                        if desviacion_estandar == 0:
                            return 0.0
                        kurtosis = np.sum((datos - media)**4) / (n * desviacion_estandar**4) - 3.0
                        return kurtosis

                    # Function for Shannon entropy enveloped calculating
                    def nanfastsmooth(Y, w, type=1, tol=0.5):

                        """
                        Smooths vector Y with a moving average of width w, ignoring NaNs in data.

                        Parameters:
                        Y (numpy array): Input signal.
                        w (int): Window width.
                        type (int): Smooth type (1 for rectangular, 2 for triangular, 3 for pseudo-Gaussian).
                        tol (float): Tolerance to NaNs between 0 and 1.

                        Returns:
                        numpy array: Smoothed signal.
                        """
                        mask = ~np.isnan(Y)  # Create a boolean mask for non-NaN values
                        Y[mask] = nanfastsmooth_core(Y[mask], w, type, tol)  # Apply smoothing to non-NaN values
                        return Y

                    # Function for Shannon entropy enveloped type calculating. For default the value = 3
                    def nanfastsmooth_core(Y, w, type, tol):
                        if type == 1:
                            SmoothY = moving_average(Y, w)
                        elif type == 2:
                            SmoothY = moving_average(moving_average(Y, w), w)
                        elif type == 3:
                            SmoothY = moving_average(moving_average(moving_average(Y, w), w), w)

                        return SmoothY

                    def moving_average(Y, window_size):
                        return np.convolve(Y, np.ones(window_size)/window_size, mode='same')

                    def calcular_indice_frecuencias(datos, frecuencia_muestreo):
                        # Aplicar filtro en frecuencia
                        freq_bajas = (1, 5.5)
                        freq_altas = (6, 16)

                        datos_bajas = apply_bandpass_filter(datos, frecuencia_muestreo, freq_bajas)
                        datos_altas = apply_bandpass_filter(datos, frecuencia_muestreo, freq_altas)

                        # Calcular energía para cada señal
                        energia_bajas = np.sum(datos_bajas ** 2)
                        energia_altas = np.sum(datos_altas ** 2)

                        # Calcular índice de frecuencias
                        indice_frecuencias = np.log(energia_altas / energia_bajas) if energia_bajas != 0 else np.nan
                        return indice_frecuencias

                    def apply_bandpass_filter(datos, frecuencia_muestreo, freq_band):
                        nyquist = 0.5 * frecuencia_muestreo
                        normal_freq_band = np.array(freq_band) / nyquist
                        b, a = signal.butter(4, normal_freq_band, btype='band')
                        datos_filtrados = signal.filtfilt(b, a, datos)
                        return datos_filtrados

                    # Start entropy and averaged entropy values
                    entropia_shannon = []
                    entropia_promediada = []
                    kurtosis_resultados = []
                    frequency_index = []

                    # Cycle for the day-by-day calculation of the entropy in the files contained in the folder, using the time range (Start to End)
                    for dia in range(Start2, End2 + 1):

                        archivo = Nombre3 + '.'+ f"{dia:003}"       # Here you select the name previously calculated plus point and the value of each Julian day

                        # If there is no file in the list, the entire day is added with a value of zero
                        if not os.path.exists(os.path.join(carpeta, archivo)):
                            for _ in range(24*6):  # Adds 24 hours with zero value if there is no file
                                entropia_shannon.append(0)
                                entropia_promediada.append(0)
                                kurtosis_resultados.append(0)
                                frequency_index.append(0)
                            continue

                        # Designation of the data contained in the folder files
                        st = Stream()
                        st += read(os.path.join(carpeta, archivo))
                        frecuencia_muestreo = st[0].stats.sampling_rate
                        # calculation of the Bandpass filter with the parameters indicated by the user.
                        st.filter('bandpass', freqmin=frec7, freqmax=frec8, corners=orden7, zerophase=True)
                        # Data value
                        datos = st[0].data

                        # Divide the data into hours and calculate entropy for each hour.
                        for hora in range(24*6):
                            inicio = hora * 600 * 100  # start of time in seconds.
                            fin = inicio + 600 * 100  # End of time in seconds.
                            datos_hora = datos[inicio:fin]

                            if len(datos_hora) < 600 * 100:  # If the hour is incomplete, add zeros to the end.
                                datos_hora = np.append(datos_hora, np.zeros(600 * 100 - len(datos_hora)))

                            # Accumulator of the calculated values of the Shannon entropy and the averaged entropy.
                            entropia_shannon.append(calcular_entropia(datos_hora))
                            entropia_promediada.append(calcular_entropia(datos_hora) / len(datos_hora))
                            kurtosis_resultados.append(calcular_kurtosis(datos_hora))
                            frequency_index.append(calcular_indice_frecuencias(datos_hora, frecuencia_muestreo))

                    # Converting shannon entropy value and averaged entropy to data array.
                    entropia_shannon = np.array(entropia_shannon)
                    entropia_promediada = np.array(entropia_promediada)
                    kurtosis_resultados = np.array(kurtosis_resultados)
                    frequency_index=np.array(frequency_index)

                    # Shannon Entropy Graph. Value of non-zero indices where there is no data.
                    indices_no_cero_shannon = np.where(entropia_shannon != 0)[0]

                    indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                    indices_no_cero_frecuency = np.where(frequency_index != 0)[0]

                    indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]

                    # **** SAVE THE RESULTS FILE .CSV
                    archivoFil2 = (self.label_8.text())                         # Reading directory label.

                    # **** SAVE THE RESULTS .npy FILE FOR LATER GRAPH *****
                    TW = str(Tam1)                                              # Convert Envelope Window value to string for names.
                    F1 = (Nombre3 + '_Bandpass_Filter_10m ' + '_Windows=' + TW + '.csv')            # Assign F1, Capture the name of the record and add the .csv extension.

                    # Guardar resultados en archivos .npy
                    F1a = (Nombre3 + '_Bandpass_Filter_10m' + '_Windows=' + TW)
                    F2 = (archivoFil2 + F1)                                     # Assigns to F2 the directory plus the previous name where the record will be stored.
                    F3 = (archivoFil2 + F1a)

                    with open(F2, 'w+', newline='') as archivo_csv:             # Each result is saved in the file, day, time and values of Shannon's entropy and averaged.
                        writer = csv.writer(archivo_csv)
                        writer.writerow(['Day', ' hour', ' Shannon Entropy', ' Averaged Shannon Entropy', ' Envelope Shannon Entropy', ' Kurtosis', ' Frequency Index'])

                        for dia in range(1, Diferencia + 1):                        # Save data by day and time according to the time interval (Start - End)
                            for hora in range(24*6):
                                writer.writerow([dia, hora, entropia_shannon[(dia - 1) * 24*6 + hora], entropia_promediada[(dia - 1) * 24*6 + hora], kurtosis_resultados[(dia - 1) * 24*6 + hora], frequency_index[(dia - 1) * 24*6 + hora] ])

                    # Use example
                    Y = entropia_shannon
                    Y = np.where(Y == 0, np.nan, Y)

                    Y1 = kurtosis_resultados
                    Y1 = np.where(Y1 == 0, np.nan, Y1)

                    Y2 = frequency_index
                    Y2 = np.where(Y2 == 0, np.nan, Y2)

                    if self.checkBox_2.isChecked():                                 # checkBox for Initial Time

                        if not self.lineEdit_14.text():
                            MensCombo14 = QMessageBox()
                            MensCombo14.setIcon(QMessageBox.Warning)
                            MensCombo14.setWindowTitle("Empty Year value")
                            MensCombo14.setText("Please, enter a valid value")
                            returnValue = MensCombo14.exec()

                        elif not self.lineEdit_15.text():
                            MensCombo15 = QMessageBox()
                            MensCombo15.setIcon(QMessageBox.Warning)
                            MensCombo15.setWindowTitle("Empty Month value")
                            MensCombo15.setText("Please, enter a valid value")
                            returnValue = MensCombo15.exec()

                        elif not self.lineEdit_16.text():
                            MensCombo16 = QMessageBox()
                            MensCombo16.setIcon(QMessageBox.Warning)
                            MensCombo16.setWindowTitle("Empty Day value")
                            MensCombo16.setText("Please, enter a valid value")
                            returnValue = MensCombo16.exec()

                        else:

                            # Data entry for enveloped (this value is a string by default)
                            Anio = (self.lineEdit_14.text())                            # Reading the Year value label.
                            Mes = (self.lineEdit_15.text())                             # Reading the Month value label.
                            Dia1 = (self.lineEdit_16.text())                            # Reading the Day value label.

                            # Convert the string value of the input text boxes to  integer

                            Anio1=int(Anio)                                             # Converts the Year value to integer.
                            Mes1=int(Mes)                                               # Converts the Month value to integer.
                            Dia2=int(Dia1)                                              # Converts the NaN Day value to integer.

                            # Dates vector create
                            fecha_inicio = datetime(Anio1, Mes1, Dia2)
                            dias = [fecha_inicio + timedelta(minutes=(10*i)) for i in range(len(entropia_shannon[indices_no_cero_shannon]))]

                            st = (dias, entropia_shannon[indices_no_cero_shannon])

                            # Save the ".npy" file in the directory.
                            np.save(F3, st)
                            plt.close()                                             # Close the existing chart.

                            # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                            # Graph 1 - ENTROPY BY POINTS.

                            plt.plot(dias, entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='ShannonEntropy: Points per hour -> 10 min')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_ShannonEntropy: Each point = 10 min. with Bandpass filter', color ="darkgreen", fontsize=18)

                            print('Aqui estoy en intervalo de tiempo Star-End')

                            # Graph 2 - Averaged Shannon Entropy Graph.

                            fig, ax = plt.subplots(1,1)
                            indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                            plt.plot(dias, entropia_promediada[indices_no_cero_promediada], "ob", mfc="b", mec = "b", label='ShannonAveragedEntropy: Points per hour -> 10 min')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Shannon Averaged Entropy: Each point = 10 min. with Bandpass filter.', color ="darkgreen", fontsize=18)

                            # Graph 3 - Graph of Shannon Entropy plus the envelope.

                            # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE.

                            fig, ax = plt.subplots(1,1)

                            y_filtered = nanfastsmooth(Y.copy(), Tam1, Tsua1, Tnan1)  # Make a "Y" copy to avoid modifying the original

                            plt.plot(dias, entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='Shannon Entropy')
                            plt.plot(dias, y_filtered[indices_no_cero_shannon], label='Envelope', color='blue')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Envelope - Shannon Entropy: Each point = 10 min. with Bandpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            # Graph 4 - Envelope only graph.

                            fig, ax = plt.subplots(1,1)

                            plt.plot(dias, y_filtered[indices_no_cero_shannon], label='Filtered Signal', color='blue')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Only the envelope of Shannon entropy: Each point = 10 min. with Bandpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                            # Graph 5 Frequency Index con envolvente
                            fig, ax = plt.subplots(1,1)

                            y_filtered3 = nanfastsmooth(Y2.copy(), Tam1, Tsua1, Tnan1)  # Make a "Y" copy to avoid modifying the original

                            plt.plot(dias, frequency_index[indices_no_cero_frecuency], 'o-', label='Frequency Index')
                            plt.plot(dias, y_filtered3[indices_no_cero_frecuency], label='Envelope', color='red')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                            plt.title(Nombre3 + ' Frequency Index: Each point = 10 min. with Bandpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            # Graph 6 Kurtosis with envelope
                            fig, ax = plt.subplots(1,1)
                            indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]

                            # Dates vector create
                            fecha_inicio = datetime(Anio1, Mes1, Dia2)
                            dias2 = [fecha_inicio + timedelta(minutes=(10*i)) for i in range(len(entropia_shannon[indices_no_cero_kurtosis]))]

                            y_filtered2 = nanfastsmooth(Y1.copy(), Tam1, Tsua1, Tnan1)  # Make a "Y" copy to avoid modifying the original

                            plt.plot(dias2, kurtosis_resultados[indices_no_cero_kurtosis], 'o', label='Kurtosis')
                            plt.plot(dias2, y_filtered2[indices_no_cero_kurtosis], label='Envelope', color='red')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                            plt.title(Nombre3 + ' Kurtosis: Each point = 10 min. with Bandpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            plt.show()

                    else:

                        # Plot the vectors into separate figures.
                        dias = np.arange(1, 8761*6+1)

                        st = (dias, entropia_shannon[indices_no_cero_shannon])

                        np.save(F3, st)  # Save the ".npy" file in the directory.
                        plt.close()

                        # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                        # Graph 1 - ENTROPY BY POINTS.

                        plt.plot(dias[indices_no_cero_shannon], entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='ShannonEntropy: Points per hour -> 10 min')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_ShannonEntropy: Each point = 10 min. with Bandpass filter', color ="darkgreen", fontsize=18)

                        # Graph 2 - Averaged Shannon Entropy Graph.

                        fig, ax = plt.subplots(1,1)
                        indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                        plt.plot(dias[indices_no_cero_promediada], entropia_promediada[indices_no_cero_promediada], "ob", mfc="b", mec = "b", label='ShannonAveragedEntropy: Points per hour -> 10 min')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Shannon Averaged Entropy: Each point = 10 min. with Bandpass filter.', color ="darkgreen", fontsize=18)


                        # Graph 3 - Graph of Shannon Entropy plus the envelope.

                        # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE.

                        fig, ax = plt.subplots(1,1)

                        y_filtered = nanfastsmooth(Y.copy(), Tam1, Tsua1, Tnan1)  # Make a "Y" copy to avoid modifying the original

                        plt.plot(dias[indices_no_cero_shannon], entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='Shannon Entropy')
                        plt.plot(dias[indices_no_cero_shannon], y_filtered[indices_no_cero_shannon], label='Envelope', color='blue')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Envelope - Shannon Entropy: Each point = 10 min. with Bandpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        # Graph 4 - Envelope only graph.

                        fig, ax = plt.subplots(1,1)

                        plt.plot(dias[indices_no_cero_shannon], y_filtered[indices_no_cero_shannon], label='Filtered Signal', color='blue')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Only the envelope of Shannon entropy: Each point = 10 min. with Bandpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                        # Graph 5 Frequency Index con envolvente
                        fig, ax = plt.subplots(1,1)

                        y_filtered3 = nanfastsmooth(Y2.copy(), Tam1, Tsua1, Tnan1)  # Make a "Y" copy to avoid modifying the original

                        plt.plot(dias[indices_no_cero_frecuency], frequency_index[indices_no_cero_frecuency], 'o-', label='Frequency Index')
                        plt.plot(dias[indices_no_cero_frecuency], y_filtered3[indices_no_cero_frecuency], label='Envelope', color='red')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                        plt.title(Nombre3 + ' Frequency Index: Each point = 10 min. with Bandpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        # Graph 6 Kurtosis with envelope
                        fig, ax = plt.subplots(1,1)
                        indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]

                        y_filtered2 = nanfastsmooth(Y1.copy(), Tam1, Tsua1, Tnan1)  # Make a "Y" copy to avoid modifying the original

                        plt.plot(dias[indices_no_cero_kurtosis], kurtosis_resultados[indices_no_cero_kurtosis], 'o', label='Kurtosis')
                        plt.plot(dias[indices_no_cero_kurtosis], y_filtered2[indices_no_cero_kurtosis], label='Envelope', color='red')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                        plt.title(Nombre3 + ' Kurtosis: Each point = 10 min. with Bandpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        plt.show()

            else:                                           # Here the value of the entropy is calculated without the time interval (Start - End)

                if not self.lineEdit_5.text():
                    MensCombo1 = QMessageBox()
                    MensCombo1.setIcon(QMessageBox.Warning)
                    MensCombo1.setWindowTitle("Empty Smoothing type")
                    MensCombo1.setText("Please, enter a valid Value")
                    returnValue = MensCombo1.exec()

                elif not self.lineEdit_7.text():
                    MensCombo2 = QMessageBox()
                    MensCombo2.setIcon(QMessageBox.Warning)
                    MensCombo2.setWindowTitle("Empty Filter Order")
                    MensCombo2.setText("Please, enter a valid Value")
                    returnValue = MensCombo2.exec()

                elif not self.lineEdit_8.text():
                    MensCombo3 = QMessageBox()
                    MensCombo3.setIcon(QMessageBox.Warning)
                    MensCombo3.setWindowTitle("Empty Min. Frequency")
                    MensCombo3.setText("Please, enter a valid Value")
                    returnValue = MensCombo3.exec()

                elif not self.lineEdit_9.text():
                    MensCombo4 = QMessageBox()
                    MensCombo4.setIcon(QMessageBox.Warning)
                    MensCombo4.setWindowTitle("Empty Max. Frequency")
                    MensCombo4.setText("Please, enter a valid Value")
                    returnValue = MensCombo4.exec()

                elif not self.lineEdit_10.text():
                    MensCombo5 = QMessageBox()
                    MensCombo5.setIcon(QMessageBox.Warning)
                    MensCombo5.setWindowTitle("Empty Envelope Window size")
                    MensCombo5.setText("Please, enter a valid Value")
                    returnValue = MensCombo5.exec()

                elif not self.lineEdit_13.text():
                    MensCombo6 = QMessageBox()
                    MensCombo6.setIcon(QMessageBox.Warning)
                    MensCombo6.setWindowTitle("Empty NaN Tolerance")
                    MensCombo6.setText("Please, enter a valid Value")
                    returnValue = MensCombo6.exec()

                elif not self.label_5.text():
                    MensCombo7 = QMessageBox()
                    MensCombo7.setIcon(QMessageBox.Warning)
                    MensCombo7.setWindowTitle("Empty directory to upload records")
                    MensCombo7.setText("Please, enter a valid name of directory")
                    returnValue = MensCombo7.exec()

                elif not self.label_8.text():
                    MensCombo8 = QMessageBox()
                    MensCombo8.setIcon(QMessageBox.Warning)
                    MensCombo8.setWindowTitle("Empty path to store CSV/NPY file")
                    MensCombo8.setText("Please, enter a valid name of directory")
                    returnValue = MensCombo8.exec()

                else:
                    # Filtering with a Bandpass 10 min.
                    plt.close()                                                 # Close the existing chart.

                    carpeta = (self.label_5.text())                             # Reading the directory or file folder label.

                    # Code to detect the contents of the folder and the files that the folder contains
                    with os.scandir(carpeta) as ficheros:
                        ficheros4 = [fichero.name for fichero in ficheros if fichero.is_file()]

                    # The contents of the files in "ficheros4" is a list. This code converts them to string
                    lfiles = [str(elemento) for elemento in ficheros4]

                    # Code used to determine the name of the files contained in the folder and to be used in the loading loop
                    Iniciolfiles = lfiles[0]                                    # Detects the numeric value of the "Start" in the name
                    Finlfiles = lfiles[-1]                                      # Detects the numerical value of the "End" in the name
                    Indice1 = Iniciolfiles.rfind('.')                           # Determines the index, which will be marked by the dot at the end for the extension
                    Nombre3 = Iniciolfiles[0:Indice1]                           # Indicates the name of the file in str (minus) the index or extension (each day)

                    # Data entry from labels and fields or text boxes (this value is a string by default)

                    frecMin = (self.lineEdit_8.text())                          # Minimum Frequency label reading.
                    frecMax = (self.lineEdit_9.text())                          # Maximum Frequency label reading.
                    orden1 = (self.lineEdit_7.text())                           # Reading the Filter Order Label.

                    # Data entry for enveloped (this value is a string by default)
                    Tam = (self.lineEdit_10.text())                             # Reading the envelope window size label.
                    Tsua = (self.lineEdit_5.text())                             # Reading the Smoothing type label.
                    Tnan = (self.lineEdit_13.text())                            # Reading the NaN Tolerance label.

                    # Convert the string value of the input text boxes to float or integer
                    frec7=float(frecMin)                                        # Converts the Minimum Frequency value to float.
                    frec8=float(frecMax)                                        # Converts the Maximum Frequency value to float.
                    orden7=int(orden1)                                          # Converts filter order value to integer.
                    #timeIn=int(num_temporal_units)                              # Converts the value of the total number of daily files to an integer.

                    Tam1=int(Tam)                                               # Converts the envelope window size value to integer.
                    Tsua1=int(Tsua)                                             # Converts the Smoothing type value to integer.
                    Tnan1=int(Tnan)                                             # Converts the NaN Tolerance value to integer.

                    timeIn = 365

                    # *** Functions ***

                    # Function for Shannon entropy calculating
                    def calcular_entropia(datos):
                        params = stats.norm.fit(datos)
                        dist = stats.norm(*params)
                        probabilidades = dist.pdf(datos)
                        entropia = -np.sum(probabilidades * np.log2(probabilidades))
                        return entropia

                    # Function for Kurtosis calculating
                    def calcular_kurtosis(datos):
                        n = len(datos)
                        media = np.mean(datos)
                        varianza = np.var(datos)
                        desviacion_estandar = np.sqrt(varianza)

                        if desviacion_estandar == 0:
                            return 0.0
                        kurtosis = np.sum((datos - media)**4) / (n * desviacion_estandar**4) - 3.0
                        return kurtosis

                    # Function for Shannon entropy enveloped calculating
                    def nanfastsmooth(Y, w, type=1, tol=0.5):

                        """
                        Smooths vector Y with a moving average of width w, ignoring NaNs in data.

                        Parameters:
                        Y (numpy array): Input signal.
                        w (int): Window width.
                        type (int): Smooth type (1 for rectangular, 2 for triangular, 3 for pseudo-Gaussian).
                        tol (float): Tolerance to NaNs between 0 and 1.

                        Returns:
                        numpy array: Smoothed signal.
                        """
                        mask = ~np.isnan(Y)  # Create a boolean mask for non-NaN values
                        Y[mask] = nanfastsmooth_core(Y[mask], w, type, tol)  # Apply smoothing to non-NaN values
                        return Y

                    # Function for Shannon entropy enveloped type calculating. For default the value = 3
                    def nanfastsmooth_core(Y, w, type, tol):
                        if type == 1:
                            SmoothY = moving_average(Y, w)
                        elif type == 2:
                            SmoothY = moving_average(moving_average(Y, w), w)
                        elif type == 3:
                            SmoothY = moving_average(moving_average(moving_average(Y, w), w), w)

                        return SmoothY

                    def moving_average(Y, window_size):
                        return np.convolve(Y, np.ones(window_size)/window_size, mode='same')

                    def calcular_indice_frecuencias(datos, frecuencia_muestreo):
                        # Aplicar filtro en frecuencia
                        freq_bajas = (1, 5.5)
                        freq_altas = (6, 16)

                        datos_bajas = apply_bandpass_filter(datos, frecuencia_muestreo, freq_bajas)
                        datos_altas = apply_bandpass_filter(datos, frecuencia_muestreo, freq_altas)

                        # Calcular energía para cada señal
                        energia_bajas = np.sum(datos_bajas ** 2)
                        energia_altas = np.sum(datos_altas ** 2)

                        # Calcular índice de frecuencias
                        indice_frecuencias = np.log(energia_altas / energia_bajas) if energia_bajas != 0 else np.nan
                        return indice_frecuencias

                    def apply_bandpass_filter(datos, frecuencia_muestreo, freq_band):
                        nyquist = 0.5 * frecuencia_muestreo
                        normal_freq_band = np.array(freq_band) / nyquist
                        b, a = signal.butter(4, normal_freq_band, btype='band')
                        datos_filtrados = signal.filtfilt(b, a, datos)
                        return datos_filtrados

                    # Start entropy and averaged entropy values
                    entropia_shannon = []
                    entropia_promediada = []
                    kurtosis_resultados = []
                    frequency_index = []

                    # Cycle for the day-by-day calculation of the entropy in the files contained in the folder, using the time range (Start to End)
                    for dia in range(1, timeIn + 1):

                        archivo = Nombre3 + '.'+ f"{dia:003}"       # Here you select the name previously calculated plus point and the value of each Julian day

                        # If there is no file in the list, the entire day is added with a value of zero
                        if not os.path.exists(os.path.join(carpeta, archivo)):
                            for _ in range(24*6):  # Adds 24 hours with zero value if there is no file
                                entropia_shannon.append(0)
                                entropia_promediada.append(0)
                                kurtosis_resultados.append(0)
                                frequency_index.append(0)
                            continue

                        # Designation of the data contained in the folder files
                        st = Stream()
                        st += read(os.path.join(carpeta, archivo))
                        frecuencia_muestreo = st[0].stats.sampling_rate
                        # calculation of the Bandpass filter with the parameters indicated by the user.
                        st.filter('bandpass', freqmin=frec7, freqmax=frec8, corners=orden7, zerophase=True)
                        # Data value
                        datos = st[0].data

                        # Divide the data into hours and calculate entropy for each hour.
                        for hora in range(24*6):
                            inicio = hora * 600 * 100  # start of time in seconds.
                            fin = inicio + 600 * 100  # End of time in seconds.
                            datos_hora = datos[inicio:fin]

                            if len(datos_hora) < 600 * 100:  # If the hour is incomplete, add zeros to the end.
                                datos_hora = np.append(datos_hora, np.zeros(600 * 100 - len(datos_hora)))

                            # Accumulator of the calculated values of the Shannon entropy and the averaged entropy.
                            entropia_shannon.append(calcular_entropia(datos_hora))
                            entropia_promediada.append(calcular_entropia(datos_hora) / len(datos_hora))
                            kurtosis_resultados.append(calcular_kurtosis(datos_hora))
                            frequency_index.append(calcular_indice_frecuencias(datos_hora, frecuencia_muestreo))

                    # Converting shannon entropy value and averaged entropy to data array.
                    entropia_shannon = np.array(entropia_shannon)
                    entropia_promediada = np.array(entropia_promediada)
                    kurtosis_resultados = np.array(kurtosis_resultados)
                    frequency_index=np.array(frequency_index)

                    # Shannon Entropy Graph. Value of non-zero indices where there is no data.
                    indices_no_cero_shannon = np.where(entropia_shannon != 0)[0]

                    indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                    indices_no_cero_frecuency = np.where(frequency_index != 0)[0]

                    indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]


                    archivoFil2 = (self.label_8.text())                         # Reading directory label.

                    # **** SAVE THE RESULTS  .CSV and .NPY FILE FOR LATER GRAPH *****
                    TW = str(Tam1)                                              # Convert Envelope Window value to string for names.
                    F1 = (Nombre3 + '_Bandpass_Filter_10m ' + '_Windows=' + TW + '.csv')            # Assign F1, Capture the name of the record and add the .csv extension.

                    F1a = (Nombre3 + '_Bandpass_Filter_10m' + '_Windows=' + TW)
                    F2 = (archivoFil2 + F1)                                     # Assigns to F2 the directory plus the previous name where the record will be stored.
                    F3 = (archivoFil2 + F1a)


                    # **** SAVE THE RESULTS FILE .CSV ***
                    with open(F2, 'w+', newline='') as archivo_csv:             # Each result is saved in the file, day, time and values of Shannon's entropy and averaged.
                        writer = csv.writer(archivo_csv)
                        writer.writerow(['Day', ' hour', ' Shannon Entropy', ' Averaged Shannon Entropy', ' Envelope Shannon Entropy', ' Kurtosis', ' Frequency Index'])

                        for dia in range(1, timeIn + 1):                        # Save data by day and time according to the time interval (Start - End)
                            for hora in range(24*6):
                                writer.writerow([dia, hora, entropia_shannon[(dia - 1) * 24*6 + hora], entropia_promediada[(dia - 1) * 24*6 + hora], kurtosis_resultados[(dia - 1) * 24*6 + hora], frequency_index[(dia - 1) * 24*6 + hora] ])

                    # Use example
                    Y = entropia_shannon
                    Y = np.where(Y == 0, np.nan, Y)

                    Y1 = kurtosis_resultados
                    Y1 = np.where(Y1 == 0, np.nan, Y1)

                    Y2 = frequency_index
                    Y2 = np.where(Y2 == 0, np.nan, Y2)


                    if self.checkBox_2.isChecked():                                     # checkBox for Initial Time

                        if not self.lineEdit_14.text():
                            MensCombo9 = QMessageBox()
                            MensCombo9.setIcon(QMessageBox.Warning)
                            MensCombo9.setWindowTitle("Empty Year value")
                            MensCombo9.setText("Please, enter a valid Value")
                            returnValue = MensCombo9.exec()

                        elif not self.lineEdit_15.text():
                            MensCombo10 = QMessageBox()
                            MensCombo10.setIcon(QMessageBox.Warning)
                            MensCombo10.setWindowTitle("Empty Month value")
                            MensCombo10.setText("Please, enter a valid Value")
                            returnValue = MensCombo10.exec()

                        elif not self.lineEdit_14.text():
                            MensCombo11 = QMessageBox()
                            MensCombo11.setIcon(QMessageBox.Warning)
                            MensCombo11.setWindowTitle("Empty Day value")
                            MensCombo11.setText("Please, enter a valid Value")
                            returnValue = MensCombo11.exec()

                        else:

                            # Data entry for enveloped (this value is a string by default)
                            Anio = (self.lineEdit_14.text())                            # Reading the Year value label.
                            Mes = (self.lineEdit_15.text())                             # Reading the Month value label.
                            Dia1 = (self.lineEdit_16.text())                            # Reading the Day value label.

                            # Convert the string value of the input text boxes to  integer

                            Anio1=int(Anio)                                             # Converts the Year value to integer.
                            Mes1=int(Mes)                                               # Converts the Month value to integer.
                            Dia2=int(Dia1)                                              # Converts the NaN Day value to integer.

                            # Dates vector create
                            fecha_inicio = datetime(Anio1, Mes1, Dia2)
                            dias = [fecha_inicio + timedelta(minutes=(6*i)) for i in range(len(entropia_shannon[indices_no_cero_shannon]))]

                            st = (dias, entropia_shannon[indices_no_cero_shannon])

                            # Save the ".npy" file in the directory.
                            np.save(F3, st)
                            plt.close()                                             # Close the existing chart.

                            # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                            print('Aqui estamos en 10 minutos con fecha')

                            # Graph 1 - ENTROPY BY POINTS.

                            plt.plot(dias, entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='ShannonEntropy: Points per hour -> 10 min')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_ShannonEntropy: Each point = 10 min. with Bandpass filter', color ="darkgreen", fontsize=18)
                            #plt.grid()
                            plt.show()

                            # Graph 2 - Averaged Shannon Entropy Graph.

                            fig, ax = plt.subplots(1,1)
                            indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                            plt.plot(dias, entropia_promediada[indices_no_cero_promediada], "ob", mfc="b", mec = "b", label='ShannonAveragedEntropy: Points per hour -> 10 min')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Shannon Averaged Entropy: Each point = 10 min. with Bandpass filter.', color ="darkgreen", fontsize=18)

                            # Graph 3 - Graph of Shannon Entropy plus the envelope.

                            # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE.

                            fig, ax = plt.subplots(1,1)

                            y_filtered = nanfastsmooth(Y.copy(), Tam1, Tsua1, Tnan1)  # Make a "Y" copy to avoid modifying the original

                            plt.plot(dias, entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='Shannon Entropy')
                            plt.plot(dias, y_filtered[indices_no_cero_shannon], label='Envelope', color='blue')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Envelope - Shannon Entropy: Each point = 10 min. with Bandpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            # Graph 4 - Envelope only graph.

                            fig, ax = plt.subplots(1,1)

                            plt.plot(dias, y_filtered[indices_no_cero_shannon], label='Filtered Signal', color='blue')


                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Only the envelope of Shannon entropy: Each point = 10 min. with Bandpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                            # Graph 5 Frequency Index con envolvente
                            fig, ax = plt.subplots(1,1)

                            y_filtered3 = nanfastsmooth(Y2.copy(), Tam1, Tsua1, Tnan1)  # Make a "Y" copy to avoid modifying the original

                            plt.plot(dias, frequency_index[indices_no_cero_frecuency], 'o-', label='Frequency Index')
                            plt.plot(dias, y_filtered3[indices_no_cero_frecuency], label='Envelope', color='red')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                            plt.title(Nombre3 + ' Frequency Index: Each point = 10 min. with Bandpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            # Graph 6 Kurtosis with envelope
                            fig, ax = plt.subplots(1,1)
                            indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]

                            # Dates vector create
                            fecha_inicio = datetime(Anio1, Mes1, Dia2)
                            dias2 = [fecha_inicio + timedelta(minutes=(10*i)) for i in range(len(entropia_shannon[indices_no_cero_kurtosis]))]

                            y_filtered2 = nanfastsmooth(Y1.copy(), Tam1, Tsua1, Tnan1)  # Make a "Y" copy to avoid modifying the original

                            plt.plot(dias2, kurtosis_resultados[indices_no_cero_kurtosis], 'o', label='Kurtosis')
                            plt.plot(dias2, y_filtered2[indices_no_cero_kurtosis], label='Envelope', color='red')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                            plt.title(Nombre3 + ' Kurtosis: Each point = 10 min. with Bandpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            plt.show()
                    else:

                        # Plot the vectors into separate figures.
                        dias = np.arange(1, 8761*6+1)

                        st = (dias, entropia_shannon[indices_no_cero_shannon])

                        np.save(F3, st)  # Save the ".npy" file in the directory.
                        plt.close()

                        # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                        # Graph 1 - ENTROPY BY POINTS.

                        plt.plot(dias[indices_no_cero_shannon], entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='ShannonEntropy: Points per hour -> 1 hr')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_ShannonEntropy: Each point = 10 min. with Bandpass filter', color ="darkgreen", fontsize=18)

                        # Graph 2 - Averaged Shannon Entropy Graph.

                        fig, ax = plt.subplots(1,1)
                        indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                        plt.plot(dias[indices_no_cero_promediada], entropia_promediada[indices_no_cero_promediada], "ob", mfc="b", mec = "b", label='ShannonAveragedEntropy: Points per hour -> 10 min')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Shannon Averaged Entropy: Each point = 10 min. with Bandpass filter.', color ="darkgreen", fontsize=18)

                        # Graph 3 - Graph of Shannon Entropy plus the envelope.

                        # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE.

                        fig, ax = plt.subplots(1,1)

                        y_filtered = nanfastsmooth(Y.copy(), Tam1, Tsua1, Tnan1)  # Make a "Y" copy to avoid modifying the original

                        plt.plot(dias[indices_no_cero_shannon], entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='Shannon Entropy')
                        plt.plot(dias[indices_no_cero_shannon], y_filtered[indices_no_cero_shannon], label='Filtered Signal', color='blue')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Envelope - Shannon Entropy: Each point = 10 min. with Bandpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        # Graph 4 - Envelope only graph.

                        fig, ax = plt.subplots(1,1)

                        plt.plot(dias[indices_no_cero_shannon], y_filtered[indices_no_cero_shannon], label='Filtered Signal', color='blue')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Only the envelope of Shannon entropy: Each point = 10 min. with Bandpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                        # Graph 5 Frequency Index con envolvente
                        fig, ax = plt.subplots(1,1)

                        y_filtered3 = nanfastsmooth(Y2.copy(), Tam1, Tsua1, Tnan1)  # Make a "Y" copy to avoid modifying the original

                        plt.plot(dias[indices_no_cero_frecuency], frequency_index[indices_no_cero_frecuency], 'o-', label='Frequency Index')
                        plt.plot(dias[indices_no_cero_frecuency], y_filtered3[indices_no_cero_frecuency], label='Envelope', color='red')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                        plt.title(Nombre3 + ' Frequency Index: Each point = 10 min. with Bandpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        # Graph 6 Kurtosis with envelope
                        fig, ax = plt.subplots(1,1)
                        indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]

                        y_filtered2 = nanfastsmooth(Y1.copy(), Tam1, Tsua1, Tnan1)  # Make a "Y" copy to avoid modifying the original

                        plt.plot(dias[indices_no_cero_kurtosis], kurtosis_resultados[indices_no_cero_kurtosis], 'o', label='Kurtosis')
                        plt.plot(dias[indices_no_cero_kurtosis], y_filtered2[indices_no_cero_kurtosis], label='Envelope', color='red')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                        plt.title(Nombre3 + ' Kurtosis: Each point = 10 min. with Bandpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        plt.show()



        except:
                plt.close()                                                 # Close the existing chart.
                msgBox = QMessageBox()
                msgBox.setIcon(QMessageBox.Warning)
                msgBox.setText("The File Does not exist, is Invalid or the CSV old file is open. Please close, try again ...")
                msgBox.setWindowTitle("Invalid Record or CSV Old file is open ")
                returnValue = msgBox.exec()
                pass


    def filtrobandstop10(self):                                               # 8.- Function to execute the Bandstop filter with 10 m. analysis window.

        try:

            if self.checkBox.isChecked() == True:           # checkBox for Time interval

                # Verify (Validation), that the text box and label is not empty

                if not self.label_5.text():
                    MensCombo1 = QMessageBox()
                    MensCombo1.setIcon(QMessageBox.Warning)
                    MensCombo1.setWindowTitle("Empty directory to upload records")
                    MensCombo1.setText("Please, enter a valid name of directory")
                    returnValue = MensCombo1.exec()

                elif not self.label_8.text():
                    MensCombo2 = QMessageBox()
                    MensCombo2.setIcon(QMessageBox.Warning)
                    MensCombo2.setWindowTitle("Empty path to store CSV/NPY file")
                    MensCombo2.setText("Please, enter a valid name of directory")
                    returnValue = MensCombo2.exec()

                elif not self.lineEdit_5.text():
                    MensCombo3 = QMessageBox()
                    MensCombo3.setIcon(QMessageBox.Warning)
                    MensCombo3.setWindowTitle("Empty Smoothing type")
                    MensCombo3.setText("Please, enter a valid Value")
                    returnValue = MensCombo3.exec()

                elif not self.lineEdit_7.text():
                    MensCombo4 = QMessageBox()
                    MensCombo4.setIcon(QMessageBox.Warning)
                    MensCombo4.setWindowTitle("Empty Filter Order")
                    MensCombo4.setText("Please, enter a valid Value")
                    returnValue = MensCombo4.exec()

                elif not self.lineEdit_8.text():
                    MensCombo5 = QMessageBox()
                    MensCombo5.setIcon(QMessageBox.Warning)
                    MensCombo5.setWindowTitle("Empty Min. Frequency")
                    MensCombo5.setText("Please, enter a valid Value")
                    returnValue = MensCombo5.exec()

                elif not self.lineEdit_9.text():
                    MensCombo6 = QMessageBox()
                    MensCombo6.setIcon(QMessageBox.Warning)
                    MensCombo6.setWindowTitle("Empty Max. Frequency")
                    MensCombo6.setText("Please, enter a valid Value")
                    returnValue = MensCombo6.exec()

                elif not self.lineEdit_10.text():
                    MensCombo7 = QMessageBox()
                    MensCombo7.setIcon(QMessageBox.Warning)
                    MensCombo7.setWindowTitle("Empty Envelope Window size")
                    MensCombo7.setText("Please, enter a valid Value")
                    returnValue = MensCombo7.exec()

                elif not self.lineEdit_11.text():
                    MensCombo8 = QMessageBox()
                    MensCombo8.setIcon(QMessageBox.Warning)
                    MensCombo8.setWindowTitle("Empty Start time")
                    MensCombo8.setText("Please, enter a valid Value")
                    returnValue = MensCombo8.exec()

                elif not self.lineEdit_12.text():
                    MensCombo9 = QMessageBox()
                    MensCombo9.setIcon(QMessageBox.Warning)
                    MensCombo9.setWindowTitle("Empty End time")
                    MensCombo9.setText("Please, enter a valid Value")
                    returnValue = MensCombo9.exec()

                elif not self.lineEdit_13.text():
                    MensCombo10 = QMessageBox()
                    MensCombo10.setIcon(QMessageBox.Warning)
                    MensCombo10.setWindowTitle("Empty NaN Tolerance")
                    MensCombo10.setText("Please, enter a valid Value")
                    returnValue = MensCombo10.exec()

                else:
                    # Filtering with a Bandstop 10 min.
                    plt.close()                                                 # Close the existing chart.

                    carpeta = (self.label_5.text())                             # Reading the directory or file folder label.

                    # Code to detect the contents of the folder and the files that the folder contains
                    with os.scandir(carpeta) as ficheros:
                        ficheros4 = [fichero.name for fichero in ficheros if fichero.is_file()]

                    # The contents of the files in "ficheros4" is a list. This code converts them to string
                    lfiles = [str(elemento) for elemento in ficheros4]

                    # Code used to determine the name of the files contained in the folder and to be used in the loading loop
                    Iniciolfiles = lfiles[0]                                    # Detects the numeric value of the "Start" in the name
                    Finlfiles = lfiles[-1]                                      # Detects the numerical value of the "End" in the name
                    Indice1 = Iniciolfiles.rfind('.')                           # Determines the index, which will be marked by the dot at the end for the extension
                    Nombre3 = Iniciolfiles[0:Indice1]                           # Indicates the name of the file in str (minus) the index or extension (each day)

                    # Data entry from labels and fields or text boxes (this value is a string by default)
                    #num_temporal_units = (self.lineEdit_5.text())               # label reading of the total number of daily files.
                    frecMin = (self.lineEdit_8.text())                          # Minimum Frequency label reading.
                    frecMax = (self.lineEdit_9.text())                          # Maximum Frequency label reading.
                    orden1 = (self.lineEdit_7.text())                           # Reading the Filter Order Label.
                    Tam = (self.lineEdit_10.text())                             # Reading the envelope window size label.
                    Start1 = (self.lineEdit_11.text())                          # Star Time Size label reading.
                    End1 = (self.lineEdit_12.text())                            # End Time Size label reading.

                    # Convert the string value of the input text boxes to float or integer
                    frec7=float(frecMin)                                        # Converts the Minimum Frequency value to float.
                    frec8=float(frecMax)                                        # Converts the Maximum Frequency value to float.
                    orden7=int(orden1)                                          # Converts filter order value to integer.

                    #timeIn=int(num_temporal_units)                              # Converts the value of the total number of daily files to an integer.

                    # Data entry for enveloped (this value is a string by default)
                    Tam = (self.lineEdit_10.text())                             # Reading the envelope window size label.
                    Tsua = (self.lineEdit_5.text())                             # Reading the Smoothing type label.
                    Tnan = (self.lineEdit_13.text())                            # Reading the NaN Tolerance label.

                    Tam1=int(Tam)                                               # Converts the envelope window size value to integer.
                    Tsua1=int(Tsua)                                             # Converts the Smoothing type value to integer.
                    Tnan1=int(Tnan)                                             # Converts the NaN Tolerance value to integer.

                    timeIn = 365

                    Start2=int(Start1)                                          # Converts the Start time window size value to an integer.
                    End2=int(End1)                                              # Converts the End time window size value to an integer.

                    Diferencia = End2 - Start2                                  # Value of the difference between end and start to obtain the number of days to calculate

                    # *** Functions ***

                    # Function for Shannon entropy calculating
                    def calcular_entropia(datos):
                        params = stats.norm.fit(datos)
                        dist = stats.norm(*params)
                        probabilidades = dist.pdf(datos)
                        entropia = -np.sum(probabilidades * np.log2(probabilidades))
                        return entropia


                    # Function for Kurtosis calculating
                    def calcular_kurtosis(datos):
                        n = len(datos)
                        media = np.mean(datos)
                        varianza = np.var(datos)
                        desviacion_estandar = np.sqrt(varianza)

                        if desviacion_estandar == 0:
                            return 0.0
                        kurtosis = np.sum((datos - media)**4) / (n * desviacion_estandar**4) - 3.0
                        return kurtosis

                    # Function for Shannon entropy enveloped calculating
                    def nanfastsmooth(Y, w, type=1, tol=0.5):

                        """
                        Smooths vector Y with a moving average of width w, ignoring NaNs in data.

                        Parameters:
                        Y (numpy array): Input signal.
                        w (int): Window width.
                        type (int): Smooth type (1 for rectangular, 2 for triangular, 3 for pseudo-Gaussian).
                        tol (float): Tolerance to NaNs between 0 and 1.

                        Returns:
                        numpy array: Smoothed signal.
                        """
                        mask = ~np.isnan(Y)  # Create a boolean mask for non-NaN values
                        Y[mask] = nanfastsmooth_core(Y[mask], w, type, tol)  # Apply smoothing to non-NaN values
                        return Y

                    # Function for Shannon entropy enveloped type calculating. For default the value = 3
                    def nanfastsmooth_core(Y, w, type, tol):
                        if type == 1:
                            SmoothY = moving_average(Y, w)
                        elif type == 2:
                            SmoothY = moving_average(moving_average(Y, w), w)
                        elif type == 3:
                            SmoothY = moving_average(moving_average(moving_average(Y, w), w), w)

                        return SmoothY

                    def moving_average(Y, window_size):
                        return np.convolve(Y, np.ones(window_size)/window_size, mode='same')

                    def calcular_indice_frecuencias(datos, frecuencia_muestreo):
                        # Aplicar filtro en frecuencia
                        freq_bajas = (1, 5.5)
                        freq_altas = (6, 16)

                        datos_bajas = apply_bandpass_filter(datos, frecuencia_muestreo, freq_bajas)
                        datos_altas = apply_bandpass_filter(datos, frecuencia_muestreo, freq_altas)

                        # Calcular energía para cada señal
                        energia_bajas = np.sum(datos_bajas ** 2)
                        energia_altas = np.sum(datos_altas ** 2)

                        # Calcular índice de frecuencias
                        indice_frecuencias = np.log(energia_altas / energia_bajas) if energia_bajas != 0 else np.nan
                        return indice_frecuencias

                    def apply_bandpass_filter(datos, frecuencia_muestreo, freq_band):
                        nyquist = 0.5 * frecuencia_muestreo
                        normal_freq_band = np.array(freq_band) / nyquist
                        b, a = signal.butter(4, normal_freq_band, btype='band')
                        datos_filtrados = signal.filtfilt(b, a, datos)
                        return datos_filtrados

                    # Start entropy and averaged entropy values
                    entropia_shannon = []
                    entropia_promediada = []
                    kurtosis_resultados = []
                    frequency_index = []

                    # Cycle for the day-by-day calculation of the entropy in the files contained in the folder, using the time range (Start to End)
                    for dia in range(Start2, End2 + 1):

                        archivo = Nombre3 + '.'+ f"{dia:003}"       # Here you select the name previously calculated plus point and the value of each Julian day

                        # If there is no file in the list, the entire day is added with a value of zero
                        if not os.path.exists(os.path.join(carpeta, archivo)):
                            for _ in range(24*6):  # Adds 24 hours with zero value if there is no file
                                entropia_shannon.append(0)
                                entropia_promediada.append(0)
                                kurtosis_resultados.append(0)
                                frequency_index.append(0)
                            continue

                        # Designation of the data contained in the folder files
                        st = Stream()
                        st += read(os.path.join(carpeta, archivo))
                        frecuencia_muestreo = st[0].stats.sampling_rate
                        # calculation of the Bandstop filter with the parameters indicated by the user.
                        st.filter('bandstop', freqmin=frec7, freqmax=frec8, corners=orden7, zerophase=True)
                        # Data value
                        datos = st[0].data

                        # Divide the data into hours and calculate entropy for each hour.
                        for hora in range(24*6):
                            inicio = hora * 600 * 100  # start of time in seconds.
                            fin = inicio + 600 * 100  # End of time in seconds.
                            datos_hora = datos[inicio:fin]

                            if len(datos_hora) < 600 * 100:  # If the hour is incomplete, add zeros to the end.
                                datos_hora = np.append(datos_hora, np.zeros(600 * 100 - len(datos_hora)))

                            # Accumulator of the calculated values of the Shannon entropy and the averaged entropy.
                            entropia_shannon.append(calcular_entropia(datos_hora))
                            entropia_promediada.append(calcular_entropia(datos_hora) / len(datos_hora))
                            kurtosis_resultados.append(calcular_kurtosis(datos_hora))
                            frequency_index.append(calcular_indice_frecuencias(datos_hora, frecuencia_muestreo))

                    # Converting shannon entropy value and averaged entropy to data array.
                    entropia_shannon = np.array(entropia_shannon)
                    entropia_promediada = np.array(entropia_promediada)
                    kurtosis_resultados = np.array(kurtosis_resultados)
                    frequency_index=np.array(frequency_index)

                    # Shannon Entropy Graph. Value of non-zero indices where there is no data.
                    indices_no_cero_shannon = np.where(entropia_shannon != 0)[0]

                    indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                    indices_no_cero_frecuency = np.where(frequency_index != 0)[0]

                    indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]

                    # **** SAVE THE RESULTS FILE .CSV
                    archivoFil2 = (self.label_8.text())                         # Reading directory label.

                    # **** SAVE THE RESULTS .npy FILE FOR LATER GRAPH *****
                    TW = str(Tam1)                                              # Convert Envelope Window value to string for names.
                    F1 = (Nombre3 + '_Bandstop_Filter_10m ' + '_Windows=' + TW + '.csv')            # Assign F1, Capture the name of the record and add the .csv extension.

                    # Guardar resultados en archivos .npy
                    F1a = (Nombre3 + '_Bandstop_Filter_10m' + '_Windows=' + TW)
                    F2 = (archivoFil2 + F1)                                     # Assigns to F2 the directory plus the previous name where the record will be stored.
                    F3 = (archivoFil2 + F1a)

                    with open(F2, 'w+', newline='') as archivo_csv:             # Each result is saved in the file, day, time and values of Shannon's entropy and averaged.
                        writer = csv.writer(archivo_csv)
                        writer.writerow(['Day', ' hour', ' Shannon Entropy', ' Averaged Shannon Entropy', ' Envelope Shannon Entropy', ' Kurtosis', ' Frequency Index'])

                        for dia in range(1, Diferencia + 1):                        # Save data by day and time according to the time interval (Start - End)
                            for hora in range(24*6):
                                writer.writerow([dia, hora, entropia_shannon[(dia - 1) * 24*6 + hora], entropia_promediada[(dia - 1) * 24*6 + hora], kurtosis_resultados[(dia - 1) * 24*6 + hora], frequency_index[(dia - 1) * 24*6 + hora] ])

                    # Use example
                    Y = entropia_shannon
                    Y = np.where(Y == 0, np.nan, Y)

                    Y1 = kurtosis_resultados
                    Y1 = np.where(Y1 == 0, np.nan, Y1)

                    Y2 = frequency_index
                    Y2 = np.where(Y2 == 0, np.nan, Y2)

                    if self.checkBox_2.isChecked():                                 # checkBox for Initial Time

                        if not self.lineEdit_14.text():
                            MensCombo14 = QMessageBox()
                            MensCombo14.setIcon(QMessageBox.Warning)
                            MensCombo14.setWindowTitle("Empty Year value")
                            MensCombo14.setText("Please, enter a valid value")
                            returnValue = MensCombo14.exec()

                        elif not self.lineEdit_15.text():
                            MensCombo15 = QMessageBox()
                            MensCombo15.setIcon(QMessageBox.Warning)
                            MensCombo15.setWindowTitle("Empty Month value")
                            MensCombo15.setText("Please, enter a valid value")
                            returnValue = MensCombo15.exec()

                        elif not self.lineEdit_16.text():
                            MensCombo16 = QMessageBox()
                            MensCombo16.setIcon(QMessageBox.Warning)
                            MensCombo16.setWindowTitle("Empty Day value")
                            MensCombo16.setText("Please, enter a valid value")
                            returnValue = MensCombo16.exec()

                        else:

                            # Data entry for enveloped (this value is a string by default)
                            Anio = (self.lineEdit_14.text())                            # Reading the Year value label.
                            Mes = (self.lineEdit_15.text())                             # Reading the Month value label.
                            Dia1 = (self.lineEdit_16.text())                            # Reading the Day value label.

                            # Convert the string value of the input text boxes to  integer

                            Anio1=int(Anio)                                             # Converts the Year value to integer.
                            Mes1=int(Mes)                                               # Converts the Month value to integer.
                            Dia2=int(Dia1)                                              # Converts the NaN Day value to integer.

                            # Dates vector create
                            fecha_inicio = datetime(Anio1, Mes1, Dia2)
                            dias = [fecha_inicio + timedelta(minutes=(10*i)) for i in range(len(entropia_shannon[indices_no_cero_shannon]))]

                            st = (dias, entropia_shannon[indices_no_cero_shannon])

                            # Save the ".npy" file in the directory.
                            np.save(F3, st)
                            plt.close()                                             # Close the existing chart.

                            # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                            # Graph 1 - ENTROPY BY POINTS.

                            plt.plot(dias, entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='ShannonEntropy: Points per hour -> 10 min')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_ShannonEntropy: Each point = 10 min. with Bandstop filter', color ="darkgreen", fontsize=18)

                            # Graph 2 - Averaged Shannon Entropy Graph.

                            fig, ax = plt.subplots(1,1)
                            indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                            plt.plot(dias, entropia_promediada[indices_no_cero_promediada], "ob", mfc="b", mec = "b", label='ShannonAveragedEntropy: Points per hour -> 10 min')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Shannon Averaged Entropy: Each point = 10 min. with Bandstop filter.', color ="darkgreen", fontsize=18)

                            # Graph 3 - Graph of Shannon Entropy plus the envelope.

                            # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE.

                            fig, ax = plt.subplots(1,1)

                            y_filtered = nanfastsmooth(Y.copy(), Tam1, Tsua1, Tnan1)  # Make a "Y" copy to avoid modifying the original

                            plt.plot(dias, entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='Shannon Entropy')
                            plt.plot(dias, y_filtered[indices_no_cero_shannon], label='Envelope', color='blue')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Envelope - Shannon Entropy: Each point = 10 min. with Bandstop filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            # Graph 4 - Envelope only graph.

                            fig, ax = plt.subplots(1,1)

                            plt.plot(dias, y_filtered[indices_no_cero_shannon], label='Filtered Signal', color='blue')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Only the envelope of Shannon entropy: Each point = 10 min. with Bandstop filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                            # Graph 5 Frequency Index con envolvente
                            fig, ax = plt.subplots(1,1)

                            y_filtered3 = nanfastsmooth(Y2.copy(), Tam1, Tsua1, Tnan1)  # Make a "Y" copy to avoid modifying the original

                            plt.plot(dias, frequency_index[indices_no_cero_frecuency], 'o-', label='Frequency Index')
                            plt.plot(dias, y_filtered3[indices_no_cero_frecuency], label='Envelope', color='red')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                            plt.title(Nombre3 + ' Frequency Index: Each point = 10 min. with Bandstop filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            # Graph 6 Kurtosis with envelope
                            fig, ax = plt.subplots(1,1)
                            indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]

                            # Dates vector create
                            fecha_inicio = datetime(Anio1, Mes1, Dia2)
                            dias2 = [fecha_inicio + timedelta(minutes=(10*i)) for i in range(len(entropia_shannon[indices_no_cero_kurtosis]))]

                            y_filtered2 = nanfastsmooth(Y1.copy(), Tam1, Tsua1, Tnan1)  # Make a "Y" copy to avoid modifying the original

                            plt.plot(dias2, kurtosis_resultados[indices_no_cero_kurtosis], 'o', label='Kurtosis')
                            plt.plot(dias2, y_filtered2[indices_no_cero_kurtosis], label='Envelope', color='red')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                            plt.title(Nombre3 + ' Kurtosis: Each point = 10 min. with Bandstop filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            plt.show()

                    else:

                        # Plot the vectors into separate figures.
                        dias = np.arange(1, 8761*6+1)

                        st = (dias, entropia_shannon[indices_no_cero_shannon])

                        np.save(F3, st)  # Save the ".npy" file in the directory.
                        plt.close()

                        # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                        # Graph 1 - ENTROPY BY POINTS.

                        plt.plot(dias[indices_no_cero_shannon], entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='ShannonEntropy: Points per hour -> 10 min')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_ShannonEntropy: Each point = 10 min. with Bandstop filter', color ="darkgreen", fontsize=18)

                        # Graph 2 - Averaged Shannon Entropy Graph.

                        fig, ax = plt.subplots(1,1)
                        indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                        plt.plot(dias[indices_no_cero_promediada], entropia_promediada[indices_no_cero_promediada], "ob", mfc="b", mec = "b", label='ShannonAveragedEntropy: Points per hour -> 10 min')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Shannon Averaged Entropy: Each point = 10 min. with Bandstop filter.', color ="darkgreen", fontsize=18)

                        # Graph 3 - Graph of Shannon Entropy plus the envelope.

                        # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE.

                        fig, ax = plt.subplots(1,1)

                        y_filtered = nanfastsmooth(Y.copy(), Tam1, Tsua1, Tnan1)  # Make a "Y" copy to avoid modifying the original

                        plt.plot(dias[indices_no_cero_shannon], entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='Shannon Entropy')
                        plt.plot(dias[indices_no_cero_shannon], y_filtered[indices_no_cero_shannon], label='Envelope', color='blue')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Envelope - Shannon Entropy: Each point = 10 min. with Bandstop filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        # Graph 4 - Envelope only graph.

                        fig, ax = plt.subplots(1,1)

                        plt.plot(dias[indices_no_cero_shannon], y_filtered[indices_no_cero_shannon], label='Filtered Signal', color='blue')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Only the envelope of Shannon entropy: Each point = 10 min. with Bandstop filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                        # Graph 5 Frequency Index con envolvente
                        fig, ax = plt.subplots(1,1)

                        y_filtered3 = nanfastsmooth(Y2.copy(), Tam1, Tsua1, Tnan1)  # Make a "Y" copy to avoid modifying the original

                        plt.plot(dias[indices_no_cero_frecuency], frequency_index[indices_no_cero_frecuency], 'o-', label='Frequency Index')
                        plt.plot(dias[indices_no_cero_frecuency], y_filtered3[indices_no_cero_frecuency], label='Envelope', color='red')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                        plt.title(Nombre3 + ' Frequency Index: Each point = 10 min. with Bandstop filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        # Graph 6 Kurtosis with envelope
                        fig, ax = plt.subplots(1,1)
                        indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]

                        y_filtered2 = nanfastsmooth(Y1.copy(), Tam1, Tsua1, Tnan1)  # Make a "Y" copy to avoid modifying the original

                        plt.plot(dias[indices_no_cero_kurtosis], kurtosis_resultados[indices_no_cero_kurtosis], 'o', label='Kurtosis')
                        plt.plot(dias[indices_no_cero_kurtosis], y_filtered2[indices_no_cero_kurtosis], label='Envelope', color='red')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                        plt.title(Nombre3 + ' Kurtosis: Each point = 10 min. with Bandstop filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        plt.show()

            else:                                           # Here the value of the entropy is calculated without the time interval (Start - End)

                if not self.lineEdit_5.text():
                    MensCombo1 = QMessageBox()
                    MensCombo1.setIcon(QMessageBox.Warning)
                    MensCombo1.setWindowTitle("Empty Smoothing type")
                    MensCombo1.setText("Please, enter a valid Value")
                    returnValue = MensCombo1.exec()

                elif not self.lineEdit_7.text():
                    MensCombo2 = QMessageBox()
                    MensCombo2.setIcon(QMessageBox.Warning)
                    MensCombo2.setWindowTitle("Empty Filter Order")
                    MensCombo2.setText("Please, enter a valid Value")
                    returnValue = MensCombo2.exec()

                elif not self.lineEdit_8.text():
                    MensCombo3 = QMessageBox()
                    MensCombo3.setIcon(QMessageBox.Warning)
                    MensCombo3.setWindowTitle("Empty Min. Frequency")
                    MensCombo3.setText("Please, enter a valid Value")
                    returnValue = MensCombo3.exec()

                elif not self.lineEdit_9.text():
                    MensCombo4 = QMessageBox()
                    MensCombo4.setIcon(QMessageBox.Warning)
                    MensCombo4.setWindowTitle("Empty Max. Frequency")
                    MensCombo4.setText("Please, enter a valid Value")
                    returnValue = MensCombo4.exec()

                elif not self.lineEdit_10.text():
                    MensCombo5 = QMessageBox()
                    MensCombo5.setIcon(QMessageBox.Warning)
                    MensCombo5.setWindowTitle("Empty Envelope Window size")
                    MensCombo5.setText("Please, enter a valid Value")
                    returnValue = MensCombo5.exec()

                elif not self.lineEdit_13.text():
                    MensCombo6 = QMessageBox()
                    MensCombo6.setIcon(QMessageBox.Warning)
                    MensCombo6.setWindowTitle("Empty NaN Tolerance")
                    MensCombo6.setText("Please, enter a valid Value")
                    returnValue = MensCombo6.exec()

                elif not self.label_5.text():
                    MensCombo7 = QMessageBox()
                    MensCombo7.setIcon(QMessageBox.Warning)
                    MensCombo7.setWindowTitle("Empty directory to upload records")
                    MensCombo7.setText("Please, enter a valid name of directory")
                    returnValue = MensCombo7.exec()

                elif not self.label_8.text():
                    MensCombo8 = QMessageBox()
                    MensCombo8.setIcon(QMessageBox.Warning)
                    MensCombo8.setWindowTitle("Empty path to store CSV/NPY file")
                    MensCombo8.setText("Please, enter a valid name of directory")
                    returnValue = MensCombo8.exec()

                else:

                    # Filtering with a Bandstop 10 min.
                    plt.close()                                                 # Close the existing chart.

                    carpeta = (self.label_5.text())                             # Reading the directory or file folder label.

                    # Code to detect the contents of the folder and the files that the folder contains
                    with os.scandir(carpeta) as ficheros:
                        ficheros4 = [fichero.name for fichero in ficheros if fichero.is_file()]

                    # The contents of the files in "ficheros4" is a list. This code converts them to string
                    lfiles = [str(elemento) for elemento in ficheros4]

                    # Code used to determine the name of the files contained in the folder and to be used in the loading loop
                    Iniciolfiles = lfiles[0]                                    # Detects the numeric value of the "Start" in the name
                    Finlfiles = lfiles[-1]                                      # Detects the numerical value of the "End" in the name
                    Indice1 = Iniciolfiles.rfind('.')                           # Determines the index, which will be marked by the dot at the end for the extension
                    Nombre3 = Iniciolfiles[0:Indice1]                           # Indicates the name of the file in str (minus) the index or extension (each day)

                    # Data entry from labels and fields or text boxes (this value is a string by default)

                    frecMin = (self.lineEdit_8.text())                          # Minimum Frequency label reading.
                    frecMax = (self.lineEdit_9.text())                          # Maximum Frequency label reading.
                    orden1 = (self.lineEdit_7.text())                           # Reading the Filter Order Label.

                    # Data entry for enveloped (this value is a string by default)
                    Tam = (self.lineEdit_10.text())                             # Reading the envelope window size label.
                    Tsua = (self.lineEdit_5.text())                             # Reading the Smoothing type label.
                    Tnan = (self.lineEdit_13.text())                            # Reading the NaN Tolerance label.

                    # Convert the string value of the input text boxes to float or integer
                    frec7=float(frecMin)                                        # Converts the Minimum Frequency value to float.
                    frec8=float(frecMax)                                        # Converts the Maximum Frequency value to float.
                    orden7=int(orden1)                                          # Converts filter order value to integer.
                    #timeIn=int(num_temporal_units)                              # Converts the value of the total number of daily files to an integer.

                    Tam1=int(Tam)                                               # Converts the envelope window size value to integer.
                    Tsua1=int(Tsua)                                             # Converts the Smoothing type value to integer.
                    Tnan1=int(Tnan)                                             # Converts the NaN Tolerance value to integer.

                    timeIn = 365

                    # *** Functions ***

                    # Function for Shannon entropy calculating
                    def calcular_entropia(datos):
                        params = stats.norm.fit(datos)
                        dist = stats.norm(*params)
                        probabilidades = dist.pdf(datos)
                        entropia = -np.sum(probabilidades * np.log2(probabilidades))
                        return entropia

                    # Function for Kurtosis calculating
                    def calcular_kurtosis(datos):
                        n = len(datos)
                        media = np.mean(datos)
                        varianza = np.var(datos)
                        desviacion_estandar = np.sqrt(varianza)

                        if desviacion_estandar == 0:
                            return 0.0
                        kurtosis = np.sum((datos - media)**4) / (n * desviacion_estandar**4) - 3.0
                        return kurtosis

                    # Function for Shannon entropy enveloped calculating
                    def nanfastsmooth(Y, w, type=1, tol=0.5):

                        """
                        Smooths vector Y with a moving average of width w, ignoring NaNs in data.

                        Parameters:
                        Y (numpy array): Input signal.
                        w (int): Window width.
                        type (int): Smooth type (1 for rectangular, 2 for triangular, 3 for pseudo-Gaussian).
                        tol (float): Tolerance to NaNs between 0 and 1.

                        Returns:
                        numpy array: Smoothed signal.
                        """
                        mask = ~np.isnan(Y)  # Create a boolean mask for non-NaN values
                        Y[mask] = nanfastsmooth_core(Y[mask], w, type, tol)  # Apply smoothing to non-NaN values
                        return Y

                    # Function for Shannon entropy enveloped type calculating. For default the value = 3
                    def nanfastsmooth_core(Y, w, type, tol):
                        if type == 1:
                            SmoothY = moving_average(Y, w)
                        elif type == 2:
                            SmoothY = moving_average(moving_average(Y, w), w)
                        elif type == 3:
                            SmoothY = moving_average(moving_average(moving_average(Y, w), w), w)

                        return SmoothY

                    def moving_average(Y, window_size):
                        return np.convolve(Y, np.ones(window_size)/window_size, mode='same')

                    def calcular_indice_frecuencias(datos, frecuencia_muestreo):
                        # Aplicar filtro en frecuencia
                        freq_bajas = (1, 5.5)
                        freq_altas = (6, 16)

                        datos_bajas = apply_bandpass_filter(datos, frecuencia_muestreo, freq_bajas)
                        datos_altas = apply_bandpass_filter(datos, frecuencia_muestreo, freq_altas)

                        # Calcular energía para cada señal
                        energia_bajas = np.sum(datos_bajas ** 2)
                        energia_altas = np.sum(datos_altas ** 2)

                        # Calcular índice de frecuencias
                        indice_frecuencias = np.log(energia_altas / energia_bajas) if energia_bajas != 0 else np.nan
                        return indice_frecuencias

                    def apply_bandpass_filter(datos, frecuencia_muestreo, freq_band):
                        nyquist = 0.5 * frecuencia_muestreo
                        normal_freq_band = np.array(freq_band) / nyquist
                        b, a = signal.butter(4, normal_freq_band, btype='band')
                        datos_filtrados = signal.filtfilt(b, a, datos)
                        return datos_filtrados

                    # Start entropy and averaged entropy values
                    entropia_shannon = []
                    entropia_promediada = []
                    kurtosis_resultados = []
                    frequency_index = []

                    # Cycle for the day-by-day calculation of the entropy in the files contained in the folder, using the time range (Start to End)
                    for dia in range(1, timeIn + 1):

                        archivo = Nombre3 + '.'+ f"{dia:003}"       # Here you select the name previously calculated plus point and the value of each Julian day

                        # If there is no file in the list, the entire day is added with a value of zero
                        if not os.path.exists(os.path.join(carpeta, archivo)):
                            for _ in range(24*6):  # Adds 24 hours with zero value if there is no file
                                entropia_shannon.append(0)
                                entropia_promediada.append(0)
                                kurtosis_resultados.append(0)
                                frequency_index.append(0)
                            continue

                        # Designation of the data contained in the folder files
                        st = Stream()
                        st += read(os.path.join(carpeta, archivo))
                        frecuencia_muestreo = st[0].stats.sampling_rate
                        # calculation of the Bandstop filter with the parameters indicated by the user.
                        st.filter('bandstop', freqmin=frec7, freqmax=frec8, corners=orden7, zerophase=True)
                        # Data value
                        datos = st[0].data

                        # Divide the data into hours and calculate entropy for each hour.
                        for hora in range(24*6):
                            inicio = hora * 600 * 100  # start of time in seconds.
                            fin = inicio + 600 * 100  # End of time in seconds.
                            datos_hora = datos[inicio:fin]

                            if len(datos_hora) < 600 * 100:  # If the hour is incomplete, add zeros to the end.
                                datos_hora = np.append(datos_hora, np.zeros(600 * 100 - len(datos_hora)))

                            # Accumulator of the calculated values of the Shannon entropy and the averaged entropy.
                            entropia_shannon.append(calcular_entropia(datos_hora))
                            entropia_promediada.append(calcular_entropia(datos_hora) / len(datos_hora))
                            kurtosis_resultados.append(calcular_kurtosis(datos_hora))
                            frequency_index.append(calcular_indice_frecuencias(datos_hora, frecuencia_muestreo))

                    # Converting shannon entropy value and averaged entropy to data array.
                    entropia_shannon = np.array(entropia_shannon)
                    entropia_promediada = np.array(entropia_promediada)
                    kurtosis_resultados = np.array(kurtosis_resultados)
                    frequency_index=np.array(frequency_index)

                    # Shannon Entropy Graph. Value of non-zero indices where there is no data.
                    indices_no_cero_shannon = np.where(entropia_shannon != 0)[0]

                    indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                    indices_no_cero_frecuency = np.where(frequency_index != 0)[0]

                    indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]


                    archivoFil2 = (self.label_8.text())                         # Reading directory label.

                    # **** SAVE THE RESULTS  .CSV and .NPY FILE FOR LATER GRAPH *****
                    TW = str(Tam1)                                              # Convert Envelope Window value to string for names.
                    F1 = (Nombre3 + '_Bandstop_Filter_10m ' + '_Windows=' + TW + '.csv')            # Assign F1, Capture the name of the record and add the .csv extension.

                    F1a = (Nombre3 + '_Bandstop_Filter_10m' + '_Windows=' + TW)
                    F2 = (archivoFil2 + F1)                                     # Assigns to F2 the directory plus the previous name where the record will be stored.
                    F3 = (archivoFil2 + F1a)


                    # **** SAVE THE RESULTS FILE .CSV ***
                    with open(F2, 'w+', newline='') as archivo_csv:             # Each result is saved in the file, day, time and values of Shannon's entropy and averaged.
                        writer = csv.writer(archivo_csv)
                        writer.writerow(['Day', ' hour', ' Shannon Entropy', ' Averaged Shannon Entropy', ' Envelope Shannon Entropy', ' Kurtosis', ' Frequency Index'])

                        for dia in range(1, timeIn + 1):                        # Save data by day and time according to the time interval (Start - End)
                            for hora in range(24*6):
                                writer.writerow([dia, hora, entropia_shannon[(dia - 1) * 24*6 + hora], entropia_promediada[(dia - 1) * 24*6 + hora], kurtosis_resultados[(dia - 1) * 24*6 + hora], frequency_index[(dia - 1) * 24*6 + hora] ])

                    # Use example
                    Y = entropia_shannon
                    Y = np.where(Y == 0, np.nan, Y)

                    Y1 = kurtosis_resultados
                    Y1 = np.where(Y1 == 0, np.nan, Y1)

                    Y2 = frequency_index
                    Y2 = np.where(Y2 == 0, np.nan, Y2)

                    if self.checkBox_2.isChecked():                                     # checkBox for Initial Time

                        if not self.lineEdit_14.text():
                            MensCombo9 = QMessageBox()
                            MensCombo9.setIcon(QMessageBox.Warning)
                            MensCombo9.setWindowTitle("Empty Year value")
                            MensCombo9.setText("Please, enter a valid Value")
                            returnValue = MensCombo9.exec()

                        elif not self.lineEdit_15.text():
                            MensCombo10 = QMessageBox()
                            MensCombo10.setIcon(QMessageBox.Warning)
                            MensCombo10.setWindowTitle("Empty Month value")
                            MensCombo10.setText("Please, enter a valid Value")
                            returnValue = MensCombo10.exec()

                        elif not self.lineEdit_14.text():
                            MensCombo11 = QMessageBox()
                            MensCombo11.setIcon(QMessageBox.Warning)
                            MensCombo11.setWindowTitle("Empty Day value")
                            MensCombo11.setText("Please, enter a valid Value")
                            returnValue = MensCombo11.exec()

                        else:

                            # Data entry for enveloped (this value is a string by default)
                            Anio = (self.lineEdit_14.text())                            # Reading the Year value label.
                            Mes = (self.lineEdit_15.text())                             # Reading the Month value label.
                            Dia1 = (self.lineEdit_16.text())                            # Reading the Day value label.

                            # Convert the string value of the input text boxes to  integer

                            Anio1=int(Anio)                                             # Converts the Year value to integer.
                            Mes1=int(Mes)                                               # Converts the Month value to integer.
                            Dia2=int(Dia1)                                              # Converts the NaN Day value to integer.

                            # Dates vector create
                            fecha_inicio = datetime(Anio1, Mes1, Dia2)
                            dias = [fecha_inicio + timedelta(minutes=(10*i)) for i in range(len(entropia_shannon[indices_no_cero_shannon]))]

                            st = (dias, entropia_shannon[indices_no_cero_shannon])

                            # Save the ".npy" file in the directory.
                            np.save(F3, st)
                            plt.close()                                             # Close the existing chart.

                            # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                            # Graph 1 - ENTROPY BY POINTS.

                            plt.plot(dias, entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='ShannonEntropy: Points per hour -> 10 min')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_ShannonEntropy: Each point = 10 min. with Bandstop filter', color ="darkgreen", fontsize=18)

                            # Graph 2 - Averaged Shannon Entropy Graph.

                            fig, ax = plt.subplots(1,1)
                            indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                            plt.plot(dias, entropia_promediada[indices_no_cero_promediada], "ob", mfc="b", mec = "b", label='ShannonAveragedEntropy: Points per hour -> 10 min')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Shannon Averaged Entropy: Each point = 10 min. with Bandstop filter.', color ="darkgreen", fontsize=18)

                            # Graph 3 - Graph of Shannon Entropy plus the envelope.

                            # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE.

                            fig, ax = plt.subplots(1,1)

                            y_filtered = nanfastsmooth(Y.copy(), Tam1, Tsua1, Tnan1)  # Make a "Y" copy to avoid modifying the original

                            plt.plot(dias, entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='Shannon Entropy')
                            plt.plot(dias, y_filtered[indices_no_cero_shannon], label='Envelope', color='blue')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Envelope - Shannon Entropy: Each point = 10 min. with Bandstop filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            # Graph 4 - Envelope only graph.

                            fig, ax = plt.subplots(1,1)

                            plt.plot(dias, y_filtered[indices_no_cero_shannon], label='Filtered Signal', color='blue')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Only the envelope of Shannon entropy: Each point = 10 min. with Bandstop filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                            # Graph 5 Frequency Index con envolvente
                            fig, ax = plt.subplots(1,1)

                            y_filtered3 = nanfastsmooth(Y2.copy(), Tam1, Tsua1, Tnan1)  # Make a "Y" copy to avoid modifying the original

                            plt.plot(dias, frequency_index[indices_no_cero_frecuency], 'o-', label='Frequency Index')
                            plt.plot(dias, y_filtered3[indices_no_cero_frecuency], label='Envelope', color='red')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                            plt.title(Nombre3 + ' Frequency Index: Each point = 10 min. with Bandstop filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            # Graph 6 Kurtosis plus enveloped
                            fig, ax = plt.subplots(1,1)
                            indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]

                            # Dates vector create
                            fecha_inicio = datetime(Anio1, Mes1, Dia2)
                            dias2 = [fecha_inicio + timedelta(minutes=(10*i)) for i in range(len(entropia_shannon[indices_no_cero_kurtosis]))]

                            y_filtered2 = nanfastsmooth(Y1.copy(), Tam1, Tsua1, Tnan1)  # Make a "Y" copy to avoid modifying the original

                            plt.plot(dias2, kurtosis_resultados[indices_no_cero_kurtosis], 'o', label='Kurtosis')
                            plt.plot(dias2, y_filtered2[indices_no_cero_kurtosis], label='Envelope', color='red')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                            plt.title(Nombre3 + ' Kurtosis: Each point = 10 min. with Bandstop filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            plt.show()
                    else:

                        # Plot the vectors into separate figures.
                        dias = np.arange(1, 8761*6+1)

                        st = (dias, entropia_shannon[indices_no_cero_shannon])

                        np.save(F3, st)  # Save the ".npy" file in the directory.
                        plt.close()

                        # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                        # Graph 1 - ENTROPY BY POINTS.

                        plt.plot(dias[indices_no_cero_shannon], entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='ShannonEntropy: Points per hour -> 10 min')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_ShannonEntropy: Each point = 10 min. with Bandstop filter', color ="darkgreen", fontsize=18)

                        # Graph 2 - Averaged Shannon Entropy Graph.

                        fig, ax = plt.subplots(1,1)
                        indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                        plt.plot(dias[indices_no_cero_promediada], entropia_promediada[indices_no_cero_promediada], "ob", mfc="b", mec = "b", label='ShannonAveragedEntropy: Points per hour -> 10 min')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Shannon Averaged Entropy: Each point = 10 min. with Bandstop filter.', color ="darkgreen", fontsize=18)

                        # Graph 3 - Graph of Shannon Entropy plus the enveloped.

                        # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE.

                        fig, ax = plt.subplots(1,1)

                        y_filtered = nanfastsmooth(Y.copy(), Tam1, Tsua1, Tnan1)  # Make a "Y" copy to avoid modifying the original

                        plt.plot(dias[indices_no_cero_shannon], entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='Shannon Entropy')
                        plt.plot(dias[indices_no_cero_shannon], y_filtered[indices_no_cero_shannon], label='Envelope', color='blue')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Envelope - Shannon Entropy: Each point = 10 min. with Bandstop filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        # Graph 4 - Envelope only graph.

                        fig, ax = plt.subplots(1,1)

                        plt.plot(dias[indices_no_cero_shannon], y_filtered[indices_no_cero_shannon], label='Filtered Signal', color='blue')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Only the envelope of Shannon entropy: Each point = 10 min. with Bandstop filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                        # Graph 5 Frequency Index con envolvente
                        fig, ax = plt.subplots(1,1)

                        y_filtered3 = nanfastsmooth(Y2.copy(), Tam1, Tsua1, Tnan1)  # Make a "Y" copy to avoid modifying the original

                        plt.plot(dias[indices_no_cero_frecuency], frequency_index[indices_no_cero_frecuency], 'o-', label='Frequency Index')
                        plt.plot(dias[indices_no_cero_frecuency], y_filtered3[indices_no_cero_frecuency], label='Envelope', color='red')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                        plt.title(Nombre3 + ' Frequency Index: Each point = 10 min. with Bandstop filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        # Graph 6 Kurtosis plus the enveloped
                        fig, ax = plt.subplots(1,1)
                        indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]

                        y_filtered2 = nanfastsmooth(Y1.copy(), Tam1, Tsua1, Tnan1)  # Make a "Y" copy to avoid modifying the original

                        plt.plot(dias[indices_no_cero_kurtosis], kurtosis_resultados[indices_no_cero_kurtosis], 'o', label='Kurtosis')
                        plt.plot(dias[indices_no_cero_kurtosis], y_filtered2[indices_no_cero_kurtosis], label='Envelope', color='red')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                        plt.title(Nombre3 + ' Kurtosis: Each point = 10 min. with Bandstop filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        plt.show()

        except:
                plt.close()                                                 # Close the existing chart.
                msgBox = QMessageBox()
                msgBox.setIcon(QMessageBox.Warning)
                msgBox.setText("The File Does not exist, is Invalid or the CSV old file is open. Please close, try again ...")
                msgBox.setWindowTitle("Invalid Record or CSV Old file is open ")
                returnValue = msgBox.exec()
                pass

    # *** FUNCTIONS FOR 24 HRS. WINDOWS ANALYSIS ***


    def filtropasobajo24hr(self):                                               # 9.- Function to execute the Lowpass filter with 24 hr. analysis window.

        try:

            # Verifying that the checkbox is true. Work with time intervals.

            if self.checkBox.isChecked() == True:                      # CheckBox 1 of the time interval is activated

                # Verify (Validation), that the text box and label is not empty

                if not self.label_5.text():
                    MensCombo1 = QMessageBox()
                    MensCombo1.setIcon(QMessageBox.Warning)
                    MensCombo1.setWindowTitle("Empty directory to upload records")
                    MensCombo1.setText("Please, enter a valid name of directory")
                    returnValue = MensCombo1.exec()

                elif not self.label_8.text():
                    MensCombo2 = QMessageBox()
                    MensCombo2.setIcon(QMessageBox.Warning)
                    MensCombo2.setWindowTitle("Empty path to store CSV/NPY file")
                    MensCombo2.setText("Please, enter a valid name of directory")
                    returnValue = MensCombo2.exec()

                elif not self.lineEdit_5.text():
                    MensCombo3 = QMessageBox()
                    MensCombo3.setIcon(QMessageBox.Warning)
                    MensCombo3.setWindowTitle("Empty Smoothing type")
                    MensCombo3.setText("Please, enter a valid Value")
                    returnValue = MensCombo3.exec()

                elif not self.lineEdit_6.text():
                    MensCombo4 = QMessageBox()
                    MensCombo4.setIcon(QMessageBox.Warning)
                    MensCombo4.setWindowTitle("Empty Frequency")
                    MensCombo4.setText("Please, enter a valid Value")
                    returnValue = MensCombo4.exec()

                elif not self.lineEdit_7.text():
                    MensCombo5 = QMessageBox()
                    MensCombo5.setIcon(QMessageBox.Warning)
                    MensCombo5.setWindowTitle("Empty Filter Order")
                    MensCombo5.setText("Please, enter a valid Value")
                    returnValue = MensCombo5.exec()

                elif not self.lineEdit_10.text():
                    MensCombo6 = QMessageBox()
                    MensCombo6.setIcon(QMessageBox.Warning)
                    MensCombo6.setWindowTitle("Empty Envelope Window size")
                    MensCombo6.setText("Please, enter a valid Value")
                    returnValue = MensCombo6.exec()

                elif not self.lineEdit_11.text():
                    MensCombo7 = QMessageBox()
                    MensCombo7.setIcon(QMessageBox.Warning)
                    MensCombo7.setWindowTitle("Empty Start time")
                    MensCombo7.setText("Please, enter a valid Value")
                    returnValue = MensCombo7.exec()

                elif not self.lineEdit_12.text():
                    MensCombo8 = QMessageBox()
                    MensCombo8.setIcon(QMessageBox.Warning)
                    MensCombo8.setWindowTitle("Empty End time")
                    MensCombo8.setText("Please, enter a valid Value")
                    returnValue = MensCombo8.exec()

                elif not self.lineEdit_13.text():
                    MensCombo9 = QMessageBox()
                    MensCombo9.setIcon(QMessageBox.Warning)
                    MensCombo9.setWindowTitle("Empty NaN Tolerance")
                    MensCombo9.setText("Please, enter a valid Value")
                    returnValue = MensCombo9.exec()

                else:
                    # Filtering with a Lowpass 24 Hrs.
                    plt.close()                                                 # Close the existing chart.

                    carpeta = (self.label_5.text())                             # Reading the directory or file folder label.

                    # Code to detect the contents of the folder and the files that the folder contains
                    with os.scandir(carpeta) as ficheros:
                        ficheros4 = [fichero.name for fichero in ficheros if fichero.is_file()]

                    # The contents of the files in "ficheros4" is a list. This code converts them to string
                    lfiles = [str(elemento) for elemento in ficheros4]

                    # Code used to determine the name of the files contained in the folder and to be used in the loading loop
                    Iniciolfiles = lfiles[0]                                    # Detects the numeric value of the "Start" in the name
                    Finlfiles = lfiles[-1]                                      # Detects the numerical value of the "End" in the name
                    Indice1 = Iniciolfiles.rfind('.')                           # Determines the index, which will be marked by the dot at the end for the extension
                    Nombre3 = Iniciolfiles[0:Indice1]                           # Indicates the name of the file in str (minus) the index or extension (each day)

                    # Data entry from labels and fields or text boxes (this value is a string by default)
                    frec3 = (self.lineEdit_6.text())                            # reading frequency Label.
                    orden1 = (self.lineEdit_7.text())                           # Reading the Filter Order Label.


                    # Data entry for enveloped (this value is a string by default)
                    Tam = (self.lineEdit_10.text())                             # Reading the envelope window size label.
                    Tsua = (self.lineEdit_5.text())                             # Reading the Smoothing type label.
                    Tnan = (self.lineEdit_13.text())                            # Reading the NaN Tolerance label.

                    Start1 = (self.lineEdit_11.text())                          # Star Time Size label reading.
                    End1 = (self.lineEdit_12.text())                            # End Time Size label reading.

                    # Convert the string value of the input text boxes to float or integer
                    frec4=float(frec3)                                          # Converts Frequency value to float.
                    orden4=int(orden1)                                          # Converts filter order value to integer.

                    Tam1=int(Tam)                                               # Converts the envelope window size value to integer.
                    Tsua1=int(Tsua)                                             # Converts the Smoothing type value to integer.
                    Tnan1=int(Tnan)                                             # Converts the NaN Tolerance value to integer.

                    timeIn = 365

                    Start2=int(Start1)                                          # Converts the Start time window size value to an integer.
                    End2=int(End1)                                              # Converts the End time window size value to an integer.

                    Diferencia = End2 - Start2                                  # Value of the difference between end and start to obtain the number of days to calculate

                    # Function for Shannon entropy calculating
                    def calcular_entropia(datos):
                        params = stats.norm.fit(datos)
                        dist = stats.norm(*params)
                        probabilidades = dist.pdf(datos)
                        entropia = -np.sum(probabilidades * np.log2(probabilidades))
                        return entropia

                     # Function for Kurtosis calculating
                    def calcular_kurtosis(datos):
                        n = len(datos)
                        media = np.mean(datos)
                        varianza = np.var(datos)
                        desviacion_estandar = np.sqrt(varianza)

                        if desviacion_estandar == 0:
                            return 0.0
                        kurtosis = np.sum((datos - media)**4) / (n * desviacion_estandar**4) - 3.0
                        return kurtosis

                    # Function for Shannon entropy enveloped calculating
                    def nanfastsmooth(Y, w, type=1, tol=0.5):

                        """
                        Smooths vector Y with a moving average of width w, ignoring NaNs in data.

                        Parameters:
                        Y (numpy array): Input signal.
                        w (int): Window width.
                        type (int): Smooth type (1 for rectangular, 2 for triangular, 3 for pseudo-Gaussian).
                        tol (float): Tolerance to NaNs between 0 and 1.

                        Returns:
                        numpy array: Smoothed signal.
                        """
                        mask = ~np.isnan(Y)  # Create a boolean mask for non-NaN values
                        Y[mask] = nanfastsmooth_core(Y[mask], w, type, tol)  # Apply smoothing to non-NaN values
                        return Y

                    # Function for Shannon entropy enveloped type calculating. For default the value = 3
                    def nanfastsmooth_core(Y, w, type, tol):
                        if type == 1:
                            SmoothY = moving_average(Y, w)
                        elif type == 2:
                            SmoothY = moving_average(moving_average(Y, w), w)
                        elif type == 3:
                            SmoothY = moving_average(moving_average(moving_average(Y, w), w), w)

                        return SmoothY

                    def moving_average(Y, window_size):
                        return np.convolve(Y, np.ones(window_size)/window_size, mode='same')

                    def calcular_indice_frecuencias(datos, frecuencia_muestreo):
                        # Frequency filter applied
                        freq_bajas = (1, 5.5)
                        freq_altas = (6, 16)

                        datos_bajas = apply_bandpass_filter(datos, frecuencia_muestreo, freq_bajas)
                        datos_altas = apply_bandpass_filter(datos, frecuencia_muestreo, freq_altas)

                        # The energy is calculated for each signal
                        energia_bajas = np.sum(datos_bajas ** 2)
                        energia_altas = np.sum(datos_altas ** 2)

                        # The frequency index is calculated
                        indice_frecuencias = np.log(energia_altas / energia_bajas) if energia_bajas != 0 else np.nan
                        return indice_frecuencias

                    def apply_bandpass_filter(datos, frecuencia_muestreo, freq_band):
                        nyquist = 0.5 * frecuencia_muestreo
                        normal_freq_band = np.array(freq_band) / nyquist
                        b, a = signal.butter(4, normal_freq_band, btype='band')
                        datos_filtrados = signal.filtfilt(b, a, datos)
                        return datos_filtrados

                    # Start entropy and averaged entropy values
                    entropia_shannon = []
                    entropia_promediada = []
                    kurtosis_resultados = []
                    frequency_index = []

                    # Cycle for the day-by-day calculation of the entropy in the files contained in the folder, using the time range (Start to End)
                    for dia in range(Start2, End2 + 1):

                        archivo = Nombre3 + '.'+ f"{dia:003}"       # Here you select the name previously calculated plus point and the value of each Julian day

                        # If there is no file in the list, the entire day is added with a value of zero
                        if not os.path.exists(os.path.join(carpeta, archivo)):
                            for _ in range(24):  # Adds 24 hours with zero value if there is no file
                                entropia_shannon.append(0)
                                entropia_promediada.append(0)
                                kurtosis_resultados.append(0)
                                frequency_index.append(0)
                            continue

                        # Designation of the data contained in the folder files
                        st = Stream()
                        st += read(os.path.join(carpeta, archivo))
                        frecuencia_muestreo = st[0].stats.sampling_rate
                        # calculation of the lowpass filter with the parameters indicated by the user.
                        st.filter('lowpass', freq=frec4, corners=orden4, zerophase=True)
                        # Data value
                        datos = st[0].data

                        # Divide the data into hours and calculate entropy for each hour.
                        for hora in range(24):
                            inicio = hora * 1440  # start of time in seconds.
                            fin = inicio + 84600  # End of time in seconds.
                            datos_hora = datos[inicio:fin]

                            if len(datos_hora) < 86400:  # If the hour is incomplete, add zeros to the end.
                                datos_hora = np.append(datos_hora, np.zeros(86400 - len(datos_hora)))

                            # Accumulator of the calculated values of the Shannon entropy and the averaged entropy.
                            entropia_shannon.append(calcular_entropia(datos_hora))
                            entropia_promediada.append(calcular_entropia(datos_hora) / len(datos_hora))
                            kurtosis_resultados.append(calcular_kurtosis(datos_hora))
                            frequency_index.append(calcular_indice_frecuencias(datos_hora, frecuencia_muestreo))

                    # Converting shannon entropy value and averaged entropy to data array.
                    entropia_shannon = np.array(entropia_shannon)
                    entropia_promediada = np.array(entropia_promediada)
                    kurtosis_resultados = np.array(kurtosis_resultados)
                    frequency_index=np.array(frequency_index)

                    # Shannon Entropy Graph. Value of non-zero indices where there is no data.
                    indices_no_cero_shannon = np.where(entropia_shannon != 0)[0]

                    indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                    indices_no_cero_frecuency = np.where(frequency_index != 0)[0]

                    indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]

                    # **** SAVE THE RESULTS FILE .CSV
                    archivoFil2 = (self.label_8.text())                         # Reading directory label.

                    # **** SAVE THE RESULTS .npy FILE FOR LATER GRAPH *****
                    TW = str(Tam1)                                              # Convert Envelope Window value to string for names.
                    F1 = (Nombre3 + '_Lowpass_Filter_24_Hrs_Time_interval_Dots_and_Time' + '_Windows=' + TW + '.csv')            # Assign F1, Capture the name of the record and add the .csv extension.

                    # Guardar resultados en archivos .npy
                    F1a = (Nombre3 + '_Lowpass_Filter_24_Hrs_Time_interval_Dots_and_Time' + '_Windows=' + TW)
                    F2 = (archivoFil2 + F1)                                     # Assigns to F2 the directory plus the previous name where the record will be stored.
                    F3 = (archivoFil2 + F1a)

                    with open(F2, 'w+', newline='') as archivo_csv:             # Each result is saved in the file, day, time and values of Shannon's entropy and averaged.
                        writer = csv.writer(archivo_csv)
                        writer.writerow(['Day', ' Hour', ' Shannon Entropy', ' Averaged Shannon Entropy', ' Kurtosis', ' Frequency Index'])

                        for dia in range(1, Diferencia + 1):                        # Save data by day and time according to the time interval (Start - End)
                            for hora in range(24):

                                writer.writerow([dia, hora, entropia_shannon[(dia - 1) * 24 + hora], entropia_promediada[(dia - 1) * 24 + hora], kurtosis_resultados[(dia - 1) * 24 + hora], frequency_index[(dia - 1) * 24 + hora] ])

                    # Use example
                    Y = entropia_shannon
                    Y = np.where(Y == 0, np.nan, Y)

                    Y1 = kurtosis_resultados
                    Y1 = np.where(Y1 == 0, np.nan, Y1)

                    Y2 = frequency_index
                    Y2 = np.where(Y2 == 0, np.nan, Y2)


                    # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                    # Graph 1 - ENTROPY BY POINTS.

                    if self.checkBox_2.isChecked():                                 # CheckBox 2 of the Initial Time is activated (This marks time on the x axis)

                        if not self.lineEdit_14.text():
                            MensCombo14 = QMessageBox()
                            MensCombo14.setIcon(QMessageBox.Warning)
                            MensCombo14.setWindowTitle("Empty Year value")
                            MensCombo14.setText("Please, enter a valid value")
                            returnValue = MensCombo14.exec()

                        elif not self.lineEdit_15.text():
                            MensCombo15 = QMessageBox()
                            MensCombo15.setIcon(QMessageBox.Warning)
                            MensCombo15.setWindowTitle("Empty Month value")
                            MensCombo15.setText("Please, enter a valid value")
                            returnValue = MensCombo15.exec()

                        elif not self.lineEdit_16.text():
                            MensCombo16 = QMessageBox()
                            MensCombo16.setIcon(QMessageBox.Warning)
                            MensCombo16.setWindowTitle("Empty Day value")
                            MensCombo16.setText("Please, enter a valid value")
                            returnValue = MensCombo16.exec()

                        else:

                            # Data entry for enveloped (this value is a string by default)
                            Anio = (self.lineEdit_14.text())                            # Reading the Year value label.
                            Mes = (self.lineEdit_15.text())                             # Reading the Month value label.
                            Dia1 = (self.lineEdit_16.text())                            # Reading the Day value label.

                            # Convert the string value of the input text boxes to  integer

                            Anio1=int(Anio)                                             # Converts the Year value to integer.
                            Mes1=int(Mes)                                               # Converts the Month value to integer.
                            Dia2=int(Dia1)                                              # Converts the NaN Day value to integer.

                            # The date vector is created
                            fecha_inicio = datetime(Anio1, Mes1, Dia2)
                            dias = [fecha_inicio + timedelta(hours=i) for i in range(len(entropia_shannon[indices_no_cero_shannon]))]

                            # "Indices_no_cero_shannon" = np.where(entropia_shannon != 0)[0]
                            st = (dias, entropia_shannon[indices_no_cero_shannon])
                            np.save(F3, st)  # Save the ".npy" file in the directory.
                            plt.close()

                            st = (dias, entropia_shannon[indices_no_cero_shannon])

                            # Save the ".npy" file in the directory.
                            np.save(F3, st)
                            plt.close()                                             # Close the existing chart.

                            # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                            # Graph 1 - ENTROPY BY POINTS.

                            plt.plot(dias, entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='ShannonEntropy: Points per hour -> 24 Hrs.')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_ShannonEntropy: Each point = 24 Hrs. with Lowpass filter', color ="darkgreen", fontsize=18)

                            # Graph 2 - Averaged Shannon Entropy Graph.

                            fig, ax = plt.subplots(1,1)
                            indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                            plt.plot(dias, entropia_promediada[indices_no_cero_promediada], "ob", mfc="b", mec = "b", label='ShannonAveragedEntropy: Points per hour -> 24 Hrs.')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Shannon Averaged Entropy: Each point = 24 Hrs. with Lowpass filter.', color ="darkgreen", fontsize=18)

                            # Graph 3 - Graph of Shannon Entropy with the envelope.

                            # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE.

                            fig, ax = plt.subplots(1,1)

                            y_filtered = nanfastsmooth(Y.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                            plt.plot(dias, entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='Shannon_Entropy')
                            plt.plot(dias, y_filtered[indices_no_cero_shannon], color='blue', label='Envelope')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Envelope - Shannon Entropy: Each point = 24 Hrs. with Lowpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            # Graph 4 - Envelope only graph.

                            fig, ax = plt.subplots(1,1)

                            plt.plot(dias, y_filtered[indices_no_cero_shannon], label='Filtered Signal', color='blue')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Only the envelope of Shannon entropy: Each point = 24 Hrs. with Lowpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                            # Graph 5 Frequency Index with enveloped
                            fig, ax = plt.subplots(1,1)

                            y_filtered3 = nanfastsmooth(Y2.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                            plt.plot(dias, frequency_index[indices_no_cero_frecuency], 'o-', label='Frequency Index')
                            plt.plot(dias, y_filtered3[indices_no_cero_frecuency], label='Envelope', color='red')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                            plt.title(Nombre3 + ' Frequency Index: Each point = 24 Hrs. with Lowpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            # Graph 6 Kurtosis with Envelope
                            fig, ax = plt.subplots(1,1)
                            indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]

                            # The date vector is created
                            fecha_inicio = datetime(Anio1, Mes1, Dia2)
                            dias2 = [fecha_inicio + timedelta(hours=i) for i in range(len(entropia_shannon[indices_no_cero_kurtosis]))]

                            y_filtered2 = nanfastsmooth(Y1.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                            plt.plot(dias2, kurtosis_resultados[indices_no_cero_kurtosis], 'o', label='Kurtosis')
                            plt.plot(dias2, y_filtered2[indices_no_cero_kurtosis], label='Envelope', color='red')
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                            plt.title(Nombre3 + ' Kurtosis: Each point = 24 Hrs. with Lowpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)

                            plt.show()

                    else:

                        # Plot the vectors into separate figures.
                        dias = np.arange(1, 8761 + 1)

                        st = (dias, entropia_shannon[indices_no_cero_shannon])

                        np.save(F3, st)  # Save the ".npy" file in the directory.
                        plt.close()

                        # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                        # Graph 1 - ENTROPY BY POINTS.

                        plt.plot(dias[indices_no_cero_shannon], entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='ShannonEntropy: Points per hour -> 24 Hrs.')

                        #plt.plot(dias, entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='ShannonEntropy: Points per hour -> 1 hr')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_ShannonEntropy: Each point = 24 Hrs. with Lowpass filter', color ="darkgreen", fontsize=18)
                        #plt.grid()

                        # Graph 2 - Averaged Shannon Entropy Graph.

                        fig, ax = plt.subplots(1,1)
                        indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                        plt.plot(dias[indices_no_cero_promediada], entropia_promediada[indices_no_cero_promediada], "ob", mfc="b", mec = "b", label='ShannonAveragedEntropy: Points per hour -> 24 Hrs.')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Shannon Averaged Entropy: Each point = 24 Hrs. with Lowpass filter.', color ="darkgreen", fontsize=18)

                        # Graph 3 - Graph of Shannon Entropy with the envelope.

                        # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE.

                        fig, ax = plt.subplots(1,1)

                        y_filtered = nanfastsmooth(Y.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                        plt.plot(dias[indices_no_cero_shannon], entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='Shannon Entropy')
                        plt.plot(dias[indices_no_cero_shannon], y_filtered[indices_no_cero_shannon], label='Envelope', color='blue')
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Envelope - Shannon Entropy: Each point = 24 Hrs. with Lowpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                        # Graph 4 - Envelope only graph.

                        fig, ax = plt.subplots(1,1)

                        plt.plot(dias[indices_no_cero_shannon], y_filtered[indices_no_cero_shannon], label='Filtered Signal', color='blue')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Only the envelope of Shannon entropy: Each point = 24 Hrs. with Lowpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                        # Graph 5 Frequency Index with Envelope
                        fig, ax = plt.subplots(1,1)

                        y_filtered3 = nanfastsmooth(Y2.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                        plt.plot(dias[indices_no_cero_frecuency], frequency_index[indices_no_cero_frecuency], 'o-', label='Frequency Index')
                        plt.plot(dias[indices_no_cero_frecuency], y_filtered3[indices_no_cero_frecuency], label='Envelope', color='red')
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                        plt.title(Nombre3 + ' Frequency Index: Each point = 24 Hrs. with Lowpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)

                        # Graph 6 Kurtosis with Envelope
                        fig, ax = plt.subplots(1,1)
                        indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]

                        y_filtered2 = nanfastsmooth(Y1.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                        plt.plot(dias[indices_no_cero_kurtosis], kurtosis_resultados[indices_no_cero_kurtosis], 'o', label='Kurtosis')
                        plt.plot(dias[indices_no_cero_kurtosis], y_filtered2[indices_no_cero_kurtosis], label='Envelope', color='red')
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                        plt.title(Nombre3 + ' Kurtosis: Each point = 24 Hrs. with Lowpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)

                        plt.show()

            else:                                           # Here the value of the entropy is calculated without the time interval (Start - End)

                if not self.label_5.text():
                    MensCombo1 = QMessageBox()
                    MensCombo1.setIcon(QMessageBox.Warning)
                    MensCombo1.setWindowTitle("Empty directory to upload records")
                    MensCombo1.setText("Please, enter a valid name of directory")
                    returnValue = MensCombo1.exec()

                elif not self.label_8.text():
                    MensCombo2 = QMessageBox()
                    MensCombo2.setIcon(QMessageBox.Warning)
                    MensCombo2.setWindowTitle("Empty path to store CSV/NPY file")
                    MensCombo2.setText("Please, enter a valid name of directory")
                    returnValue = MensCombo2.exec()

                elif not self.lineEdit_5.text():
                    MensCombo3 = QMessageBox()
                    MensCombo3.setIcon(QMessageBox.Warning)
                    MensCombo3.setWindowTitle("Empty Smoothing type")
                    MensCombo3.setText("Please, enter a valid Value")
                    returnValue = MensCombo3.exec()

                elif not self.lineEdit_6.text():
                    MensCombo4 = QMessageBox()
                    MensCombo4.setIcon(QMessageBox.Warning)
                    MensCombo4.setWindowTitle("Empty Frequency")
                    MensCombo4.setText("Please, enter a valid Value")
                    returnValue = MensCombo4.exec()

                elif not self.lineEdit_7.text():
                    MensCombo5 = QMessageBox()
                    MensCombo5.setIcon(QMessageBox.Warning)
                    MensCombo5.setWindowTitle("Empty Filter Order")
                    MensCombo5.setText("Please, enter a valid Value")
                    returnValue = MensCombo5.exec()

                elif not self.lineEdit_10.text():
                    MensCombo6 = QMessageBox()
                    MensCombo6.setIcon(QMessageBox.Warning)
                    MensCombo6.setWindowTitle("Empty Envelope Window size")
                    MensCombo6.setText("Please, enter a valid Value")
                    returnValue = MensCombo6.exec()

                elif not self.lineEdit_13.text():
                    MensCombo7 = QMessageBox()
                    MensCombo7.setIcon(QMessageBox.Warning)
                    MensCombo7.setWindowTitle("Empty NaN Tolerance")
                    MensCombo7.setText("Please, enter a valid Value")
                    returnValue = MensCombo7.exec()

                else:
                    # Filtering with a Lowpass 24 Hrs.
                    plt.close()                                                 # Close the existing chart.

                    carpeta = (self.label_5.text())                             # Reading the directory or file folder label.

                    # Code to detect the contents of the folder and the files that the folder contains
                    with os.scandir(carpeta) as ficheros:
                        ficheros4 = [fichero.name for fichero in ficheros if fichero.is_file()]

                    # The contents of the files in "ficheros4" is a list. This code converts them to string
                    lfiles = [str(elemento) for elemento in ficheros4]

                    # Code used to determine the name of the files contained in the folder and to be used in the loading loop
                    Iniciolfiles = lfiles[0]                                    # Detects the numeric value of the "Start" in the name
                    Finlfiles = lfiles[-1]                                      # Detects the numerical value of the "End" in the name
                    Indice1 = Iniciolfiles.rfind('.')                           # Determines the index, which will be marked by the dot at the end for the extension
                    Nombre3 = Iniciolfiles[0:Indice1]                           # Indicates the name of the file in str (minus) the index or extension (each day)

                    # Data entry from labels and fields or text boxes (this value is a string by default)
                    num_temporal_units = (self.lineEdit_5.text())               # label reading of the total number of daily files.
                    frec3 = (self.lineEdit_6.text())                            # reading frequency Label.
                    orden1 = (self.lineEdit_7.text())                           # Reading the Filter Order Label.

                    # Data entry for enveloped (this value is a string by default)
                    Tam = (self.lineEdit_10.text())                             # Reading the envelope window size label.
                    Tsua = (self.lineEdit_5.text())                             # Reading the Smoothing type label.
                    Tnan = (self.lineEdit_13.text())                            # Reading the NaN Tolerance label.

                    # Convert the string value of the input text boxes to float or integer
                    frec4=float(frec3)                                          # Converts Frequency value to float.
                    orden4=int(orden1)                                          # Converts filter order value to integer.

                    Tam1=int(Tam)                                               # Converts the envelope window size value to integer.
                    Tsua1=int(Tsua)                                             # Converts the Smoothing type value to integer.
                    Tnan1=int(Tnan)                                             # Converts the NaN Tolerance value to integer.

                    timeIn = 365

                    # Function for Shannon entropy calculating
                    def calcular_entropia(datos):
                        params = stats.norm.fit(datos)
                        dist = stats.norm(*params)
                        probabilidades = dist.pdf(datos)
                        entropia = -np.sum(probabilidades * np.log2(probabilidades))
                        return entropia

                     # Function for Kurtosis calculating
                    def calcular_kurtosis(datos):
                        n = len(datos)
                        media = np.mean(datos)
                        varianza = np.var(datos)
                        desviacion_estandar = np.sqrt(varianza)

                        if desviacion_estandar == 0:
                            return 0.0
                        kurtosis = np.sum((datos - media)**4) / (n * desviacion_estandar**4) - 3.0
                        return kurtosis

                    # Function for Shannon entropy enveloped calculating
                    def nanfastsmooth(Y, w, type=1, tol=0.5):

                        """
                        Smooths vector Y with a moving average of width w, ignoring NaNs in data.

                        Parameters:
                        Y (numpy array): Input signal.
                        w (int): Window width.
                        type (int): Smooth type (1 for rectangular, 2 for triangular, 3 for pseudo-Gaussian).
                        tol (float): Tolerance to NaNs between 0 and 1.

                        Returns:
                        numpy array: Smoothed signal.
                        """
                        mask = ~np.isnan(Y)  # Create a boolean mask for non-NaN values
                        Y[mask] = nanfastsmooth_core(Y[mask], w, type, tol)  # Apply smoothing to non-NaN values
                        return Y

                    # Function for Shannon entropy enveloped type calculating. For default the value = 3
                    def nanfastsmooth_core(Y, w, type, tol):
                        if type == 1:
                            SmoothY = moving_average(Y, w)
                        elif type == 2:
                            SmoothY = moving_average(moving_average(Y, w), w)
                        elif type == 3:
                            SmoothY = moving_average(moving_average(moving_average(Y, w), w), w)

                        return SmoothY

                    def moving_average(Y, window_size):
                        return np.convolve(Y, np.ones(window_size)/window_size, mode='same')

                    def calcular_indice_frecuencias(datos, frecuencia_muestreo):
                        # Frequency filter applied
                        freq_bajas = (1, 5.5)
                        freq_altas = (6, 16)

                        datos_bajas = apply_bandpass_filter(datos, frecuencia_muestreo, freq_bajas)
                        datos_altas = apply_bandpass_filter(datos, frecuencia_muestreo, freq_altas)

                        # The energy is calculated for each signal
                        energia_bajas = np.sum(datos_bajas ** 2)
                        energia_altas = np.sum(datos_altas ** 2)

                        # The frequency index is calculated
                        indice_frecuencias = np.log(energia_altas / energia_bajas) if energia_bajas != 0 else np.nan
                        return indice_frecuencias

                    def apply_bandpass_filter(datos, frecuencia_muestreo, freq_band):
                        nyquist = 0.5 * frecuencia_muestreo
                        normal_freq_band = np.array(freq_band) / nyquist
                        b, a = signal.butter(4, normal_freq_band, btype='band')
                        datos_filtrados = signal.filtfilt(b, a, datos)
                        return datos_filtrados

                    # Start entropy and averaged entropy values
                    entropia_shannon = []
                    entropia_promediada = []
                    kurtosis_resultados = []
                    frequency_index = []

                    # Cycle for the day-by-day calculation of the entropy in the files contained in the folder, using the time range (Start to End)
                    for dia in range(1, timeIn + 1):

                        archivo = Nombre3 + '.'+ f"{dia:003}"       # Here you select the name previously calculated plus point and the value of each Julian day

                        # If there is no file in the list, the entire day is added with a value of zero
                        if not os.path.exists(os.path.join(carpeta, archivo)):
                            for _ in range(24):  # Adds 24 hours with zero value if there is no file
                                entropia_shannon.append(0)
                                entropia_promediada.append(0)
                                kurtosis_resultados.append(0)
                                frequency_index.append(0)
                            continue

                        # Designation of the data contained in the folder files
                        st = Stream()
                        st += read(os.path.join(carpeta, archivo))
                        frecuencia_muestreo = st[0].stats.sampling_rate
                        # calculation of the lowpass filter with the parameters indicated by the user.
                        st.filter('lowpass', freq=frec4, corners=orden4, zerophase=True)
                        # Data value
                        datos = st[0].data

                        # Divide the data into hours and calculate entropy for each hour.
                        for hora in range(24):
                            inicio = hora * 1440  # start of time in seconds.
                            fin = inicio + 84600  # End of time in seconds.
                            datos_hora = datos[inicio:fin]

                            if len(datos_hora) < 86400:  # If the hour is incomplete, add zeros to the end.
                                datos_hora = np.append(datos_hora, np.zeros(86400 - len(datos_hora)))

                            # Accumulator of the calculated values of the Shannon entropy and the averaged entropy.
                            entropia_shannon.append(calcular_entropia(datos_hora))
                            entropia_promediada.append(calcular_entropia(datos_hora) / len(datos_hora))
                            kurtosis_resultados.append(calcular_kurtosis(datos_hora))
                            frequency_index.append(calcular_indice_frecuencias(datos_hora, frecuencia_muestreo))

                    # Converting shannon entropy value and averaged entropy to data array.
                    entropia_shannon = np.array(entropia_shannon)
                    entropia_promediada = np.array(entropia_promediada)
                    kurtosis_resultados = np.array(kurtosis_resultados)
                    frequency_index=np.array(frequency_index)

                    # Shannon Entropy Graph. Value of non-zero indices where there is no data.
                    indices_no_cero_shannon = np.where(entropia_shannon != 0)[0]

                    indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                    indices_no_cero_frecuency = np.where(frequency_index != 0)[0]

                    indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]


                    # **** SAVE THE RESULTS FILE .CSV
                    archivoFil2 = (self.label_8.text())                         # Reading directory label.

                    # **** SAVE THE RESULTS .npy FILE FOR LATER GRAPH *****
                    TW = str(Tam1)                                              # Convert Envelope Window value to string for names.
                    F1 = (Nombre3 + '_Lowpass_Filter_24_Hrs_without_Time_interval_Dots_and_Time' + '_Windows=' + TW + '.csv')            # Assign F1, Capture the name of the record and add the .csv extension.

                    # Guardar resultados en archivos .npy
                    F1a = (Nombre3 + '_Lowpass_Filter_24_Hrs_without_Time_interval_Dots_and_Time' + '_Windows=' + TW)
                    F2 = (archivoFil2 + F1)                                     # Assigns to F2 the directory plus the previous name where the record will be stored.
                    F3 = (archivoFil2 + F1a)

                    with open(F2, 'w+', newline='') as archivo_csv:             # Each result is saved in the file, day, time and values of Shannon's entropy and averaged.
                        writer = csv.writer(archivo_csv)
                        writer.writerow(['Day', ' hour', ' Shannon Entropy', ' Averaged Shannon Entropy', ' Envelope Shannon Entropy', ' Kurtosis', ' Frequency Index'])

                        for dia in range(1, timeIn + 1):                        # Save data by day and time according to the time interval (Start - End)
                            for hora in range(24):
                                writer.writerow([dia, hora, entropia_shannon[(dia - 1) * 24 + hora], entropia_promediada[(dia - 1) * 24 + hora], kurtosis_resultados[(dia - 1) * 24 + hora], frequency_index[(dia - 1) * 24 + hora] ])

                    # Use example
                    Y = entropia_shannon
                    Y = np.where(Y == 0, np.nan, Y)

                    Y1 = kurtosis_resultados
                    Y1 = np.where(Y1 == 0, np.nan, Y1)

                    Y2 = frequency_index
                    Y2 = np.where(Y2 == 0, np.nan, Y2)

                    # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                    # Graph 1 - ENTROPY BY POINTS.

                    if self.checkBox_2.isChecked():                                 # checkBox for Initial Time

                        if not self.lineEdit_14.text():
                            MensCombo14 = QMessageBox()
                            MensCombo14.setIcon(QMessageBox.Warning)
                            MensCombo14.setWindowTitle("Empty Year value")
                            MensCombo14.setText("Please, enter a valid value")
                            returnValue = MensCombo14.exec()

                        elif not self.lineEdit_15.text():
                            MensCombo15 = QMessageBox()
                            MensCombo15.setIcon(QMessageBox.Warning)
                            MensCombo15.setWindowTitle("Empty Month value")
                            MensCombo15.setText("Please, enter a valid value")
                            returnValue = MensCombo15.exec()

                        elif not self.lineEdit_16.text():
                            MensCombo16 = QMessageBox()
                            MensCombo16.setIcon(QMessageBox.Warning)
                            MensCombo16.setWindowTitle("Empty Day value")
                            MensCombo16.setText("Please, enter a valid value")
                            returnValue = MensCombo16.exec()

                        else:

                            # Data entry for enveloped (this value is a string by default)
                            Anio = (self.lineEdit_14.text())                            # Reading the Year value label.
                            Mes = (self.lineEdit_15.text())                             # Reading the Month value label.
                            Dia1 = (self.lineEdit_16.text())                            # Reading the Day value label.

                            # Convert the string value of the input text boxes to  integer

                            Anio1=int(Anio)                                             # Converts the Year value to integer.
                            Mes1=int(Mes)                                               # Converts the Month value to integer.
                            Dia2=int(Dia1)                                              # Converts the NaN Day value to integer.

                            # The date vector is created
                            fecha_inicio = datetime(Anio1, Mes1, Dia2)
                            dias = [fecha_inicio + timedelta(hours=i) for i in range(len(entropia_shannon[indices_no_cero_shannon]))]

                            st = (dias, entropia_shannon[indices_no_cero_shannon])

                            # Save the ".npy" file in the directory.
                            np.save(F3, st)
                            plt.close()                                             # Close the existing chart.

                            # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                            # Graph 1 - ENTROPY BY POINTS.

                            plt.plot(dias, entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='Shannon Entropy')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_ShannonEntropy: Each point = 24 Hrs. with Lowpass filter', color ="darkgreen", fontsize=18)

                            # Graph 2 - Averaged Shannon Entropy Graph.

                            fig, ax = plt.subplots(1,1)
                            indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                            plt.plot(dias, entropia_promediada[indices_no_cero_promediada], "ob", mfc="b", mec = "b", label='ShannonAveragedEntropy: Points per hour -> 24 Hrs.')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Shannon Averaged Entropy: Each point = 24 Hrs. with Lowpass filter.', color ="darkgreen", fontsize=18)

                            # Graph 3 - Graph of Shannon Entropy with the envelope.

                            # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE.

                            fig, ax = plt.subplots(1,1)

                            y_filtered = nanfastsmooth(Y.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                            plt.plot(dias, entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='Shannon Entropy')
                            plt.plot(dias, y_filtered[indices_no_cero_shannon], label='Envelope', color='blue')
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Envelope - Shannon Entropy: Each point = 24 Hrs. with Lowpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                            # Graph 4 - Envelope only graph.

                            fig, ax = plt.subplots(1,1)

                            plt.plot(dias, y_filtered[indices_no_cero_shannon], label='Filtered Signal', color='blue')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Only the envelope of Shannon entropy: Each point = 24 Hrs. with Lowpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                            # Graph 5 Frequency Index with Envelope
                            fig, ax = plt.subplots(1,1)

                            y_filtered3 = nanfastsmooth(Y2.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                            plt.plot(dias, frequency_index[indices_no_cero_frecuency], 'o-', label='Frequency Index')
                            plt.plot(dias, y_filtered3[indices_no_cero_frecuency], label='Envelope', color='red')
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                            plt.title(Nombre3 + ' Frequency Index: Each point = 24 Hrs. with Lowpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)

                            # Graph 6 Kurtosis with Envelope
                            fig, ax = plt.subplots(1,1)
                            indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]

                            # The date vector is created
                            fecha_inicio = datetime(Anio1, Mes1, Dia2)
                            dias2 = [fecha_inicio + timedelta(hours=i) for i in range(len(entropia_shannon[indices_no_cero_kurtosis]))]

                            y_filtered2 = nanfastsmooth(Y1.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                            plt.plot(dias2, kurtosis_resultados[indices_no_cero_kurtosis], 'o', label='Kurtosis')
                            plt.plot(dias2, y_filtered2[indices_no_cero_kurtosis], label='Envelope', color='red')
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                            plt.title(Nombre3 + ' Kurtosis: Each point = 24 Hrs. with Lowpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)

                            plt.show()

                    else:

                        # Plot the vectors into separate figures.
                        dias = np.arange(1, 8761 + 1)

                        st = (dias, entropia_shannon[indices_no_cero_shannon])

                        np.save(F3, st)  # Save the ".npy" file in the directory.
                        plt.close()

                        # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                        # Graph 1 - ENTROPY BY POINTS.

                        plt.plot(dias[indices_no_cero_shannon], entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='ShannonEntropy: Points per hour -> 24 Hrs.')

                        #plt.plot(dias, entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='ShannonEntropy: Points per hour -> 1 hr')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_ShannonEntropy: Each point = 24 Hrs. with Lowpass filter', color ="darkgreen", fontsize=18)
                        #plt.grid()

                        # Graph 2 - Averaged Shannon Entropy Graph.

                        fig, ax = plt.subplots(1,1)
                        indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                        plt.plot(dias[indices_no_cero_promediada], entropia_promediada[indices_no_cero_promediada], "ob", mfc="b", mec = "b", label='ShannonAveragedEntropy: Points per hour -> 24 Hrs.')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Shannon Averaged Entropy: Each point = 24 Hrs. with Lowpass filter.', color ="darkgreen", fontsize=18)

                        # Graph 3 - Graph of Shannon Entropy plus the envelope.

                        # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE.

                        fig, ax = plt.subplots(1,1)

                        y_filtered = nanfastsmooth(Y.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                        plt.plot(dias[indices_no_cero_shannon], entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='Shannon Entropy')
                        plt.plot(dias[indices_no_cero_shannon], y_filtered[indices_no_cero_shannon], label='Envelope', color='blue')
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Envelope - Shannon Entropy: Each point = 24 Hrs. with Lowpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                        # Graph 4 - Envelope only graph.

                        fig, ax = plt.subplots(1,1)

                        plt.plot(dias[indices_no_cero_shannon], y_filtered[indices_no_cero_shannon], label='Filtered Signal', color='blue')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Only the envelope of Shannon entropy: Each point = 24 Hrs. with Lowpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                        # Graph 5 Frequency Index with Envelope
                        fig, ax = plt.subplots(1,1)

                        y_filtered3 = nanfastsmooth(Y2.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                        plt.plot(dias[indices_no_cero_frecuency], frequency_index[indices_no_cero_frecuency], 'o-', label='Frequency Index')
                        plt.plot(dias[indices_no_cero_frecuency], y_filtered3[indices_no_cero_frecuency], label='Envelope', color='red')
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                        plt.title(Nombre3 + ' Frequency Index: Each point = 24 Hrs. with Lowpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)

                        # Graph 6 Kurtosis with Envelope
                        fig, ax = plt.subplots(1,1)
                        indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]

                        y_filtered2 = nanfastsmooth(Y1.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                        plt.plot(dias[indices_no_cero_kurtosis], kurtosis_resultados[indices_no_cero_kurtosis], 'o', label='Kurtosis')
                        plt.plot(dias[indices_no_cero_kurtosis], y_filtered2[indices_no_cero_kurtosis], label='Envelope', color='red')
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                        plt.title(Nombre3 + ' Kurtosis: Each point = 24 Hrs. with Lowpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)

                        plt.show()


        except:                         # In any other case of invalid or empty inputs
                plt.close()                                                 # Close the existing chart.
                msgBox = QMessageBox()
                msgBox.setIcon(QMessageBox.Warning)
                msgBox.setText("The File Does not exist, is Invalid or the CSV old file is open. Please close, try again ...")
                msgBox.setWindowTitle("Invalid Record inputs or CSV Old file is open ")
                returnValue = msgBox.exec()
                pass


    def filtropasoalto24hr(self):                                               # 10.- Function to execute the Highpass filter with 24 hr. analysis window.

        try:

            # Verifying that the checkbox is true. Work with time intervals.

            if self.checkBox.isChecked() == True:                      # CheckBox 1 of the time interval is activated

                # Verify (Validation), that the text box and label is not empty

                if not self.label_5.text():
                    MensCombo1 = QMessageBox()
                    MensCombo1.setIcon(QMessageBox.Warning)
                    MensCombo1.setWindowTitle("Empty directory to upload records")
                    MensCombo1.setText("Please, enter a valid name of directory")
                    returnValue = MensCombo1.exec()

                elif not self.label_8.text():
                    MensCombo2 = QMessageBox()
                    MensCombo2.setIcon(QMessageBox.Warning)
                    MensCombo2.setWindowTitle("Empty path to store CSV/NPY file")
                    MensCombo2.setText("Please, enter a valid name of directory")
                    returnValue = MensCombo2.exec()

                elif not self.lineEdit_5.text():
                    MensCombo3 = QMessageBox()
                    MensCombo3.setIcon(QMessageBox.Warning)
                    MensCombo3.setWindowTitle("Empty Smoothing type")
                    MensCombo3.setText("Please, enter a valid Value")
                    returnValue = MensCombo3.exec()

                elif not self.lineEdit_6.text():
                    MensCombo4 = QMessageBox()
                    MensCombo4.setIcon(QMessageBox.Warning)
                    MensCombo4.setWindowTitle("Empty Frequency")
                    MensCombo4.setText("Please, enter a valid Value")
                    returnValue = MensCombo4.exec()

                elif not self.lineEdit_7.text():
                    MensCombo5 = QMessageBox()
                    MensCombo5.setIcon(QMessageBox.Warning)
                    MensCombo5.setWindowTitle("Empty Filter Order")
                    MensCombo5.setText("Please, enter a valid Value")
                    returnValue = MensCombo5.exec()

                elif not self.lineEdit_10.text():
                    MensCombo6 = QMessageBox()
                    MensCombo6.setIcon(QMessageBox.Warning)
                    MensCombo6.setWindowTitle("Empty Envelope Window size")
                    MensCombo6.setText("Please, enter a valid Value")
                    returnValue = MensCombo6.exec()

                elif not self.lineEdit_11.text():
                    MensCombo7 = QMessageBox()
                    MensCombo7.setIcon(QMessageBox.Warning)
                    MensCombo7.setWindowTitle("Empty Start time")
                    MensCombo7.setText("Please, enter a valid Value")
                    returnValue = MensCombo7.exec()

                elif not self.lineEdit_12.text():
                    MensCombo8 = QMessageBox()
                    MensCombo8.setIcon(QMessageBox.Warning)
                    MensCombo8.setWindowTitle("Empty End time")
                    MensCombo8.setText("Please, enter a valid Value")
                    returnValue = MensCombo8.exec()

                elif not self.lineEdit_13.text():
                    MensCombo9 = QMessageBox()
                    MensCombo9.setIcon(QMessageBox.Warning)
                    MensCombo9.setWindowTitle("Empty NaN Tolerance")
                    MensCombo9.setText("Please, enter a valid Value")
                    returnValue = MensCombo9.exec()

                else:
                    # Filtering with a Highpass 24 Hrs.
                    plt.close()                                                 # Close the existing chart.

                    carpeta = (self.label_5.text())                             # Reading the directory or file folder label.

                    # Code to detect the contents of the folder and the files that the folder contains
                    with os.scandir(carpeta) as ficheros:
                        ficheros4 = [fichero.name for fichero in ficheros if fichero.is_file()]

                    # The contents of the files in "ficheros4" is a list. This code converts them to string
                    lfiles = [str(elemento) for elemento in ficheros4]

                    # Code used to determine the name of the files contained in the folder and to be used in the loading loop
                    Iniciolfiles = lfiles[0]                                    # Detects the numeric value of the "Start" in the name
                    Finlfiles = lfiles[-1]                                      # Detects the numerical value of the "End" in the name
                    Indice1 = Iniciolfiles.rfind('.')                           # Determines the index, which will be marked by the dot at the end for the extension
                    Nombre3 = Iniciolfiles[0:Indice1]                           # Indicates the name of the file in str (minus) the index or extension (each day)

                    # Data entry from labels and fields or text boxes (this value is a string by default)
                    frec3 = (self.lineEdit_6.text())                            # reading frequency Label.
                    orden1 = (self.lineEdit_7.text())                           # Reading the Filter Order Label.

                    # Data entry for enveloped (this value is a string by default)
                    Tam = (self.lineEdit_10.text())                             # Reading the envelope window size label.
                    Tsua = (self.lineEdit_5.text())                             # Reading the Smoothing type label.
                    Tnan = (self.lineEdit_13.text())                            # Reading the NaN Tolerance label.

                    Start1 = (self.lineEdit_11.text())                          # Star Time Size label reading.
                    End1 = (self.lineEdit_12.text())                            # End Time Size label reading.

                    # Convert the string value of the input text boxes to float or integer
                    frec4=float(frec3)                                          # Converts Frequency value to float.
                    orden4=int(orden1)                                          # Converts filter order value to integer.

                    Tam1=int(Tam)                                               # Converts the envelope window size value to integer.
                    Tsua1=int(Tsua)                                             # Converts the Smoothing type value to integer.
                    Tnan1=int(Tnan)                                             # Converts the NaN Tolerance value to integer.

                    timeIn = 365

                    Start2=int(Start1)                                          # Converts the Start time window size value to an integer.
                    End2=int(End1)                                              # Converts the End time window size value to an integer.

                    Diferencia = End2 - Start2                                  # Value of the difference between end and start to obtain the number of days to calculate

                    # Function for Shannon entropy calculating
                    def calcular_entropia(datos):
                        params = stats.norm.fit(datos)
                        dist = stats.norm(*params)
                        probabilidades = dist.pdf(datos)
                        entropia = -np.sum(probabilidades * np.log2(probabilidades))
                        return entropia

                     # Function for Kurtosis calculating
                    def calcular_kurtosis(datos):
                        n = len(datos)
                        media = np.mean(datos)
                        varianza = np.var(datos)
                        desviacion_estandar = np.sqrt(varianza)

                        if desviacion_estandar == 0:
                            return 0.0
                        kurtosis = np.sum((datos - media)**4) / (n * desviacion_estandar**4) - 3.0
                        return kurtosis

                    # Function for Shannon entropy enveloped calculating
                    def nanfastsmooth(Y, w, type=1, tol=0.5):

                        """
                        Smooths vector Y with a moving average of width w, ignoring NaNs in data.

                        Parameters:
                        Y (numpy array): Input signal.
                        w (int): Window width.
                        type (int): Smooth type (1 for rectangular, 2 for triangular, 3 for pseudo-Gaussian).
                        tol (float): Tolerance to NaNs between 0 and 1.

                        Returns:
                        numpy array: Smoothed signal.
                        """
                        mask = ~np.isnan(Y)  # Create a boolean mask for non-NaN values
                        Y[mask] = nanfastsmooth_core(Y[mask], w, type, tol)  # Apply smoothing to non-NaN values
                        return Y

                    # Function for Shannon entropy enveloped type calculating. For default the value = 3
                    def nanfastsmooth_core(Y, w, type, tol):
                        if type == 1:
                            SmoothY = moving_average(Y, w)
                        elif type == 2:
                            SmoothY = moving_average(moving_average(Y, w), w)
                        elif type == 3:
                            SmoothY = moving_average(moving_average(moving_average(Y, w), w), w)

                        return SmoothY

                    def moving_average(Y, window_size):
                        return np.convolve(Y, np.ones(window_size)/window_size, mode='same')

                    def calcular_indice_frecuencias(datos, frecuencia_muestreo):
                        # Frequency filter applied
                        freq_bajas = (1, 5.5)
                        freq_altas = (6, 16)

                        datos_bajas = apply_bandpass_filter(datos, frecuencia_muestreo, freq_bajas)
                        datos_altas = apply_bandpass_filter(datos, frecuencia_muestreo, freq_altas)

                        # The energy is calculated for each signal
                        energia_bajas = np.sum(datos_bajas ** 2)
                        energia_altas = np.sum(datos_altas ** 2)

                        # The frequency index is calculated
                        indice_frecuencias = np.log(energia_altas / energia_bajas) if energia_bajas != 0 else np.nan
                        return indice_frecuencias

                    def apply_bandpass_filter(datos, frecuencia_muestreo, freq_band):
                        nyquist = 0.5 * frecuencia_muestreo
                        normal_freq_band = np.array(freq_band) / nyquist
                        b, a = signal.butter(4, normal_freq_band, btype='band')
                        datos_filtrados = signal.filtfilt(b, a, datos)
                        return datos_filtrados

                    # Start entropy and averaged entropy values
                    entropia_shannon = []
                    entropia_promediada = []
                    kurtosis_resultados = []
                    frequency_index = []

                    # Cycle for the day-by-day calculation of the entropy in the files contained in the folder, using the time range (Start to End)
                    for dia in range(Start2, End2 + 1):

                        archivo = Nombre3 + '.'+ f"{dia:003}"       # Here you select the name previously calculated plus point and the value of each Julian day

                        # If there is no file in the list, the entire day is added with a value of zero
                        if not os.path.exists(os.path.join(carpeta, archivo)):
                            for _ in range(24):  # Adds 24 hours with zero value if there is no file
                                entropia_shannon.append(0)
                                entropia_promediada.append(0)
                                kurtosis_resultados.append(0)
                                frequency_index.append(0)
                            continue

                        # Designation of the data contained in the folder files
                        st = Stream()
                        st += read(os.path.join(carpeta, archivo))
                        frecuencia_muestreo = st[0].stats.sampling_rate
                        # calculation of the Highpass filter with the parameters indicated by the user.
                        st.filter('highpass', freq=frec4, corners=orden4, zerophase=True)
                        # Data value
                        datos = st[0].data

                        # Divide the data into hours and calculate entropy for each hour.
                        for hora in range(24):
                            inicio = hora * 1440  # start of time in seconds.
                            fin = inicio + 84600  # End of time in seconds.
                            datos_hora = datos[inicio:fin]

                            if len(datos_hora) < 86400:  # If the hour is incomplete, add zeros to the end.
                                datos_hora = np.append(datos_hora, np.zeros(86400 - len(datos_hora)))

                            # Accumulator of the calculated values of the Shannon entropy and the averaged entropy.
                            entropia_shannon.append(calcular_entropia(datos_hora))
                            entropia_promediada.append(calcular_entropia(datos_hora) / len(datos_hora))
                            kurtosis_resultados.append(calcular_kurtosis(datos_hora))
                            frequency_index.append(calcular_indice_frecuencias(datos_hora, frecuencia_muestreo))

                    # Converting shannon entropy value and averaged entropy to data array.
                    entropia_shannon = np.array(entropia_shannon)
                    entropia_promediada = np.array(entropia_promediada)
                    kurtosis_resultados = np.array(kurtosis_resultados)
                    frequency_index=np.array(frequency_index)

                    # Shannon Entropy Graph. Value of non-zero indices where there is no data.
                    indices_no_cero_shannon = np.where(entropia_shannon != 0)[0]

                    indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                    indices_no_cero_frecuency = np.where(frequency_index != 0)[0]

                    indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]

                    # **** SAVE THE RESULTS FILE .CSV
                    archivoFil2 = (self.label_8.text())                         # Reading directory label.

                    # **** SAVE THE RESULTS .npy FILE FOR LATER GRAPH *****
                    TW = str(Tam1)                                              # Convert Envelope Window value to string for names.
                    F1 = (Nombre3 + '_Highpass_Filter_24_Hrs_Time_interval_Dots_and_Time' + '_Windows=' + TW + '.csv')            # Assign F1, Capture the name of the record and add the .csv extension.

                    # Guardar resultados en archivos .npy
                    F1a = (Nombre3 + '_Highpass_Filter_24_Hrs_Time_interval_Dots_and_Time' + '_Windows=' + TW)
                    F2 = (archivoFil2 + F1)                                     # Assigns to F2 the directory plus the previous name where the record will be stored.
                    F3 = (archivoFil2 + F1a)

                    with open(F2, 'w+', newline='') as archivo_csv:             # Each result is saved in the file, day, time and values of Shannon's entropy and averaged.
                        writer = csv.writer(archivo_csv)
                        writer.writerow(['Day', ' Hour', ' Shannon Entropy', ' Averaged Shannon Entropy', ' Kurtosis', ' Frequency Index'])

                        for dia in range(1, Diferencia + 1):                        # Save data by day and time according to the time interval (Start - End)
                            for hora in range(24):

                                writer.writerow([dia, hora, entropia_shannon[(dia - 1) * 24 + hora], entropia_promediada[(dia - 1) * 24 + hora], kurtosis_resultados[(dia - 1) * 24 + hora], frequency_index[(dia - 1) * 24 + hora] ])

                    # Use example
                    Y = entropia_shannon
                    Y = np.where(Y == 0, np.nan, Y)

                    Y1 = kurtosis_resultados
                    Y1 = np.where(Y1 == 0, np.nan, Y1)

                    Y2 = frequency_index
                    Y2 = np.where(Y2 == 0, np.nan, Y2)

                    # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                    if self.checkBox_2.isChecked():                                 # CheckBox 2 of the Initial Time is activated (This marks time on the x axis)

                        if not self.lineEdit_14.text():
                            MensCombo14 = QMessageBox()
                            MensCombo14.setIcon(QMessageBox.Warning)
                            MensCombo14.setWindowTitle("Empty Year value")
                            MensCombo14.setText("Please, enter a valid value")
                            returnValue = MensCombo14.exec()

                        elif not self.lineEdit_15.text():
                            MensCombo15 = QMessageBox()
                            MensCombo15.setIcon(QMessageBox.Warning)
                            MensCombo15.setWindowTitle("Empty Month value")
                            MensCombo15.setText("Please, enter a valid value")
                            returnValue = MensCombo15.exec()

                        elif not self.lineEdit_16.text():
                            MensCombo16 = QMessageBox()
                            MensCombo16.setIcon(QMessageBox.Warning)
                            MensCombo16.setWindowTitle("Empty Day value")
                            MensCombo16.setText("Please, enter a valid value")
                            returnValue = MensCombo16.exec()

                        else:

                            # Data entry for enveloped (this value is a string by default)
                            Anio = (self.lineEdit_14.text())                            # Reading the Year value label.
                            Mes = (self.lineEdit_15.text())                             # Reading the Month value label.
                            Dia1 = (self.lineEdit_16.text())                            # Reading the Day value label.

                            # Convert the string value of the input text boxes to  integer

                            Anio1=int(Anio)                                             # Converts the Year value to integer.
                            Mes1=int(Mes)                                               # Converts the Month value to integer.
                            Dia2=int(Dia1)                                              # Converts the NaN Day value to integer.

                            # The date vector is created
                            fecha_inicio = datetime(Anio1, Mes1, Dia2)
                            dias = [fecha_inicio + timedelta(hours=i) for i in range(len(entropia_shannon[indices_no_cero_shannon]))]

                            # "Indices_no_cero_shannon" = np.where(entropia_shannon != 0)[0]
                            st = (dias, entropia_shannon[indices_no_cero_shannon])
                            np.save(F3, st)  # Save the ".npy" file in the directory.
                            plt.close()

                            st = (dias, entropia_shannon[indices_no_cero_shannon])

                            # Save the ".npy" file in the directory.
                            np.save(F3, st)
                            plt.close()                                             # Close the existing chart.

                            # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                            # Graph 1 - ENTROPY BY POINTS.

                            plt.plot(dias, entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='ShannonEntropy: Points per hour -> 24 Hrs.')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_ShannonEntropy: Each point = 24 Hrs. with Highpass filter', color ="darkgreen", fontsize=18)

                            # Graph 2 - Averaged Shannon Entropy Graph.

                            fig, ax = plt.subplots(1,1)
                            indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                            plt.plot(dias, entropia_promediada[indices_no_cero_promediada], "ob", mfc="b", mec = "b", label='ShannonAveragedEntropy: Points per hour -> 24 Hrs.')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Shannon Averaged Entropy: Each point = 24 Hrs. with Highpass filter.', color ="darkgreen", fontsize=18)

                            # Graph 3 - Graph of Shannon Entropy with the envelope.

                            # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE.

                            fig, ax = plt.subplots(1,1)

                            y_filtered = nanfastsmooth(Y.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                            plt.plot(dias, entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='Shannon_Entropy')
                            plt.plot(dias, y_filtered[indices_no_cero_shannon], color='blue', label='Envelope')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Envelope - Shannon Entropy: Each point = 24 Hrs. with Highpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            # Graph 4 - Envelope only graph.

                            fig, ax = plt.subplots(1,1)

                            plt.plot(dias, y_filtered[indices_no_cero_shannon], label='Filtered Signal', color='blue')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Only the envelope of Shannon entropy: Each point = 24 Hrs. with Highpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                            # Graph 5 Frequency Index with enveloped
                            fig, ax = plt.subplots(1,1)

                            y_filtered3 = nanfastsmooth(Y2.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                            plt.plot(dias, frequency_index[indices_no_cero_frecuency], 'o-', label='Frequency Index')
                            plt.plot(dias, y_filtered3[indices_no_cero_frecuency], label='Envelope', color='red')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                            plt.title(Nombre3 + ' Frequency Index: Each point = 24 Hrs. with Highpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            # Graph 6 Kurtosis with Envelope
                            fig, ax = plt.subplots(1,1)
                            indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]

                            # The date vector is created
                            fecha_inicio = datetime(Anio1, Mes1, Dia2)
                            dias2 = [fecha_inicio + timedelta(hours=i) for i in range(len(entropia_shannon[indices_no_cero_kurtosis]))]

                            y_filtered2 = nanfastsmooth(Y1.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                            plt.plot(dias2, kurtosis_resultados[indices_no_cero_kurtosis], 'o', label='Kurtosis')
                            plt.plot(dias2, y_filtered2[indices_no_cero_kurtosis], label='Envelope', color='red')
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                            plt.title(Nombre3 + ' Kurtosis: Each point = 24 Hrs. with Highpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)

                            plt.show()

                    else:

                        # Plot the vectors into separate figures.
                        dias = np.arange(1, 8761 + 1)

                        st = (dias, entropia_shannon[indices_no_cero_shannon])

                        np.save(F3, st)  # Save the ".npy" file in the directory.
                        plt.close()

                        # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                        # Graph 1 - ENTROPY BY POINTS.

                        plt.plot(dias[indices_no_cero_shannon], entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='ShannonEntropy: Points per hour -> 24 Hrs.')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_ShannonEntropy: Each point = 24 Hrs. with Highpass filter', color ="darkgreen", fontsize=18)

                        # Graph 2 - Averaged Shannon Entropy Graph.

                        fig, ax = plt.subplots(1,1)
                        indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                        plt.plot(dias[indices_no_cero_promediada], entropia_promediada[indices_no_cero_promediada], "ob", mfc="b", mec = "b", label='ShannonAveragedEntropy: Points per hour -> 24 Hrs.')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Shannon Averaged Entropy: Each point = 24 Hrs. with Highpass filter.', color ="darkgreen", fontsize=18)

                        # Graph 3 - Graph of Shannon Entropy with the envelope.

                        # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE.

                        fig, ax = plt.subplots(1,1)

                        y_filtered = nanfastsmooth(Y.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                        plt.plot(dias[indices_no_cero_shannon], entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='Shannon Entropy')
                        plt.plot(dias[indices_no_cero_shannon], y_filtered[indices_no_cero_shannon], label='Envelope', color='blue')
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Envelope - Shannon Entropy: Each point = 24 Hrs. with Highpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                        # Graph 4 - Envelope only graph.

                        fig, ax = plt.subplots(1,1)

                        plt.plot(dias[indices_no_cero_shannon], y_filtered[indices_no_cero_shannon], label='Filtered Signal', color='blue')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Only the envelope of Shannon entropy: Each point = 24 Hrs. with Highpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                        # Graph 5 Frequency Index with Envelope
                        fig, ax = plt.subplots(1,1)

                        y_filtered3 = nanfastsmooth(Y2.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                        plt.plot(dias[indices_no_cero_frecuency], frequency_index[indices_no_cero_frecuency], 'o-', label='Frequency Index')
                        plt.plot(dias[indices_no_cero_frecuency], y_filtered3[indices_no_cero_frecuency], label='Envelope', color='red')
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                        plt.title(Nombre3 + ' Frequency Index: Each point = 24 Hrs. with Highpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)

                        # Graph 6 Kurtosis with Envelope
                        fig, ax = plt.subplots(1,1)
                        indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]

                        y_filtered2 = nanfastsmooth(Y1.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                        plt.plot(dias[indices_no_cero_kurtosis], kurtosis_resultados[indices_no_cero_kurtosis], 'o', label='Kurtosis')
                        plt.plot(dias[indices_no_cero_kurtosis], y_filtered2[indices_no_cero_kurtosis], label='Envelope', color='red')
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                        plt.title(Nombre3 + ' Kurtosis: Each point = 24 Hrs. with Highpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)

                        plt.show()


            else:                                           # Here the value of the entropy is calculated without the time interval (Start - End)

                if not self.label_5.text():
                    MensCombo1 = QMessageBox()
                    MensCombo1.setIcon(QMessageBox.Warning)
                    MensCombo1.setWindowTitle("Empty directory to upload records")
                    MensCombo1.setText("Please, enter a valid name of directory")
                    returnValue = MensCombo1.exec()

                elif not self.label_8.text():
                    MensCombo2 = QMessageBox()
                    MensCombo2.setIcon(QMessageBox.Warning)
                    MensCombo2.setWindowTitle("Empty path to store CSV/NPY file")
                    MensCombo2.setText("Please, enter a valid name of directory")
                    returnValue = MensCombo2.exec()

                elif not self.lineEdit_5.text():
                    MensCombo3 = QMessageBox()
                    MensCombo3.setIcon(QMessageBox.Warning)
                    MensCombo3.setWindowTitle("Empty Smoothing type")
                    MensCombo3.setText("Please, enter a valid Value")
                    returnValue = MensCombo3.exec()

                elif not self.lineEdit_6.text():
                    MensCombo4 = QMessageBox()
                    MensCombo4.setIcon(QMessageBox.Warning)
                    MensCombo4.setWindowTitle("Empty Frequency")
                    MensCombo4.setText("Please, enter a valid Value")
                    returnValue = MensCombo4.exec()

                elif not self.lineEdit_7.text():
                    MensCombo5 = QMessageBox()
                    MensCombo5.setIcon(QMessageBox.Warning)
                    MensCombo5.setWindowTitle("Empty Filter Order")
                    MensCombo5.setText("Please, enter a valid Value")
                    returnValue = MensCombo5.exec()

                elif not self.lineEdit_10.text():
                    MensCombo6 = QMessageBox()
                    MensCombo6.setIcon(QMessageBox.Warning)
                    MensCombo6.setWindowTitle("Empty Envelope Window size")
                    MensCombo6.setText("Please, enter a valid Value")
                    returnValue = MensCombo6.exec()

                elif not self.lineEdit_13.text():
                    MensCombo7 = QMessageBox()
                    MensCombo7.setIcon(QMessageBox.Warning)
                    MensCombo7.setWindowTitle("Empty NaN Tolerance")
                    MensCombo7.setText("Please, enter a valid Value")
                    returnValue = MensCombo7.exec()

                else:
                    # Filtering with a Highpass 24 Hrs.
                    plt.close()                                                 # Close the existing chart.

                    carpeta = (self.label_5.text())                             # Reading the directory or file folder label.

                    # Code to detect the contents of the folder and the files that the folder contains
                    with os.scandir(carpeta) as ficheros:
                        ficheros4 = [fichero.name for fichero in ficheros if fichero.is_file()]

                    # The contents of the files in "ficheros4" is a list. This code converts them to string
                    lfiles = [str(elemento) for elemento in ficheros4]

                    # Code used to determine the name of the files contained in the folder and to be used in the loading loop
                    Iniciolfiles = lfiles[0]                                    # Detects the numeric value of the "Start" in the name
                    Finlfiles = lfiles[-1]                                      # Detects the numerical value of the "End" in the name
                    Indice1 = Iniciolfiles.rfind('.')                           # Determines the index, which will be marked by the dot at the end for the extension
                    Nombre3 = Iniciolfiles[0:Indice1]                           # Indicates the name of the file in str (minus) the index or extension (each day)

                    # Data entry from labels and fields or text boxes (this value is a string by default)
                    num_temporal_units = (self.lineEdit_5.text())               # label reading of the total number of daily files.
                    frec3 = (self.lineEdit_6.text())                            # reading frequency Label.
                    orden1 = (self.lineEdit_7.text())                           # Reading the Filter Order Label.

                    # Data entry for enveloped (this value is a string by default)
                    Tam = (self.lineEdit_10.text())                             # Reading the envelope window size label.
                    Tsua = (self.lineEdit_5.text())                             # Reading the Smoothing type label.
                    Tnan = (self.lineEdit_13.text())                            # Reading the NaN Tolerance label.

                    # Convert the string value of the input text boxes to float or integer
                    frec4=float(frec3)                                          # Converts Frequency value to float.
                    orden4=int(orden1)                                          # Converts filter order value to integer.

                    Tam1=int(Tam)                                               # Converts the envelope window size value to integer.
                    Tsua1=int(Tsua)                                             # Converts the Smoothing type value to integer.
                    Tnan1=int(Tnan)                                             # Converts the NaN Tolerance value to integer.

                    timeIn = 365

                    # Function for Shannon entropy calculating
                    def calcular_entropia(datos):
                        params = stats.norm.fit(datos)
                        dist = stats.norm(*params)
                        probabilidades = dist.pdf(datos)
                        entropia = -np.sum(probabilidades * np.log2(probabilidades))
                        return entropia

                     # Function for Kurtosis calculating
                    def calcular_kurtosis(datos):
                        n = len(datos)
                        media = np.mean(datos)
                        varianza = np.var(datos)
                        desviacion_estandar = np.sqrt(varianza)

                        if desviacion_estandar == 0:
                            return 0.0
                        kurtosis = np.sum((datos - media)**4) / (n * desviacion_estandar**4) - 3.0
                        return kurtosis

                    # Function for Shannon entropy enveloped calculating
                    def nanfastsmooth(Y, w, type=1, tol=0.5):

                        """
                        Smooths vector Y with a moving average of width w, ignoring NaNs in data.

                        Parameters:
                        Y (numpy array): Input signal.
                        w (int): Window width.
                        type (int): Smooth type (1 for rectangular, 2 for triangular, 3 for pseudo-Gaussian).
                        tol (float): Tolerance to NaNs between 0 and 1.

                        Returns:
                        numpy array: Smoothed signal.
                        """
                        mask = ~np.isnan(Y)  # Create a boolean mask for non-NaN values
                        Y[mask] = nanfastsmooth_core(Y[mask], w, type, tol)  # Apply smoothing to non-NaN values
                        return Y

                    # Function for Shannon entropy enveloped type calculating. For default the value = 3
                    def nanfastsmooth_core(Y, w, type, tol):
                        if type == 1:
                            SmoothY = moving_average(Y, w)
                        elif type == 2:
                            SmoothY = moving_average(moving_average(Y, w), w)
                        elif type == 3:
                            SmoothY = moving_average(moving_average(moving_average(Y, w), w), w)

                        return SmoothY

                    def moving_average(Y, window_size):
                        return np.convolve(Y, np.ones(window_size)/window_size, mode='same')

                    def calcular_indice_frecuencias(datos, frecuencia_muestreo):
                        # Frequency filter applied
                        freq_bajas = (1, 5.5)
                        freq_altas = (6, 16)

                        datos_bajas = apply_bandpass_filter(datos, frecuencia_muestreo, freq_bajas)
                        datos_altas = apply_bandpass_filter(datos, frecuencia_muestreo, freq_altas)

                        # The energy is calculated for each signal
                        energia_bajas = np.sum(datos_bajas ** 2)
                        energia_altas = np.sum(datos_altas ** 2)

                        # The frequency index is calculated
                        indice_frecuencias = np.log(energia_altas / energia_bajas) if energia_bajas != 0 else np.nan
                        return indice_frecuencias

                    def apply_bandpass_filter(datos, frecuencia_muestreo, freq_band):
                        nyquist = 0.5 * frecuencia_muestreo
                        normal_freq_band = np.array(freq_band) / nyquist
                        b, a = signal.butter(4, normal_freq_band, btype='band')
                        datos_filtrados = signal.filtfilt(b, a, datos)
                        return datos_filtrados

                    # Start entropy and averaged entropy values
                    entropia_shannon = []
                    entropia_promediada = []
                    kurtosis_resultados = []
                    frequency_index = []

                    # Cycle for the day-by-day calculation of the entropy in the files contained in the folder, using the time range (Start to End)
                    for dia in range(1, timeIn + 1):

                        archivo = Nombre3 + '.'+ f"{dia:003}"       # Here you select the name previously calculated plus point and the value of each Julian day

                        # If there is no file in the list, the entire day is added with a value of zero
                        if not os.path.exists(os.path.join(carpeta, archivo)):
                            for _ in range(24):  # Adds 24 hours with zero value if there is no file
                                entropia_shannon.append(0)
                                entropia_promediada.append(0)
                                kurtosis_resultados.append(0)
                                frequency_index.append(0)
                            continue

                        # Designation of the data contained in the folder files
                        st = Stream()
                        st += read(os.path.join(carpeta, archivo))
                        frecuencia_muestreo = st[0].stats.sampling_rate
                        # calculation of the Highpass filter with the parameters indicated by the user.
                        st.filter('highpass', freq=frec4, corners=orden4, zerophase=True)
                        # Data value
                        datos = st[0].data

                        # Divide the data into hours and calculate entropy for each hour.
                        for hora in range(24):
                            inicio = hora * 1440  # start of time in seconds.
                            fin = inicio + 84600  # End of time in seconds.
                            datos_hora = datos[inicio:fin]

                            if len(datos_hora) < 86400:  # If the hour is incomplete, add zeros to the end.
                                datos_hora = np.append(datos_hora, np.zeros(86400 - len(datos_hora)))

                            # Accumulator of the calculated values of the Shannon entropy and the averaged entropy.
                            entropia_shannon.append(calcular_entropia(datos_hora))
                            entropia_promediada.append(calcular_entropia(datos_hora) / len(datos_hora))
                            kurtosis_resultados.append(calcular_kurtosis(datos_hora))
                            frequency_index.append(calcular_indice_frecuencias(datos_hora, frecuencia_muestreo))

                    # Converting shannon entropy value and averaged entropy to data array.
                    entropia_shannon = np.array(entropia_shannon)
                    entropia_promediada = np.array(entropia_promediada)
                    kurtosis_resultados = np.array(kurtosis_resultados)
                    frequency_index=np.array(frequency_index)

                    # Shannon Entropy Graph. Value of non-zero indices where there is no data.
                    indices_no_cero_shannon = np.where(entropia_shannon != 0)[0]

                    indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                    indices_no_cero_frecuency = np.where(frequency_index != 0)[0]

                    indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]

                    # **** SAVE THE RESULTS FILE .CSV
                    archivoFil2 = (self.label_8.text())                         # Reading directory label.

                    # **** SAVE THE RESULTS .npy FILE FOR LATER GRAPH *****
                    TW = str(Tam1)                                              # Convert Envelope Window value to string for names.
                    F1 = (Nombre3 + '_Highpass_Filter_24_Hrs_without_Time_interval_Dots_and_Time' + '_Windows=' + TW + '.csv')            # Assign F1, Capture the name of the record and add the .csv extension.

                    # Guardar resultados en archivos .npy
                    F1a = (Nombre3 + '_Highpass_Filter_24_Hrs_without_Time_interval_Dots_and_Time' + '_Windows=' + TW)
                    F2 = (archivoFil2 + F1)                                     # Assigns to F2 the directory plus the previous name where the record will be stored.
                    F3 = (archivoFil2 + F1a)

                    with open(F2, 'w+', newline='') as archivo_csv:             # Each result is saved in the file, day, time and values of Shannon's entropy and averaged.
                        writer = csv.writer(archivo_csv)
                        writer.writerow(['Day', ' hour', ' Shannon Entropy', ' Averaged Shannon Entropy', ' Envelope Shannon Entropy', ' Kurtosis', ' Frequency Index'])

                        for dia in range(1, timeIn + 1):                        # Save data by day and time according to the time interval (Start - End)
                            for hora in range(24):
                                writer.writerow([dia, hora, entropia_shannon[(dia - 1) * 24 + hora], entropia_promediada[(dia - 1) * 24 + hora], kurtosis_resultados[(dia - 1) * 24 + hora], frequency_index[(dia - 1) * 24 + hora] ])

                    # Use example
                    Y = entropia_shannon
                    Y = np.where(Y == 0, np.nan, Y)

                    Y1 = kurtosis_resultados
                    Y1 = np.where(Y1 == 0, np.nan, Y1)

                    Y2 = frequency_index
                    Y2 = np.where(Y2 == 0, np.nan, Y2)

                    # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                    # Graph 1 - ENTROPY BY POINTS.

                    if self.checkBox_2.isChecked():                                 # checkBox for Initial Time

                        if not self.lineEdit_14.text():
                            MensCombo14 = QMessageBox()
                            MensCombo14.setIcon(QMessageBox.Warning)
                            MensCombo14.setWindowTitle("Empty Year value")
                            MensCombo14.setText("Please, enter a valid value")
                            returnValue = MensCombo14.exec()

                        elif not self.lineEdit_15.text():
                            MensCombo15 = QMessageBox()
                            MensCombo15.setIcon(QMessageBox.Warning)
                            MensCombo15.setWindowTitle("Empty Month value")
                            MensCombo15.setText("Please, enter a valid value")
                            returnValue = MensCombo15.exec()

                        elif not self.lineEdit_16.text():
                            MensCombo16 = QMessageBox()
                            MensCombo16.setIcon(QMessageBox.Warning)
                            MensCombo16.setWindowTitle("Empty Day value")
                            MensCombo16.setText("Please, enter a valid value")
                            returnValue = MensCombo16.exec()

                        else:

                            # Data entry for enveloped (this value is a string by default)
                            Anio = (self.lineEdit_14.text())                            # Reading the Year value label.
                            Mes = (self.lineEdit_15.text())                             # Reading the Month value label.
                            Dia1 = (self.lineEdit_16.text())                            # Reading the Day value label.

                            # Convert the string value of the input text boxes to  integer

                            Anio1=int(Anio)                                             # Converts the Year value to integer.
                            Mes1=int(Mes)                                               # Converts the Month value to integer.
                            Dia2=int(Dia1)                                              # Converts the NaN Day value to integer.

                            # The date vector is created
                            fecha_inicio = datetime(Anio1, Mes1, Dia2)
                            dias = [fecha_inicio + timedelta(hours=i) for i in range(len(entropia_shannon[indices_no_cero_shannon]))]

                            st = (dias, entropia_shannon[indices_no_cero_shannon])

                            # Save the ".npy" file in the directory.
                            np.save(F3, st)
                            plt.close()                                             # Close the existing chart.

                            # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                            # Graph 1 - ENTROPY BY POINTS.

                            plt.plot(dias, entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='Shannon Entropy')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_ShannonEntropy: Each point = 24 Hrs. with Highpass filter', color ="darkgreen", fontsize=18)

                            # Graph 2 - Averaged Shannon Entropy Graph.

                            fig, ax = plt.subplots(1,1)
                            indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                            plt.plot(dias, entropia_promediada[indices_no_cero_promediada], "ob", mfc="b", mec = "b", label='ShannonAveragedEntropy: Points per hour -> 24 Hrs.')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Shannon Averaged Entropy: Each point = 24 Hrs. with Highpass filter.', color ="darkgreen", fontsize=18)

                            # Graph 3 - Graph of Shannon Entropy with the envelope.

                            # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE.

                            fig, ax = plt.subplots(1,1)

                            y_filtered = nanfastsmooth(Y.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                            plt.plot(dias, entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='Shannon Entropy')
                            plt.plot(dias, y_filtered[indices_no_cero_shannon], label='Envelope', color='blue')
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Envelope - Shannon Entropy: Each point = 24 Hrs. with Highpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                            # Graph 4 - Envelope only graph.

                            fig, ax = plt.subplots(1,1)

                            plt.plot(dias, y_filtered[indices_no_cero_shannon], label='Filtered Signal', color='blue')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Only the envelope of Shannon entropy: Each point = 24 Hrs. with Highpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                            # Graph 5 Frequency Index with Envelope
                            fig, ax = plt.subplots(1,1)

                            y_filtered3 = nanfastsmooth(Y2.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                            plt.plot(dias, frequency_index[indices_no_cero_frecuency], 'o-', label='Frequency Index')
                            plt.plot(dias, y_filtered3[indices_no_cero_frecuency], label='Envelope', color='red')
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                            plt.title(Nombre3 + ' Frequency Index: Each point = 24 Hrs. with Highpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)

                            # Graph 6 Kurtosis with Envelope
                            fig, ax = plt.subplots(1,1)
                            indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]

                            # The date vector is created
                            fecha_inicio = datetime(Anio1, Mes1, Dia2)
                            dias2 = [fecha_inicio + timedelta(hours=i) for i in range(len(entropia_shannon[indices_no_cero_kurtosis]))]

                            y_filtered2 = nanfastsmooth(Y1.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                            plt.plot(dias2, kurtosis_resultados[indices_no_cero_kurtosis], 'o', label='Kurtosis')
                            plt.plot(dias2, y_filtered2[indices_no_cero_kurtosis], label='Envelope', color='red')
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                            plt.title(Nombre3 + ' Kurtosis: Each point = 24 Hrs. with Highpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)

                            plt.show()

                    else:

                        # Plot the vectors into separate figures.
                        dias = np.arange(1, 8761 + 1)

                        st = (dias, entropia_shannon[indices_no_cero_shannon])

                        np.save(F3, st)  # Save the ".npy" file in the directory.
                        plt.close()

                        # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                        # Graph 1 - ENTROPY BY POINTS.

                        plt.plot(dias[indices_no_cero_shannon], entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='ShannonEntropy: Points per hour -> 24 Hrs.')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_ShannonEntropy: Each point = 24 Hrs. with Highpass filter', color ="darkgreen", fontsize=18)

                        # Graph 2 - Averaged Shannon Entropy Graph.

                        fig, ax = plt.subplots(1,1)
                        indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                        plt.plot(dias[indices_no_cero_promediada], entropia_promediada[indices_no_cero_promediada], "ob", mfc="b", mec = "b", label='ShannonAveragedEntropy: Points per hour -> 24 Hrs.')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Shannon Averaged Entropy: Each point = 24 Hrs. with Highpass filter.', color ="darkgreen", fontsize=18)

                        # Graph 3 - Graph of Shannon Entropy plus the envelope.

                        # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE.

                        fig, ax = plt.subplots(1,1)

                        y_filtered = nanfastsmooth(Y.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                        plt.plot(dias[indices_no_cero_shannon], entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='Shannon Entropy')
                        plt.plot(dias[indices_no_cero_shannon], y_filtered[indices_no_cero_shannon], label='Envelope', color='blue')
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Envelope - Shannon Entropy: Each point = 24 Hrs. with Highpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                        # Graph 4 - Envelope only graph.

                        fig, ax = plt.subplots(1,1)

                        plt.plot(dias[indices_no_cero_shannon], y_filtered[indices_no_cero_shannon], label='Filtered Signal', color='blue')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Only the envelope of Shannon entropy: Each point = 24 Hrs. with Highpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                        # Graph 5 Frequency Index with Envelope
                        fig, ax = plt.subplots(1,1)

                        y_filtered3 = nanfastsmooth(Y2.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                        plt.plot(dias[indices_no_cero_frecuency], frequency_index[indices_no_cero_frecuency], 'o-', label='Frequency Index')
                        plt.plot(dias[indices_no_cero_frecuency], y_filtered3[indices_no_cero_frecuency], label='Envelope', color='red')
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                        plt.title(Nombre3 + ' Frequency Index: Each point = 24 Hrs. with Highpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)

                        # Graph 6 Kurtosis with Envelope
                        fig, ax = plt.subplots(1,1)
                        indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]

                        y_filtered2 = nanfastsmooth(Y1.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                        plt.plot(dias[indices_no_cero_kurtosis], kurtosis_resultados[indices_no_cero_kurtosis], 'o', label='Kurtosis')
                        plt.plot(dias[indices_no_cero_kurtosis], y_filtered2[indices_no_cero_kurtosis], label='Envelope', color='red')
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                        plt.title(Nombre3 + ' Kurtosis: Each point = 24 Hrs. with Highpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)

                        plt.show()


        except:                         # In any other case of invalid or empty inputs
                plt.close()                                                 # Close the existing chart.
                msgBox = QMessageBox()
                msgBox.setIcon(QMessageBox.Warning)
                msgBox.setText("The File Does not exist, is Invalid or the CSV old file is open. Please close, try again ...")
                msgBox.setWindowTitle("Invalid Record inputs or CSV Old file is open ")
                returnValue = msgBox.exec()
                pass



    def filtropasabanda24hr(self):                                               # 11.- Function to execute the Bandpass filter with 24 hr. analysis window.

        try:

            # Verifying that the checkbox is true. Work with time intervals.

            if self.checkBox.isChecked() == True:

                # Verify (Validation), that the text box and label is not empty

                if not self.label_5.text():
                    MensCombo1 = QMessageBox()
                    MensCombo1.setIcon(QMessageBox.Warning)
                    MensCombo1.setWindowTitle("Empty directory to upload records")
                    MensCombo1.setText("Please, enter a valid name of directory")
                    returnValue = MensCombo1.exec()

                elif not self.label_8.text():
                    MensCombo2 = QMessageBox()
                    MensCombo2.setIcon(QMessageBox.Warning)
                    MensCombo2.setWindowTitle("Empty path to store CSV/NPY file")
                    MensCombo2.setText("Please, enter a valid name of directory")
                    returnValue = MensCombo2.exec()

                elif not self.lineEdit_5.text():
                    MensCombo3 = QMessageBox()
                    MensCombo3.setIcon(QMessageBox.Warning)
                    MensCombo3.setWindowTitle("Empty Smoothing type")
                    MensCombo3.setText("Please, enter a valid Value")
                    returnValue = MensCombo3.exec()

                elif not self.lineEdit_7.text():
                    MensCombo4 = QMessageBox()
                    MensCombo4.setIcon(QMessageBox.Warning)
                    MensCombo4.setWindowTitle("Empty Filter Order")
                    MensCombo4.setText("Please, enter a valid Value")
                    returnValue = MensCombo4.exec()

                elif not self.lineEdit_8.text():
                    MensCombo5 = QMessageBox()
                    MensCombo5.setIcon(QMessageBox.Warning)
                    MensCombo5.setWindowTitle("Empty Min. Frequency")
                    MensCombo5.setText("Please, enter a valid Value")
                    returnValue = MensCombo5.exec()

                elif not self.lineEdit_9.text():
                    MensCombo6 = QMessageBox()
                    MensCombo6.setIcon(QMessageBox.Warning)
                    MensCombo6.setWindowTitle("Empty Max. Frequency")
                    MensCombo6.setText("Please, enter a valid Value")
                    returnValue = MensCombo6.exec()

                elif not self.lineEdit_10.text():
                    MensCombo7 = QMessageBox()
                    MensCombo7.setIcon(QMessageBox.Warning)
                    MensCombo7.setWindowTitle("Empty Envelope Window size")
                    MensCombo7.setText("Please, enter a valid Value")
                    returnValue = MensCombo7.exec()

                elif not self.lineEdit_11.text():
                    MensCombo8 = QMessageBox()
                    MensCombo8.setIcon(QMessageBox.Warning)
                    MensCombo8.setWindowTitle("Empty Start time")
                    MensCombo8.setText("Please, enter a valid Value")
                    returnValue = MensCombo8.exec()

                elif not self.lineEdit_12.text():
                    MensCombo9 = QMessageBox()
                    MensCombo9.setIcon(QMessageBox.Warning)
                    MensCombo9.setWindowTitle("Empty End time")
                    MensCombo9.setText("Please, enter a valid Value")
                    returnValue = MensCombo9.exec()

                elif not self.lineEdit_13.text():
                    MensCombo10 = QMessageBox()
                    MensCombo10.setIcon(QMessageBox.Warning)
                    MensCombo10.setWindowTitle("Empty NaN Tolerance")
                    MensCombo10.setText("Please, enter a valid Value")
                    returnValue = MensCombo10.exec()

                else:
                    # Filtering with a Bandpass 24 Hrs.
                    plt.close()                                                 # Close the existing chart.

                    carpeta = (self.label_5.text())                             # Reading the directory or file folder label.

                    # Code to detect the contents of the folder and the files that the folder contains
                    with os.scandir(carpeta) as ficheros:
                        ficheros4 = [fichero.name for fichero in ficheros if fichero.is_file()]

                    # The contents of the files in "ficheros4" is a list. This code converts them to string
                    lfiles = [str(elemento) for elemento in ficheros4]

                    # Code used to determine the name of the files contained in the folder and to be used in the loading loop
                    Iniciolfiles = lfiles[0]                                    # Detects the numeric value of the "Start" in the name
                    Finlfiles = lfiles[-1]                                      # Detects the numerical value of the "End" in the name
                    Indice1 = Iniciolfiles.rfind('.')                           # Determines the index, which will be marked by the dot at the end for the extension
                    Nombre3 = Iniciolfiles[0:Indice1]                           # Indicates the name of the file in str (minus) the index or extension (each day)

                    # Data entry from labels and fields or text boxes (this value is a string by default)

                    frecMin = (self.lineEdit_8.text())                          # Minimum Frequency label reading.
                    frecMax = (self.lineEdit_9.text())                          # Maximum Frequency label reading.
                    orden1 = (self.lineEdit_7.text())                           # Reading the Filter Order Label.

                    Start1 = (self.lineEdit_11.text())                          # Star Time Size label reading.
                    End1 = (self.lineEdit_12.text())                            # End Time Size label reading.

                    # Convert the string value of the input text boxes to float or integer
                    frec7=float(frecMin)                                        # Converts the Minimum Frequency value to float.
                    frec8=float(frecMax)                                        # Converts the Maximum Frequency value to float.
                    orden7=int(orden1)                                          # Converts filter order value to integer.

                     # Data entry for enveloped (this value is a string by default)
                    Tam = (self.lineEdit_10.text())                             # Reading the envelope window size label.
                    Tsua = (self.lineEdit_5.text())                             # Reading the Smoothing type label.
                    Tnan = (self.lineEdit_13.text())                            # Reading the NaN Tolerance label.

                    Tam1=int(Tam)                                               # Converts the envelope window size value to integer.
                    Tsua1=int(Tsua)                                             # Converts the Smoothing type value to integer.
                    Tnan1=int(Tnan)                                             # Converts the NaN Tolerance value to integer.

                    timeIn = 365

                    Start2=int(Start1)                                          # Converts the Start time window size value to an integer.
                    End2=int(End1)                                              # Converts the End time window size value to an integer.

                    Diferencia = End2 - Start2                                  # Value of the difference between end and start to obtain the number of days to calculate

                    # Function for Shannon entropy calculating
                    def calcular_entropia(datos):
                        params = stats.norm.fit(datos)
                        dist = stats.norm(*params)
                        probabilidades = dist.pdf(datos)
                        entropia = -np.sum(probabilidades * np.log2(probabilidades))
                        return entropia

                    # Function for Kurtosis calculating
                    def calcular_kurtosis(datos):
                        n = len(datos)
                        media = np.mean(datos)
                        varianza = np.var(datos)
                        desviacion_estandar = np.sqrt(varianza)

                        if desviacion_estandar == 0:
                            return 0.0
                        kurtosis = np.sum((datos - media)**4) / (n * desviacion_estandar**4) - 3.0
                        return kurtosis

                    # Function for Shannon entropy enveloped calculating
                    def nanfastsmooth(Y, w, type=1, tol=0.5):

                        """
                        Smooths vector Y with a moving average of width w, ignoring NaNs in data.

                        Parameters:
                        Y (numpy array): Input signal.
                        w (int): Window width.
                        type (int): Smooth type (1 for rectangular, 2 for triangular, 3 for pseudo-Gaussian).
                        tol (float): Tolerance to NaNs between 0 and 1.

                        Returns:
                        numpy array: Smoothed signal.
                        """
                        mask = ~np.isnan(Y)  # Create a boolean mask for non-NaN values
                        Y[mask] = nanfastsmooth_core(Y[mask], w, type, tol)  # Apply smoothing to non-NaN values
                        return Y

                    # Function for Shannon entropy enveloped type calculating. For default the value = 3
                    def nanfastsmooth_core(Y, w, type, tol):
                        if type == 1:
                            SmoothY = moving_average(Y, w)
                        elif type == 2:
                            SmoothY = moving_average(moving_average(Y, w), w)
                        elif type == 3:
                            SmoothY = moving_average(moving_average(moving_average(Y, w), w), w)

                        return SmoothY

                    def moving_average(Y, window_size):
                        return np.convolve(Y, np.ones(window_size)/window_size, mode='same')

                    def calcular_indice_frecuencias(datos, frecuencia_muestreo):
                        # Aplicar filtro en frecuencia
                        freq_bajas = (1, 5.5)
                        freq_altas = (6, 16)

                        datos_bajas = apply_bandpass_filter(datos, frecuencia_muestreo, freq_bajas)
                        datos_altas = apply_bandpass_filter(datos, frecuencia_muestreo, freq_altas)

                        # Calcular energía para cada señal
                        energia_bajas = np.sum(datos_bajas ** 2)
                        energia_altas = np.sum(datos_altas ** 2)

                        # Calcular índice de frecuencias
                        indice_frecuencias = np.log(energia_altas / energia_bajas) if energia_bajas != 0 else np.nan
                        return indice_frecuencias

                    def apply_bandpass_filter(datos, frecuencia_muestreo, freq_band):
                        nyquist = 0.5 * frecuencia_muestreo
                        normal_freq_band = np.array(freq_band) / nyquist
                        b, a = signal.butter(4, normal_freq_band, btype='band')
                        datos_filtrados = signal.filtfilt(b, a, datos)
                        return datos_filtrados

                    # Start entropy and averaged entropy values
                    entropia_shannon = []
                    entropia_promediada = []
                    kurtosis_resultados = []
                    frequency_index = []

                    # Cycle for the day-by-day calculation of the entropy in the files contained in the folder, using the time range (Start to End)
                    for dia in range(Start2, End2 + 1):

                        archivo = Nombre3 + '.'+ f"{dia:003}"       # Here you select the name previously calculated plus point and the value of each Julian day

                        # If there is no file in the list, the entire day is added with a value of zero
                        if not os.path.exists(os.path.join(carpeta, archivo)):
                            for _ in range(24):  # Adds 24 hours with zero value if there is no file
                                entropia_shannon.append(0)
                                entropia_promediada.append(0)
                                kurtosis_resultados.append(0)
                                frequency_index.append(0)
                            continue

                        # Designation of the data contained in the folder files
                        st = Stream()
                        st += read(os.path.join(carpeta, archivo))
                        frecuencia_muestreo = st[0].stats.sampling_rate
                        # calculation of the Bandpass filter with the parameters indicated by the user.
                        st.filter('bandpass', freqmin=frec7, freqmax=frec8, corners=orden7, zerophase=True)
                        # Data value
                        datos = st[0].data

                        # Divide the data into hours and calculate entropy for each hour.
                        for hora in range(24):
                            inicio = hora * 1440  # start of time in seconds.
                            fin = inicio + 84600  # End of time in seconds.
                            datos_hora = datos[inicio:fin]

                            if len(datos_hora) < 86400:  # If the hour is incomplete, add zeros to the end.
                                datos_hora = np.append(datos_hora, np.zeros(86400 - len(datos_hora)))

                            # Accumulator of the calculated values of the Shannon entropy and the averaged entropy.
                            entropia_shannon.append(calcular_entropia(datos_hora))
                            entropia_promediada.append(calcular_entropia(datos_hora) / len(datos_hora))
                            kurtosis_resultados.append(calcular_kurtosis(datos_hora))
                            frequency_index.append(calcular_indice_frecuencias(datos_hora, frecuencia_muestreo))

                    # Converting shannon entropy value and averaged entropy to data array.
                    entropia_shannon = np.array(entropia_shannon)
                    entropia_promediada = np.array(entropia_promediada)
                    kurtosis_resultados = np.array(kurtosis_resultados)
                    frequency_index=np.array(frequency_index)

                    # Shannon Entropy Graph. Value of non-zero indices where there is no data.
                    indices_no_cero_shannon = np.where(entropia_shannon != 0)[0]

                    indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                    indices_no_cero_frecuency = np.where(frequency_index != 0)[0]

                    indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]

                    # **** SAVE THE RESULTS FILE .CSV
                    archivoFil2 = (self.label_8.text())                         # Reading directory label.

                    # **** SAVE THE RESULTS .npy FILE FOR LATER GRAPH *****
                    TW = str(Tam1)                                              # Convert Envelope Window value to string for names.
                    F1 = (Nombre3 + '_Bandpass_Filter_24_Hrs_Time_interval_Dots_and_Time' + '_Windows=' + TW + '.csv')            # Assign F1, Capture the name of the record and add the .csv extension.

                    # Guardar resultados en archivos .npy
                    F1a = (Nombre3 + '_Bandpass_Filter_24_Hrs_Time_interval_Dots_and_Time' + '_Windows=' + TW)
                    F2 = (archivoFil2 + F1)                                     # Assigns to F2 the directory plus the previous name where the record will be stored.
                    F3 = (archivoFil2 + F1a)

                    with open(F2, 'w+', newline='') as archivo_csv:             # Each result is saved in the file, day, time and values of Shannon's entropy and averaged.
                        writer = csv.writer(archivo_csv)
                        writer.writerow(['Day', ' hour', ' Shannon Entropy', ' Averaged Shannon Entropy', ' Enveloped Shannon Entropy', ' Kurtosis', ' Frequency Index'])

                        for dia in range(1, Diferencia + 1):                        # Save data by day and time according to the time interval (Start - End)
                            for hora in range(24):

                                writer.writerow([dia, hora, entropia_shannon[(dia - 1) * 24 + hora], entropia_promediada[(dia - 1) * 24 + hora], kurtosis_resultados[(dia - 1) * 24 + hora], frequency_index[(dia - 1) * 24 + hora] ])

                    # Use example
                    Y = entropia_shannon
                    Y = np.where(Y == 0, np.nan, Y)

                    Y1 = kurtosis_resultados
                    Y1 = np.where(Y1 == 0, np.nan, Y1)

                    Y2 = frequency_index
                    Y2 = np.where(Y2 == 0, np.nan, Y2)                                             # Close the existing chart.

                    # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                    # Graph 1 - ENTROPY BY POINTS.

                    if self.checkBox_2.isChecked():                                 # CheckBox 2 of the Initial Time is activated (This marks time on the x axis)

                        if not self.lineEdit_14.text():
                            MensCombo14 = QMessageBox()
                            MensCombo14.setIcon(QMessageBox.Warning)
                            MensCombo14.setWindowTitle("Empty Year value")
                            MensCombo14.setText("Please, enter a valid value")
                            returnValue = MensCombo14.exec()

                        elif not self.lineEdit_15.text():
                            MensCombo15 = QMessageBox()
                            MensCombo15.setIcon(QMessageBox.Warning)
                            MensCombo15.setWindowTitle("Empty Month value")
                            MensCombo15.setText("Please, enter a valid value")
                            returnValue = MensCombo15.exec()

                        elif not self.lineEdit_16.text():
                            MensCombo16 = QMessageBox()
                            MensCombo16.setIcon(QMessageBox.Warning)
                            MensCombo16.setWindowTitle("Empty Day value")
                            MensCombo16.setText("Please, enter a valid value")
                            returnValue = MensCombo16.exec()

                        else:

                            # Data entry for enveloped (this value is a string by default)
                            Anio = (self.lineEdit_14.text())                            # Reading the Year value label.
                            Mes = (self.lineEdit_15.text())                             # Reading the Month value label.
                            Dia1 = (self.lineEdit_16.text())                            # Reading the Day value label.

                            # Convert the string value of the input text boxes to  integer

                            Anio1=int(Anio)                                             # Converts the Year value to integer.
                            Mes1=int(Mes)                                               # Converts the Month value to integer.
                            Dia2=int(Dia1)                                              # Converts the NaN Day value to integer.

                            # The date vector is created
                            fecha_inicio = datetime(Anio1, Mes1, Dia2)
                            dias = [fecha_inicio + timedelta(hours=i) for i in range(len(entropia_shannon[indices_no_cero_shannon]))]

                            # "Indices_no_cero_shannon" = np.where(entropia_shannon != 0)[0]
                            st = (dias, entropia_shannon[indices_no_cero_shannon])
                            np.save(F3, st)  # Save the ".npy" file in the directory.
                            plt.close()

                            st = (dias, entropia_shannon[indices_no_cero_shannon])

                            # Save the ".npy" file in the directory.
                            np.save(F3, st)
                            plt.close()                                             # Close the existing chart.

                            # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                            # Graph 1 - ENTROPY BY POINTS.

                            plt.plot(dias, entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='ShannonEntropy: Points per hour -> 24 Hrs.')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_ShannonEntropy: Each point = 24 Hrs. with Bandpass filter', color ="darkgreen", fontsize=18)

                            # Graph 2 - Averaged Shannon Entropy Graph.

                            fig, ax = plt.subplots(1,1)
                            indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                            plt.plot(dias, entropia_promediada[indices_no_cero_promediada], "ob", mfc="b", mec = "b", label='ShannonAveragedEntropy: Points per hour -> 24 Hrs.')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Shannon Averaged Entropy: Each point = 24 Hrs. with Bandpass filter.', color ="darkgreen", fontsize=18)

                            # Graph 3 - Graph of Shannon Entropy with the envelope.

                            # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE.

                            fig, ax = plt.subplots(1,1)

                            y_filtered = nanfastsmooth(Y.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                            plt.plot(dias, entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='Shannon_Entropy')
                            plt.plot(dias, y_filtered[indices_no_cero_shannon], color='blue', label='Envelope')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Envelope - Shannon Entropy: Each point = 24 Hrs. with Bandpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            # Graph 4 - Envelope only graph.

                            fig, ax = plt.subplots(1,1)

                            plt.plot(dias, y_filtered[indices_no_cero_shannon], label='Filtered Signal', color='blue')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Only the envelope of Shannon entropy: Each point = 24 Hrs. with Bandpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                            # Graph 5 Frequency Index with enveloped
                            fig, ax = plt.subplots(1,1)

                            y_filtered3 = nanfastsmooth(Y2.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                            plt.plot(dias, frequency_index[indices_no_cero_frecuency], 'o-', label='Frequency Index')
                            plt.plot(dias, y_filtered3[indices_no_cero_frecuency], label='Envelope', color='red')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                            plt.title(Nombre3 + ' Frequency Index: Each point = 24 Hrs. with Bandpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            # Graph 6 Kurtosis with Envelope
                            fig, ax = plt.subplots(1,1)
                            indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]

                            # The date vector is created
                            fecha_inicio = datetime(Anio1, Mes1, Dia2)
                            dias2 = [fecha_inicio + timedelta(hours=i) for i in range(len(entropia_shannon[indices_no_cero_kurtosis]))]

                            y_filtered2 = nanfastsmooth(Y1.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                            plt.plot(dias2, kurtosis_resultados[indices_no_cero_kurtosis], 'o', label='Kurtosis')
                            plt.plot(dias2, y_filtered2[indices_no_cero_kurtosis], label='Envelope', color='red')
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                            plt.title(Nombre3 + ' Kurtosis: Each point = 24 Hrs. with Bandpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)

                            plt.show()

                    else:

                        # Plot the vectors into separate figures.
                        dias = np.arange(1, 8761 + 1)

                        st = (dias, entropia_shannon[indices_no_cero_shannon])

                        np.save(F3, st)  # Save the ".npy" file in the directory.
                        plt.close()

                        # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                        # Graph 1 - ENTROPY BY POINTS.

                        plt.plot(dias[indices_no_cero_shannon], entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='ShannonEntropy: Points per hour -> 24 Hrs.')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_ShannonEntropy: Each point = 24 Hrs. with Bandpass filter', color ="darkgreen", fontsize=18)

                        # Graph 2 - Averaged Shannon Entropy Graph.

                        fig, ax = plt.subplots(1,1)
                        indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                        plt.plot(dias[indices_no_cero_promediada], entropia_promediada[indices_no_cero_promediada], "ob", mfc="b", mec = "b", label='ShannonAveragedEntropy: Points per hour -> 24 Hrs.')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Shannon Averaged Entropy: Each point = 24 Hrs. with Bandpass filter.', color ="darkgreen", fontsize=18)

                        # Graph 3 - Graph of Shannon Entropy with the envelope.

                        # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE.

                        fig, ax = plt.subplots(1,1)

                        y_filtered = nanfastsmooth(Y.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                        plt.plot(dias[indices_no_cero_shannon], entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='Shannon Entropy')
                        plt.plot(dias[indices_no_cero_shannon], y_filtered[indices_no_cero_shannon], label='Envelope', color='blue')
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Envelope - Shannon Entropy: Each point = 24 Hrs. with Bandpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                        # Graph 4 - Envelope only graph.

                        fig, ax = plt.subplots(1,1)

                        plt.plot(dias[indices_no_cero_shannon], y_filtered[indices_no_cero_shannon], label='Filtered Signal', color='blue')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Only the envelope of Shannon entropy: Each point = 24 Hrs. with Bandpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                        # Graph 5 Frequency Index with Envelope
                        fig, ax = plt.subplots(1,1)

                        y_filtered3 = nanfastsmooth(Y2.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                        plt.plot(dias[indices_no_cero_frecuency], frequency_index[indices_no_cero_frecuency], 'o-', label='Frequency Index')
                        plt.plot(dias[indices_no_cero_frecuency], y_filtered3[indices_no_cero_frecuency], label='Envelope', color='red')
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                        plt.title(Nombre3 + ' Frequency Index: Each point = 24 Hrs. with Bandpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)

                        # Graph 6 Kurtosis with Envelope
                        fig, ax = plt.subplots(1,1)
                        indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]

                        y_filtered2 = nanfastsmooth(Y1.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                        plt.plot(dias[indices_no_cero_kurtosis], kurtosis_resultados[indices_no_cero_kurtosis], 'o', label='Kurtosis')
                        plt.plot(dias[indices_no_cero_kurtosis], y_filtered2[indices_no_cero_kurtosis], label='Envelope', color='red')
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                        plt.title(Nombre3 + ' Kurtosis: Each point = 24 Hrs. with Bandpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)

                        plt.show()

            else:                                           # Here the value of the entropy is calculated without the time interval (Start - End)

                if not self.lineEdit_5.text():
                    MensCombo1 = QMessageBox()
                    MensCombo1.setIcon(QMessageBox.Warning)
                    MensCombo1.setWindowTitle("Empty Smoothing type")
                    MensCombo1.setText("Please, enter a valid Value")
                    returnValue = MensCombo1.exec()

                elif not self.lineEdit_7.text():
                    MensCombo2 = QMessageBox()
                    MensCombo2.setIcon(QMessageBox.Warning)
                    MensCombo2.setWindowTitle("Empty Filter Order")
                    MensCombo2.setText("Please, enter a valid Value")
                    returnValue = MensCombo2.exec()

                elif not self.lineEdit_8.text():
                    MensCombo3 = QMessageBox()
                    MensCombo3.setIcon(QMessageBox.Warning)
                    MensCombo3.setWindowTitle("Empty Min. Frequency")
                    MensCombo3.setText("Please, enter a valid Value")
                    returnValue = MensCombo3.exec()

                elif not self.lineEdit_9.text():
                    MensCombo4 = QMessageBox()
                    MensCombo4.setIcon(QMessageBox.Warning)
                    MensCombo4.setWindowTitle("Empty Max. Frequency")
                    MensCombo4.setText("Please, enter a valid Value")
                    returnValue = MensCombo4.exec()

                elif not self.lineEdit_10.text():
                    MensCombo5 = QMessageBox()
                    MensCombo5.setIcon(QMessageBox.Warning)
                    MensCombo5.setWindowTitle("Empty Envelope Window size")
                    MensCombo5.setText("Please, enter a valid Value")
                    returnValue = MensCombo5.exec()

                elif not self.lineEdit_13.text():
                    MensCombo6 = QMessageBox()
                    MensCombo6.setIcon(QMessageBox.Warning)
                    MensCombo6.setWindowTitle("Empty NaN Tolerance")
                    MensCombo6.setText("Please, enter a valid Value")
                    returnValue = MensCombo6.exec()

                elif not self.label_5.text():
                    MensCombo7 = QMessageBox()
                    MensCombo7.setIcon(QMessageBox.Warning)
                    MensCombo7.setWindowTitle("Empty directory to upload records")
                    MensCombo7.setText("Please, enter a valid name of directory")
                    returnValue = MensCombo7.exec()

                elif not self.label_8.text():
                    MensCombo8 = QMessageBox()
                    MensCombo8.setIcon(QMessageBox.Warning)
                    MensCombo8.setWindowTitle("Empty path to store CSV/NPY file")
                    MensCombo8.setText("Please, enter a valid name of directory")
                    returnValue = MensCombo8.exec()

                else:
                    # Filtering with a Bandpass 24 Hrs.
                    plt.close()                                                 # Close the existing chart.

                    carpeta = (self.label_5.text())                             # Reading the directory or file folder label.

                    # Code to detect the contents of the folder and the files that the folder contains
                    with os.scandir(carpeta) as ficheros:
                        ficheros4 = [fichero.name for fichero in ficheros if fichero.is_file()]

                    # The contents of the files in "ficheros4" is a list. This code converts them to string
                    lfiles = [str(elemento) for elemento in ficheros4]

                    # Code used to determine the name of the files contained in the folder and to be used in the loading loop
                    Iniciolfiles = lfiles[0]                                    # Detects the numeric value of the "Start" in the name
                    Finlfiles = lfiles[-1]                                      # Detects the numerical value of the "End" in the name
                    Indice1 = Iniciolfiles.rfind('.')                           # Determines the index, which will be marked by the dot at the end for the extension
                    Nombre3 = Iniciolfiles[0:Indice1]                           # Indicates the name of the file in str (minus) the index or extension (each day)

                    # Data entry from labels and fields or text boxes (this value is a string by default)
                    frecMin = (self.lineEdit_8.text())                          # Minimum Frequency label reading.
                    frecMax = (self.lineEdit_9.text())                          # Maximum Frequency label reading.
                    orden1 = (self.lineEdit_7.text())                           # Reading the Filter Order Label.

                    # Data entry for enveloped (this value is a string by default)
                    Tam = (self.lineEdit_10.text())                             # Reading the envelope window size label.
                    Tsua = (self.lineEdit_5.text())                             # Reading the Smoothing type label.
                    Tnan = (self.lineEdit_13.text())                            # Reading the NaN Tolerance label.

                    # Convert the string value of the input text boxes to float or integer
                    frec7=float(frecMin)                                        # Converts the Minimum Frequency value to float.
                    frec8=float(frecMax)                                        # Converts the Maximum Frequency value to float.
                    orden7=int(orden1)                                          # Converts filter order value to integer.

                    Tam1=int(Tam)                                               # Converts the envelope window size value to integer.
                    Tsua1=int(Tsua)                                             # Converts the Smoothing type value to integer.
                    Tnan1=int(Tnan)                                             # Converts the NaN Tolerance value to integer.

                    timeIn = 365

                    # Function for Shannon entropy calculating
                    def calcular_entropia(datos):
                        params = stats.norm.fit(datos)
                        dist = stats.norm(*params)
                        probabilidades = dist.pdf(datos)
                        entropia = -np.sum(probabilidades * np.log2(probabilidades))
                        return entropia

                    # Function for Kurtosis calculating
                    def calcular_kurtosis(datos):
                        n = len(datos)
                        media = np.mean(datos)
                        varianza = np.var(datos)
                        desviacion_estandar = np.sqrt(varianza)

                        if desviacion_estandar == 0:
                            return 0.0
                        kurtosis = np.sum((datos - media)**4) / (n * desviacion_estandar**4) - 3.0
                        return kurtosis

                    # Function for Shannon entropy enveloped calculating
                    def nanfastsmooth(Y, w, type=1, tol=0.5):

                        """
                        Smooths vector Y with a moving average of width w, ignoring NaNs in data.

                        Parameters:
                        Y (numpy array): Input signal.
                        w (int): Window width.
                        type (int): Smooth type (1 for rectangular, 2 for triangular, 3 for pseudo-Gaussian).
                        tol (float): Tolerance to NaNs between 0 and 1.

                        Returns:
                        numpy array: Smoothed signal.
                        """
                        mask = ~np.isnan(Y)  # Create a boolean mask for non-NaN values
                        Y[mask] = nanfastsmooth_core(Y[mask], w, type, tol)  # Apply smoothing to non-NaN values
                        return Y

                    # Function for Shannon entropy enveloped type calculating. For default the value = 3
                    def nanfastsmooth_core(Y, w, type, tol):
                        if type == 1:
                            SmoothY = moving_average(Y, w)
                        elif type == 2:
                            SmoothY = moving_average(moving_average(Y, w), w)
                        elif type == 3:
                            SmoothY = moving_average(moving_average(moving_average(Y, w), w), w)

                        return SmoothY

                    def moving_average(Y, window_size):
                        return np.convolve(Y, np.ones(window_size)/window_size, mode='same')

                    def calcular_indice_frecuencias(datos, frecuencia_muestreo):
                        # Aplicar filtro en frecuencia
                        freq_bajas = (1, 5.5)
                        freq_altas = (6, 16)

                        datos_bajas = apply_bandpass_filter(datos, frecuencia_muestreo, freq_bajas)
                        datos_altas = apply_bandpass_filter(datos, frecuencia_muestreo, freq_altas)

                        # Calcular energía para cada señal
                        energia_bajas = np.sum(datos_bajas ** 2)
                        energia_altas = np.sum(datos_altas ** 2)

                        # Calcular índice de frecuencias
                        indice_frecuencias = np.log(energia_altas / energia_bajas) if energia_bajas != 0 else np.nan
                        return indice_frecuencias

                    def apply_bandpass_filter(datos, frecuencia_muestreo, freq_band):
                        nyquist = 0.5 * frecuencia_muestreo
                        normal_freq_band = np.array(freq_band) / nyquist
                        b, a = signal.butter(4, normal_freq_band, btype='band')
                        datos_filtrados = signal.filtfilt(b, a, datos)
                        return datos_filtrados

                    # Start entropy and averaged entropy values
                    entropia_shannon = []
                    entropia_promediada = []
                    kurtosis_resultados = []
                    frequency_index = []

                    # Cycle for the day-by-day calculation of the entropy in the files contained in the folder, using the time range (Start to End)
                    for dia in range(1, timeIn + 1):

                        archivo = Nombre3 + '.'+ f"{dia:003}"       # Here you select the name previously calculated plus point and the value of each Julian day

                        # If there is no file in the list, the entire day is added with a value of zero
                        if not os.path.exists(os.path.join(carpeta, archivo)):
                            for _ in range(24):  # Adds 24 hours with zero value if there is no file
                                entropia_shannon.append(0)
                                entropia_promediada.append(0)
                                kurtosis_resultados.append(0)
                                frequency_index.append(0)
                            continue

                        # Designation of the data contained in the folder files
                        st = Stream()
                        st += read(os.path.join(carpeta, archivo))
                        frecuencia_muestreo = st[0].stats.sampling_rate
                        # calculation of the Bandpass filter with the parameters indicated by the user.
                        st.filter('bandpass', freqmin=frec7, freqmax=frec8, corners=orden7, zerophase=True)
                        # Data value
                        datos = st[0].data

                        # Divide the data into hours and calculate entropy for each hour.
                        for hora in range(24):
                            inicio = hora * 1440  # start of time in seconds.
                            fin = inicio + 84600  # End of time in seconds.
                            datos_hora = datos[inicio:fin]

                            if len(datos_hora) < 86400:  # If the hour is incomplete, add zeros to the end.
                                datos_hora = np.append(datos_hora, np.zeros(86400 - len(datos_hora)))

                            # Accumulator of the calculated values of the Shannon entropy and the averaged entropy.
                            entropia_shannon.append(calcular_entropia(datos_hora))
                            entropia_promediada.append(calcular_entropia(datos_hora) / len(datos_hora))
                            kurtosis_resultados.append(calcular_kurtosis(datos_hora))
                            frequency_index.append(calcular_indice_frecuencias(datos_hora, frecuencia_muestreo))

                    # Converting shannon entropy value and averaged entropy to data array.
                    entropia_shannon = np.array(entropia_shannon)
                    entropia_promediada = np.array(entropia_promediada)
                    kurtosis_resultados = np.array(kurtosis_resultados)
                    frequency_index=np.array(frequency_index)

                    # Shannon Entropy Graph. Value of non-zero indices where there is no data.
                    indices_no_cero_shannon = np.where(entropia_shannon != 0)[0]

                    indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                    indices_no_cero_frecuency = np.where(frequency_index != 0)[0]

                    indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]

                    # **** SAVE THE RESULTS FILE .CSV
                    archivoFil2 = (self.label_8.text())                         # Reading directory label.

                    # **** SAVE THE RESULTS .npy FILE FOR LATER GRAPH *****
                    TW = str(Tam1)                                              # Convert Envelope Window value to string for names.
                    F1 = (Nombre3 + '_Bandpass_Filter_24_Hrs_without_Time_interval_Dots_and_Time' + '_Windows=' + TW + '.csv')            # Assign F1, Capture the name of the record and add the .csv extension.

                    # Guardar resultados en archivos .npy
                    F1a = (Nombre3 + '_Bandpass_Filter_24_Hrs_without_Time_interval_Dots_and_Time' + '_Windows=' + TW)
                    F2 = (archivoFil2 + F1)                                     # Assigns to F2 the directory plus the previous name where the record will be stored.
                    F3 = (archivoFil2 + F1a)

                    with open(F2, 'w+', newline='') as archivo_csv:             # Each result is saved in the file, day, time and values of Shannon's entropy and averaged.
                        writer = csv.writer(archivo_csv)
                        writer.writerow(['Day', ' hour', ' Shannon Entropy', ' Averaged Shannon Entropy', ' Enveloped Shannon Entropy', ' Kurtosis', ' Frequency Index'])

                        for dia in range(1, timeIn + 1):                        # Save data by day and time according to the time interval (Start - End)
                            for hora in range(24):
                                writer.writerow([dia, hora, entropia_shannon[(dia - 1) * 24 + hora], entropia_promediada[(dia - 1) * 24 + hora], kurtosis_resultados[(dia - 1) * 24 + hora], frequency_index[(dia - 1) * 24 + hora] ])

                    # Use example
                    Y = entropia_shannon
                    Y = np.where(Y == 0, np.nan, Y)

                    Y1 = kurtosis_resultados
                    Y1 = np.where(Y1 == 0, np.nan, Y1)

                    Y2 = frequency_index
                    Y2 = np.where(Y2 == 0, np.nan, Y2)                                             # Close the existing chart.

                    if self.checkBox_2.isChecked():                                 # CheckBox 2 of the Initial Time is activated (This marks time on the x axis)

                        if not self.lineEdit_14.text():
                            MensCombo14 = QMessageBox()
                            MensCombo14.setIcon(QMessageBox.Warning)
                            MensCombo14.setWindowTitle("Empty Year value")
                            MensCombo14.setText("Please, enter a valid value")
                            returnValue = MensCombo14.exec()

                        elif not self.lineEdit_15.text():
                            MensCombo15 = QMessageBox()
                            MensCombo15.setIcon(QMessageBox.Warning)
                            MensCombo15.setWindowTitle("Empty Month value")
                            MensCombo15.setText("Please, enter a valid value")
                            returnValue = MensCombo15.exec()

                        elif not self.lineEdit_16.text():
                            MensCombo16 = QMessageBox()
                            MensCombo16.setIcon(QMessageBox.Warning)
                            MensCombo16.setWindowTitle("Empty Day value")
                            MensCombo16.setText("Please, enter a valid value")
                            returnValue = MensCombo16.exec()

                        else:

                            # Data entry for enveloped (this value is a string by default)
                            Anio = (self.lineEdit_14.text())                            # Reading the Year value label.
                            Mes = (self.lineEdit_15.text())                             # Reading the Month value label.
                            Dia1 = (self.lineEdit_16.text())                            # Reading the Day value label.

                            # Convert the string value of the input text boxes to  integer

                            Anio1=int(Anio)                                             # Converts the Year value to integer.
                            Mes1=int(Mes)                                               # Converts the Month value to integer.
                            Dia2=int(Dia1)                                              # Converts the NaN Day value to integer.

                            # The date vector is created
                            fecha_inicio = datetime(Anio1, Mes1, Dia2)
                            dias = [fecha_inicio + timedelta(hours=i) for i in range(len(entropia_shannon[indices_no_cero_shannon]))]

                            # "Indices_no_cero_shannon" = np.where(entropia_shannon != 0)[0]
                            st = (dias, entropia_shannon[indices_no_cero_shannon])
                            np.save(F3, st)  # Save the ".npy" file in the directory.
                            plt.close()

                            st = (dias, entropia_shannon[indices_no_cero_shannon])

                            # Save the ".npy" file in the directory.
                            np.save(F3, st)
                            plt.close()                                             # Close the existing chart.

                            # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                            # Graph 1 - ENTROPY BY POINTS.

                            plt.plot(dias, entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='ShannonEntropy: Points per hour -> 24 Hrs.')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_ShannonEntropy: Each point = 24 Hrs. with Bandpass filter', color ="darkgreen", fontsize=18)

                            # Graph 2 - Averaged Shannon Entropy Graph.

                            fig, ax = plt.subplots(1,1)
                            indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                            plt.plot(dias, entropia_promediada[indices_no_cero_promediada], "ob", mfc="b", mec = "b", label='ShannonAveragedEntropy: Points per hour -> 24 Hrs.')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Shannon Averaged Entropy: Each point = 24 Hrs. with Bandpass filter.', color ="darkgreen", fontsize=18)

                            # Graph 3 - Graph of Shannon Entropy with the envelope.

                            # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE.

                            fig, ax = plt.subplots(1,1)

                            y_filtered = nanfastsmooth(Y.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                            plt.plot(dias, entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='Shannon_Entropy')
                            plt.plot(dias, y_filtered[indices_no_cero_shannon], color='blue', label='Envelope')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Envelope - Shannon Entropy: Each point = 24 Hrs. with Bandpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            # Graph 4 - Envelope only graph.

                            fig, ax = plt.subplots(1,1)

                            plt.plot(dias, y_filtered[indices_no_cero_shannon], label='Filtered Signal', color='blue')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Only the envelope of Shannon entropy: Each point = 24 Hrs. with Bandpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                            # Graph 5 Frequency Index with enveloped
                            fig, ax = plt.subplots(1,1)

                            y_filtered3 = nanfastsmooth(Y2.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                            plt.plot(dias, frequency_index[indices_no_cero_frecuency], 'o-', label='Frequency Index')
                            plt.plot(dias, y_filtered3[indices_no_cero_frecuency], label='Envelope', color='red')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                            plt.title(Nombre3 + ' Frequency Index: Each point = 24 Hrs. with Bandpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            # Graph 6 Kurtosis with Envelope
                            fig, ax = plt.subplots(1,1)
                            indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]

                            # The date vector is created
                            fecha_inicio = datetime(Anio1, Mes1, Dia2)
                            dias2 = [fecha_inicio + timedelta(hours=i) for i in range(len(entropia_shannon[indices_no_cero_kurtosis]))]

                            y_filtered2 = nanfastsmooth(Y1.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                            plt.plot(dias2, kurtosis_resultados[indices_no_cero_kurtosis], 'o', label='Kurtosis')
                            plt.plot(dias2, y_filtered2[indices_no_cero_kurtosis], label='Envelope', color='red')
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                            plt.title(Nombre3 + ' Kurtosis: Each point = 24 Hrs. with Bandpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)

                            plt.show()

                    else:

                        # Plot the vectors into separate figures.
                        dias = np.arange(1, 8761*6+1)

                        st = (dias, entropia_shannon[indices_no_cero_shannon])

                        np.save(F3, st)  # Save the ".npy" file in the directory.
                        plt.close()

                        # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                        # Graph 1 - ENTROPY BY POINTS.

                        plt.plot(dias[indices_no_cero_shannon], entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='ShannonEntropy: Points per hour -> 24 Hrs.')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_ShannonEntropy: Each point = 24 Hrs. with Bandpass filter', color ="darkgreen", fontsize=18)

                        # Graph 2 - Averaged Shannon Entropy Graph.

                        fig, ax = plt.subplots(1,1)
                        indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                        plt.plot(dias[indices_no_cero_promediada], entropia_promediada[indices_no_cero_promediada], "ob", mfc="b", mec = "b", label='ShannonAveragedEntropy: Points per hour -> 24 Hrs.')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Shannon Averaged Entropy: Each point = 24 Hrs. with Bandpass filter.', color ="darkgreen", fontsize=18)

                        # Graph 3 - Graph of Shannon Entropy with the envelope.

                        # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE.

                        fig, ax = plt.subplots(1,1)

                        y_filtered = nanfastsmooth(Y.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                        plt.plot(dias[indices_no_cero_shannon], entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='Shannon Entropy')
                        plt.plot(dias[indices_no_cero_shannon], y_filtered[indices_no_cero_shannon], label='Envelope', color='blue')
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Envelope - Shannon Entropy: Each point = 24 Hrs. with Bandpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                        # Graph 4 - Envelope only graph.

                        fig, ax = plt.subplots(1,1)

                        plt.plot(dias[indices_no_cero_shannon], y_filtered[indices_no_cero_shannon], label='Filtered Signal', color='blue')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Only the envelope of Shannon entropy: Each point = 24 Hrs. with Bandpass filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                        # Graph 5 Frequency Index with Envelope
                        fig, ax = plt.subplots(1,1)

                        y_filtered3 = nanfastsmooth(Y2.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                        plt.plot(dias[indices_no_cero_frecuency], frequency_index[indices_no_cero_frecuency], 'o-', label='Frequency Index')
                        plt.plot(dias[indices_no_cero_frecuency], y_filtered3[indices_no_cero_frecuency], label='Envelope', color='red')
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                        plt.title(Nombre3 + ' Frequency Index: Each point = 24 Hrs. with Bandpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)

                        # Graph 6 Kurtosis with Envelope
                        fig, ax = plt.subplots(1,1)
                        indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]

                        y_filtered2 = nanfastsmooth(Y1.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                        plt.plot(dias[indices_no_cero_kurtosis], kurtosis_resultados[indices_no_cero_kurtosis], 'o', label='Kurtosis')
                        plt.plot(dias[indices_no_cero_kurtosis], y_filtered2[indices_no_cero_kurtosis], label='Envelope', color='red')
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                        plt.title(Nombre3 + ' Kurtosis: Each point = 24 Hrs. with Bandpass filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)

                        plt.show()

        except:                         # In any other case of invalid or empty inputs
                plt.close()                                                 # Close the existing chart.
                msgBox = QMessageBox()
                msgBox.setIcon(QMessageBox.Warning)
                msgBox.setText("The File Does not exist, is Invalid or the CSV old file is open. Please close, try again ...")
                msgBox.setWindowTitle("Invalid Record inputs or CSV Old file is open ")
                returnValue = msgBox.exec()
                pass

    def filtroBandstop24hr(self):                                               # 12.- Function to execute the Bandstop filter with 24 hr. analysis window.

        try:

            # Verifying that the checkbox is true. Work with time intervals.

            if self.checkBox.isChecked() == True:

                # Verify (Validation), that the text box and label is not empty

                if not self.label_5.text():
                    MensCombo1 = QMessageBox()
                    MensCombo1.setIcon(QMessageBox.Warning)
                    MensCombo1.setWindowTitle("Empty directory to upload records")
                    MensCombo1.setText("Please, enter a valid name of directory")
                    returnValue = MensCombo1.exec()

                elif not self.label_8.text():
                    MensCombo2 = QMessageBox()
                    MensCombo2.setIcon(QMessageBox.Warning)
                    MensCombo2.setWindowTitle("Empty path to store CSV/NPY file")
                    MensCombo2.setText("Please, enter a valid name of directory")
                    returnValue = MensCombo2.exec()

                elif not self.lineEdit_5.text():
                    MensCombo3 = QMessageBox()
                    MensCombo3.setIcon(QMessageBox.Warning)
                    MensCombo3.setWindowTitle("Empty Smoothing type")
                    MensCombo3.setText("Please, enter a valid Value")
                    returnValue = MensCombo3.exec()

                elif not self.lineEdit_7.text():
                    MensCombo4 = QMessageBox()
                    MensCombo4.setIcon(QMessageBox.Warning)
                    MensCombo4.setWindowTitle("Empty Filter Order")
                    MensCombo4.setText("Please, enter a valid Value")
                    returnValue = MensCombo4.exec()

                elif not self.lineEdit_8.text():
                    MensCombo5 = QMessageBox()
                    MensCombo5.setIcon(QMessageBox.Warning)
                    MensCombo5.setWindowTitle("Empty Min. Frequency")
                    MensCombo5.setText("Please, enter a valid Value")
                    returnValue = MensCombo5.exec()

                elif not self.lineEdit_9.text():
                    MensCombo6 = QMessageBox()
                    MensCombo6.setIcon(QMessageBox.Warning)
                    MensCombo6.setWindowTitle("Empty Max. Frequency")
                    MensCombo6.setText("Please, enter a valid Value")
                    returnValue = MensCombo6.exec()

                elif not self.lineEdit_10.text():
                    MensCombo7 = QMessageBox()
                    MensCombo7.setIcon(QMessageBox.Warning)
                    MensCombo7.setWindowTitle("Empty Envelope Window size")
                    MensCombo7.setText("Please, enter a valid Value")
                    returnValue = MensCombo7.exec()

                elif not self.lineEdit_11.text():
                    MensCombo8 = QMessageBox()
                    MensCombo8.setIcon(QMessageBox.Warning)
                    MensCombo8.setWindowTitle("Empty Start time")
                    MensCombo8.setText("Please, enter a valid Value")
                    returnValue = MensCombo8.exec()

                elif not self.lineEdit_12.text():
                    MensCombo9 = QMessageBox()
                    MensCombo9.setIcon(QMessageBox.Warning)
                    MensCombo9.setWindowTitle("Empty End time")
                    MensCombo9.setText("Please, enter a valid Value")
                    returnValue = MensCombo9.exec()

                elif not self.lineEdit_13.text():
                    MensCombo10 = QMessageBox()
                    MensCombo10.setIcon(QMessageBox.Warning)
                    MensCombo10.setWindowTitle("Empty NaN Tolerance")
                    MensCombo10.setText("Please, enter a valid Value")
                    returnValue = MensCombo10.exec()

                else:
                    # Filtering with a Bandstop 24 Hrs.
                    plt.close()                                                 # Close the existing chart.

                    carpeta = (self.label_5.text())                             # Reading the directory or file folder label.

                    # Code to detect the contents of the folder and the files that the folder contains
                    with os.scandir(carpeta) as ficheros:
                        ficheros4 = [fichero.name for fichero in ficheros if fichero.is_file()]

                    # The contents of the files in "ficheros4" is a list. This code converts them to string
                    lfiles = [str(elemento) for elemento in ficheros4]

                    # Code used to determine the name of the files contained in the folder and to be used in the loading loop
                    Iniciolfiles = lfiles[0]                                    # Detects the numeric value of the "Start" in the name
                    Finlfiles = lfiles[-1]                                      # Detects the numerical value of the "End" in the name
                    Indice1 = Iniciolfiles.rfind('.')                           # Determines the index, which will be marked by the dot at the end for the extension
                    Nombre3 = Iniciolfiles[0:Indice1]                           # Indicates the name of the file in str (minus) the index or extension (each day)

                    # Data entry from labels and fields or text boxes (this value is a string by default)

                    frecMin = (self.lineEdit_8.text())                          # Minimum Frequency label reading.
                    frecMax = (self.lineEdit_9.text())                          # Maximum Frequency label reading.
                    orden1 = (self.lineEdit_7.text())                           # Reading the Filter Order Label.

                    Start1 = (self.lineEdit_11.text())                          # Star Time Size label reading.
                    End1 = (self.lineEdit_12.text())                            # End Time Size label reading.

                    # Convert the string value of the input text boxes to float or integer
                    frec7=float(frecMin)                                        # Converts the Minimum Frequency value to float.
                    frec8=float(frecMax)                                        # Converts the Maximum Frequency value to float.
                    orden7=int(orden1)                                          # Converts filter order value to integer.

                     # Data entry for enveloped (this value is a string by default)
                    Tam = (self.lineEdit_10.text())                             # Reading the envelope window size label.
                    Tsua = (self.lineEdit_5.text())                             # Reading the Smoothing type label.
                    Tnan = (self.lineEdit_13.text())                            # Reading the NaN Tolerance label.

                    Tam1=int(Tam)                                               # Converts the envelope window size value to integer.
                    Tsua1=int(Tsua)                                             # Converts the Smoothing type value to integer.
                    Tnan1=int(Tnan)                                             # Converts the NaN Tolerance value to integer.

                    timeIn = 365

                    Start2=int(Start1)                                          # Converts the Start time window size value to an integer.
                    End2=int(End1)                                              # Converts the End time window size value to an integer.

                    Diferencia = End2 - Start2                                  # Value of the difference between end and start to obtain the number of days to calculate

                    # Function for Shannon entropy calculating
                    def calcular_entropia(datos):
                        params = stats.norm.fit(datos)
                        dist = stats.norm(*params)
                        probabilidades = dist.pdf(datos)
                        entropia = -np.sum(probabilidades * np.log2(probabilidades))
                        return entropia

                    # Function for Kurtosis calculating
                    def calcular_kurtosis(datos):
                        n = len(datos)
                        media = np.mean(datos)
                        varianza = np.var(datos)
                        desviacion_estandar = np.sqrt(varianza)

                        if desviacion_estandar == 0:
                            return 0.0
                        kurtosis = np.sum((datos - media)**4) / (n * desviacion_estandar**4) - 3.0
                        return kurtosis

                    # Function for Shannon entropy enveloped calculating
                    def nanfastsmooth(Y, w, type=1, tol=0.5):

                        """
                        Smooths vector Y with a moving average of width w, ignoring NaNs in data.

                        Parameters:
                        Y (numpy array): Input signal.
                        w (int): Window width.
                        type (int): Smooth type (1 for rectangular, 2 for triangular, 3 for pseudo-Gaussian).
                        tol (float): Tolerance to NaNs between 0 and 1.

                        Returns:
                        numpy array: Smoothed signal.
                        """
                        mask = ~np.isnan(Y)  # Create a boolean mask for non-NaN values
                        Y[mask] = nanfastsmooth_core(Y[mask], w, type, tol)  # Apply smoothing to non-NaN values
                        return Y

                    # Function for Shannon entropy enveloped type calculating. For default the value = 3
                    def nanfastsmooth_core(Y, w, type, tol):
                        if type == 1:
                            SmoothY = moving_average(Y, w)
                        elif type == 2:
                            SmoothY = moving_average(moving_average(Y, w), w)
                        elif type == 3:
                            SmoothY = moving_average(moving_average(moving_average(Y, w), w), w)

                        return SmoothY

                    def moving_average(Y, window_size):
                        return np.convolve(Y, np.ones(window_size)/window_size, mode='same')

                    def calcular_indice_frecuencias(datos, frecuencia_muestreo):
                        # Aplicar filtro en frecuencia
                        freq_bajas = (1, 5.5)
                        freq_altas = (6, 16)

                        datos_bajas = apply_bandpass_filter(datos, frecuencia_muestreo, freq_bajas)
                        datos_altas = apply_bandpass_filter(datos, frecuencia_muestreo, freq_altas)

                        # Calcular energía para cada señal
                        energia_bajas = np.sum(datos_bajas ** 2)
                        energia_altas = np.sum(datos_altas ** 2)

                        # Calcular índice de frecuencias
                        indice_frecuencias = np.log(energia_altas / energia_bajas) if energia_bajas != 0 else np.nan
                        return indice_frecuencias

                    def apply_bandpass_filter(datos, frecuencia_muestreo, freq_band):
                        nyquist = 0.5 * frecuencia_muestreo
                        normal_freq_band = np.array(freq_band) / nyquist
                        b, a = signal.butter(4, normal_freq_band, btype='band')
                        datos_filtrados = signal.filtfilt(b, a, datos)
                        return datos_filtrados

                    # Start entropy and averaged entropy values
                    entropia_shannon = []
                    entropia_promediada = []
                    kurtosis_resultados = []
                    frequency_index = []

                    # Cycle for the day-by-day calculation of the entropy in the files contained in the folder, using the time range (Start to End)
                    for dia in range(Start2, End2 + 1):

                        archivo = Nombre3 + '.'+ f"{dia:003}"       # Here you select the name previously calculated plus point and the value of each Julian day

                        # If there is no file in the list, the entire day is added with a value of zero
                        if not os.path.exists(os.path.join(carpeta, archivo)):
                            for _ in range(24):  # Adds 24 hours with zero value if there is no file
                                entropia_shannon.append(0)
                                entropia_promediada.append(0)
                                kurtosis_resultados.append(0)
                                frequency_index.append(0)
                            continue

                        # Designation of the data contained in the folder files
                        st = Stream()
                        st += read(os.path.join(carpeta, archivo))
                        frecuencia_muestreo = st[0].stats.sampling_rate
                        # calculation of the Bandstop filter with the parameters indicated by the user.
                        st.filter('bandstop', freqmin=frec7, freqmax=frec8, corners=orden7, zerophase=True)
                        # Data value
                        datos = st[0].data

                        # Divide the data into hours and calculate entropy for each hour.
                        for hora in range(24):
                            inicio = hora * 1440  # start of time in seconds.
                            fin = inicio + 84600  # End of time in seconds.
                            datos_hora = datos[inicio:fin]

                            if len(datos_hora) < 86400:  # If the hour is incomplete, add zeros to the end.
                                datos_hora = np.append(datos_hora, np.zeros(86400 - len(datos_hora)))

                            # Accumulator of the calculated values of the Shannon entropy and the averaged entropy.
                            entropia_shannon.append(calcular_entropia(datos_hora))
                            entropia_promediada.append(calcular_entropia(datos_hora) / len(datos_hora))
                            kurtosis_resultados.append(calcular_kurtosis(datos_hora))
                            frequency_index.append(calcular_indice_frecuencias(datos_hora, frecuencia_muestreo))

                    # Converting shannon entropy value and averaged entropy to data array.
                    entropia_shannon = np.array(entropia_shannon)
                    entropia_promediada = np.array(entropia_promediada)
                    kurtosis_resultados = np.array(kurtosis_resultados)
                    frequency_index=np.array(frequency_index)

                    # Shannon Entropy Graph. Value of non-zero indices where there is no data.
                    indices_no_cero_shannon = np.where(entropia_shannon != 0)[0]

                    indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                    indices_no_cero_frecuency = np.where(frequency_index != 0)[0]

                    indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]

                    # **** SAVE THE RESULTS FILE .CSV
                    archivoFil2 = (self.label_8.text())                         # Reading directory label.

                    # **** SAVE THE RESULTS .npy FILE FOR LATER GRAPH *****
                    TW = str(Tam1)                                              # Convert Envelope Window value to string for names.
                    F1 = (Nombre3 + '_Bandstop_Filter_24_Hrs_Time_interval_Dots_and_Time' + '_Windows=' + TW + '.csv')            # Assign F1, Capture the name of the record and add the .csv extension.

                    # Guardar resultados en archivos .npy
                    F1a = (Nombre3 + '_Bandstop_Filter_24_Hrs_Time_interval_Dots_and_Time' + '_Windows=' + TW)
                    F2 = (archivoFil2 + F1)                                     # Assigns to F2 the directory plus the previous name where the record will be stored.
                    F3 = (archivoFil2 + F1a)

                    with open(F2, 'w+', newline='') as archivo_csv:             # Each result is saved in the file, day, time and values of Shannon's entropy and averaged.
                        writer = csv.writer(archivo_csv)
                        writer.writerow(['Day', ' hour', ' Shannon Entropy', ' Averaged Shannon Entropy', ' Enveloped Shannon Entropy', ' Kurtosis', ' Frequency Index'])

                        for dia in range(1, Diferencia + 1):                        # Save data by day and time according to the time interval (Start - End)
                            for hora in range(24):

                                writer.writerow([dia, hora, entropia_shannon[(dia - 1) * 24 + hora], entropia_promediada[(dia - 1) * 24 + hora], kurtosis_resultados[(dia - 1) * 24 + hora], frequency_index[(dia - 1) * 24 + hora] ])

                    # Use example
                    Y = entropia_shannon
                    Y = np.where(Y == 0, np.nan, Y)

                    Y1 = kurtosis_resultados
                    Y1 = np.where(Y1 == 0, np.nan, Y1)

                    Y2 = frequency_index
                    Y2 = np.where(Y2 == 0, np.nan, Y2)                                             # Close the existing chart.

                    # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                    # Graph 1 - ENTROPY BY POINTS.

                    if self.checkBox_2.isChecked():                                 # CheckBox 2 of the Initial Time is activated (This marks time on the x axis)

                        if not self.lineEdit_14.text():
                            MensCombo14 = QMessageBox()
                            MensCombo14.setIcon(QMessageBox.Warning)
                            MensCombo14.setWindowTitle("Empty Year value")
                            MensCombo14.setText("Please, enter a valid value")
                            returnValue = MensCombo14.exec()

                        elif not self.lineEdit_15.text():
                            MensCombo15 = QMessageBox()
                            MensCombo15.setIcon(QMessageBox.Warning)
                            MensCombo15.setWindowTitle("Empty Month value")
                            MensCombo15.setText("Please, enter a valid value")
                            returnValue = MensCombo15.exec()

                        elif not self.lineEdit_16.text():
                            MensCombo16 = QMessageBox()
                            MensCombo16.setIcon(QMessageBox.Warning)
                            MensCombo16.setWindowTitle("Empty Day value")
                            MensCombo16.setText("Please, enter a valid value")
                            returnValue = MensCombo16.exec()

                        else:

                            # Data entry for enveloped (this value is a string by default)
                            Anio = (self.lineEdit_14.text())                            # Reading the Year value label.
                            Mes = (self.lineEdit_15.text())                             # Reading the Month value label.
                            Dia1 = (self.lineEdit_16.text())                            # Reading the Day value label.

                            # Convert the string value of the input text boxes to  integer

                            Anio1=int(Anio)                                             # Converts the Year value to integer.
                            Mes1=int(Mes)                                               # Converts the Month value to integer.
                            Dia2=int(Dia1)                                              # Converts the NaN Day value to integer.

                            # The date vector is created
                            fecha_inicio = datetime(Anio1, Mes1, Dia2)
                            dias = [fecha_inicio + timedelta(hours=i) for i in range(len(entropia_shannon[indices_no_cero_shannon]))]

                            # "Indices_no_cero_shannon" = np.where(entropia_shannon != 0)[0]
                            st = (dias, entropia_shannon[indices_no_cero_shannon])
                            np.save(F3, st)  # Save the ".npy" file in the directory.
                            plt.close()

                            st = (dias, entropia_shannon[indices_no_cero_shannon])

                            # Save the ".npy" file in the directory.
                            np.save(F3, st)
                            plt.close()                                             # Close the existing chart.

                            # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                            # Graph 1 - ENTROPY BY POINTS.

                            plt.plot(dias, entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='ShannonEntropy: Points per hour -> 24 Hrs.')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_ShannonEntropy: Each point = 24 Hrs. with Bandstop filter', color ="darkgreen", fontsize=18)

                            # Graph 2 - Averaged Shannon Entropy Graph.

                            fig, ax = plt.subplots(1,1)
                            indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                            plt.plot(dias, entropia_promediada[indices_no_cero_promediada], "ob", mfc="b", mec = "b", label='ShannonAveragedEntropy: Points per hour -> 24 Hrs.')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Shannon Averaged Entropy: Each point = 24 Hrs. with Bandstop filter.', color ="darkgreen", fontsize=18)

                            # Graph 3 - Graph of Shannon Entropy with the envelope.

                            # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE.

                            fig, ax = plt.subplots(1,1)

                            y_filtered = nanfastsmooth(Y.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                            plt.plot(dias, entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='Shannon_Entropy')
                            plt.plot(dias, y_filtered[indices_no_cero_shannon], color='blue', label='Envelope')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Envelope - Shannon Entropy: Each point = 24 Hrs. with Bandstop filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            # Graph 4 - Envelope only graph.

                            fig, ax = plt.subplots(1,1)

                            plt.plot(dias, y_filtered[indices_no_cero_shannon], label='Filtered Signal', color='blue')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Only the envelope of Shannon entropy: Each point = 24 Hrs. with Bandstop filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                            # Graph 5 Frequency Index with enveloped
                            fig, ax = plt.subplots(1,1)

                            y_filtered3 = nanfastsmooth(Y2.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                            plt.plot(dias, frequency_index[indices_no_cero_frecuency], 'o-', label='Frequency Index')
                            plt.plot(dias, y_filtered3[indices_no_cero_frecuency], label='Envelope', color='red')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                            plt.title(Nombre3 + ' Frequency Index: Each point = 24 Hrs. with Bandstop filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            # Graph 6 Kurtosis with Envelope
                            fig, ax = plt.subplots(1,1)
                            indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]

                            # The date vector is created
                            fecha_inicio = datetime(Anio1, Mes1, Dia2)
                            dias2 = [fecha_inicio + timedelta(hours=i) for i in range(len(entropia_shannon[indices_no_cero_kurtosis]))]

                            y_filtered2 = nanfastsmooth(Y1.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                            plt.plot(dias2, kurtosis_resultados[indices_no_cero_kurtosis], 'o', label='Kurtosis')
                            plt.plot(dias2, y_filtered2[indices_no_cero_kurtosis], label='Envelope', color='red')
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                            plt.title(Nombre3 + ' Kurtosis: Each point = 24 Hrs. with Bandstop filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)

                            plt.show()

                    else:

                        # Plot the vectors into separate figures.
                        dias = np.arange(1, 8761 + 1)

                        st = (dias, entropia_shannon[indices_no_cero_shannon])

                        np.save(F3, st)  # Save the ".npy" file in the directory.
                        plt.close()

                        # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                        # Graph 1 - ENTROPY BY POINTS.

                        plt.plot(dias[indices_no_cero_shannon], entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='ShannonEntropy: Points per hour -> 24 Hrs.')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_ShannonEntropy: Each point = 24 Hrs. with Bandstop filter', color ="darkgreen", fontsize=18)

                        # Graph 2 - Averaged Shannon Entropy Graph.

                        fig, ax = plt.subplots(1,1)
                        indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                        plt.plot(dias[indices_no_cero_promediada], entropia_promediada[indices_no_cero_promediada], "ob", mfc="b", mec = "b", label='ShannonAveragedEntropy: Points per hour -> 24 Hrs.')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Shannon Averaged Entropy: Each point = 24 Hrs. with Bandstop filter.', color ="darkgreen", fontsize=18)

                        # Graph 3 - Graph of Shannon Entropy with the envelope.

                        # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE.

                        fig, ax = plt.subplots(1,1)

                        y_filtered = nanfastsmooth(Y.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                        plt.plot(dias[indices_no_cero_shannon], entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='Shannon Entropy')
                        plt.plot(dias[indices_no_cero_shannon], y_filtered[indices_no_cero_shannon], label='Envelope', color='blue')
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Envelope - Shannon Entropy: Each point = 24 Hrs. with Bandstop filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                        # Graph 4 - Envelope only graph.

                        fig, ax = plt.subplots(1,1)

                        plt.plot(dias[indices_no_cero_shannon], y_filtered[indices_no_cero_shannon], label='Filtered Signal', color='blue')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Only the envelope of Shannon entropy: Each point = 24 Hrs. with Bandstop filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                        # Graph 5 Frequency Index with Envelope
                        fig, ax = plt.subplots(1,1)

                        y_filtered3 = nanfastsmooth(Y2.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                        plt.plot(dias[indices_no_cero_frecuency], frequency_index[indices_no_cero_frecuency], 'o-', label='Frequency Index')
                        plt.plot(dias[indices_no_cero_frecuency], y_filtered3[indices_no_cero_frecuency], label='Envelope', color='red')
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                        plt.title(Nombre3 + ' Frequency Index: Each point = 24 Hrs. with Bandstop filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)

                        # Graph 6 Kurtosis with Envelope
                        fig, ax = plt.subplots(1,1)
                        indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]

                        y_filtered2 = nanfastsmooth(Y1.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                        plt.plot(dias[indices_no_cero_kurtosis], kurtosis_resultados[indices_no_cero_kurtosis], 'o', label='Kurtosis')
                        plt.plot(dias[indices_no_cero_kurtosis], y_filtered2[indices_no_cero_kurtosis], label='Envelope', color='red')
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                        plt.title(Nombre3 + ' Kurtosis: Each point = 24 Hrs. with Bandstop filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)

                        plt.show()

            else:                                           # Here the value of the entropy is calculated without the time interval (Start - End)

                if not self.lineEdit_5.text():
                    MensCombo1 = QMessageBox()
                    MensCombo1.setIcon(QMessageBox.Warning)
                    MensCombo1.setWindowTitle("Empty Smoothing type")
                    MensCombo1.setText("Please, enter a valid Value")
                    returnValue = MensCombo1.exec()

                elif not self.lineEdit_7.text():
                    MensCombo2 = QMessageBox()
                    MensCombo2.setIcon(QMessageBox.Warning)
                    MensCombo2.setWindowTitle("Empty Filter Order")
                    MensCombo2.setText("Please, enter a valid Value")
                    returnValue = MensCombo2.exec()

                elif not self.lineEdit_8.text():
                    MensCombo3 = QMessageBox()
                    MensCombo3.setIcon(QMessageBox.Warning)
                    MensCombo3.setWindowTitle("Empty Min. Frequency")
                    MensCombo3.setText("Please, enter a valid Value")
                    returnValue = MensCombo3.exec()

                elif not self.lineEdit_9.text():
                    MensCombo4 = QMessageBox()
                    MensCombo4.setIcon(QMessageBox.Warning)
                    MensCombo4.setWindowTitle("Empty Max. Frequency")
                    MensCombo4.setText("Please, enter a valid Value")
                    returnValue = MensCombo4.exec()

                elif not self.lineEdit_10.text():
                    MensCombo5 = QMessageBox()
                    MensCombo5.setIcon(QMessageBox.Warning)
                    MensCombo5.setWindowTitle("Empty Envelope Window size")
                    MensCombo5.setText("Please, enter a valid Value")
                    returnValue = MensCombo5.exec()

                elif not self.lineEdit_13.text():
                    MensCombo6 = QMessageBox()
                    MensCombo6.setIcon(QMessageBox.Warning)
                    MensCombo6.setWindowTitle("Empty NaN Tolerance")
                    MensCombo6.setText("Please, enter a valid Value")
                    returnValue = MensCombo6.exec()

                elif not self.label_5.text():
                    MensCombo7 = QMessageBox()
                    MensCombo7.setIcon(QMessageBox.Warning)
                    MensCombo7.setWindowTitle("Empty directory to upload records")
                    MensCombo7.setText("Please, enter a valid name of directory")
                    returnValue = MensCombo7.exec()

                elif not self.label_8.text():
                    MensCombo8 = QMessageBox()
                    MensCombo8.setIcon(QMessageBox.Warning)
                    MensCombo8.setWindowTitle("Empty path to store CSV/NPY file")
                    MensCombo8.setText("Please, enter a valid name of directory")
                    returnValue = MensCombo8.exec()

                else:
                    # Filtering with a Bandstop 24 Hrs.
                    plt.close()                                                 # Close the existing chart.

                    carpeta = (self.label_5.text())                             # Reading the directory or file folder label.

                    # Code to detect the contents of the folder and the files that the folder contains
                    with os.scandir(carpeta) as ficheros:
                        ficheros4 = [fichero.name for fichero in ficheros if fichero.is_file()]

                    # The contents of the files in "ficheros4" is a list. This code converts them to string
                    lfiles = [str(elemento) for elemento in ficheros4]

                    # Code used to determine the name of the files contained in the folder and to be used in the loading loop
                    Iniciolfiles = lfiles[0]                                    # Detects the numeric value of the "Start" in the name
                    Finlfiles = lfiles[-1]                                      # Detects the numerical value of the "End" in the name
                    Indice1 = Iniciolfiles.rfind('.')                           # Determines the index, which will be marked by the dot at the end for the extension
                    Nombre3 = Iniciolfiles[0:Indice1]                           # Indicates the name of the file in str (minus) the index or extension (each day)

                    # Data entry from labels and fields or text boxes (this value is a string by default)
                    frecMin = (self.lineEdit_8.text())                          # Minimum Frequency label reading.
                    frecMax = (self.lineEdit_9.text())                          # Maximum Frequency label reading.
                    orden1 = (self.lineEdit_7.text())                           # Reading the Filter Order Label.

                    # Data entry for enveloped (this value is a string by default)
                    Tam = (self.lineEdit_10.text())                             # Reading the envelope window size label.
                    Tsua = (self.lineEdit_5.text())                             # Reading the Smoothing type label.
                    Tnan = (self.lineEdit_13.text())                            # Reading the NaN Tolerance label.

                    # Convert the string value of the input text boxes to float or integer
                    frec7=float(frecMin)                                        # Converts the Minimum Frequency value to float.
                    frec8=float(frecMax)                                        # Converts the Maximum Frequency value to float.
                    orden7=int(orden1)                                          # Converts filter order value to integer.

                    Tam1=int(Tam)                                               # Converts the envelope window size value to integer.
                    Tsua1=int(Tsua)                                             # Converts the Smoothing type value to integer.
                    Tnan1=int(Tnan)                                             # Converts the NaN Tolerance value to integer.

                    timeIn = 365

                    # Function for Shannon entropy calculating
                    def calcular_entropia(datos):
                        params = stats.norm.fit(datos)
                        dist = stats.norm(*params)
                        probabilidades = dist.pdf(datos)
                        entropia = -np.sum(probabilidades * np.log2(probabilidades))
                        return entropia

                    # Function for Kurtosis calculating
                    def calcular_kurtosis(datos):
                        n = len(datos)
                        media = np.mean(datos)
                        varianza = np.var(datos)
                        desviacion_estandar = np.sqrt(varianza)

                        if desviacion_estandar == 0:
                            return 0.0
                        kurtosis = np.sum((datos - media)**4) / (n * desviacion_estandar**4) - 3.0
                        return kurtosis

                    # Function for Shannon entropy enveloped calculating
                    def nanfastsmooth(Y, w, type=1, tol=0.5):

                        """
                        Smooths vector Y with a moving average of width w, ignoring NaNs in data.

                        Parameters:
                        Y (numpy array): Input signal.
                        w (int): Window width.
                        type (int): Smooth type (1 for rectangular, 2 for triangular, 3 for pseudo-Gaussian).
                        tol (float): Tolerance to NaNs between 0 and 1.

                        Returns:
                        numpy array: Smoothed signal.
                        """
                        mask = ~np.isnan(Y)  # Create a boolean mask for non-NaN values
                        Y[mask] = nanfastsmooth_core(Y[mask], w, type, tol)  # Apply smoothing to non-NaN values
                        return Y

                    # Function for Shannon entropy enveloped type calculating. For default the value = 3
                    def nanfastsmooth_core(Y, w, type, tol):
                        if type == 1:
                            SmoothY = moving_average(Y, w)
                        elif type == 2:
                            SmoothY = moving_average(moving_average(Y, w), w)
                        elif type == 3:
                            SmoothY = moving_average(moving_average(moving_average(Y, w), w), w)

                        return SmoothY

                    def moving_average(Y, window_size):
                        return np.convolve(Y, np.ones(window_size)/window_size, mode='same')

                    def calcular_indice_frecuencias(datos, frecuencia_muestreo):
                        # Aplicar filtro en frecuencia
                        freq_bajas = (1, 5.5)
                        freq_altas = (6, 16)

                        datos_bajas = apply_bandpass_filter(datos, frecuencia_muestreo, freq_bajas)
                        datos_altas = apply_bandpass_filter(datos, frecuencia_muestreo, freq_altas)

                        # Calcular energía para cada señal
                        energia_bajas = np.sum(datos_bajas ** 2)
                        energia_altas = np.sum(datos_altas ** 2)

                        # Calcular índice de frecuencias
                        indice_frecuencias = np.log(energia_altas / energia_bajas) if energia_bajas != 0 else np.nan
                        return indice_frecuencias

                    def apply_bandpass_filter(datos, frecuencia_muestreo, freq_band):
                        nyquist = 0.5 * frecuencia_muestreo
                        normal_freq_band = np.array(freq_band) / nyquist
                        b, a = signal.butter(4, normal_freq_band, btype='band')
                        datos_filtrados = signal.filtfilt(b, a, datos)
                        return datos_filtrados

                    # Start entropy and averaged entropy values
                    entropia_shannon = []
                    entropia_promediada = []
                    kurtosis_resultados = []
                    frequency_index = []

                    # Cycle for the day-by-day calculation of the entropy in the files contained in the folder, using the time range (Start to End)
                    for dia in range(1, timeIn + 1):

                        archivo = Nombre3 + '.'+ f"{dia:003}"       # Here you select the name previously calculated plus point and the value of each Julian day

                        # If there is no file in the list, the entire day is added with a value of zero
                        if not os.path.exists(os.path.join(carpeta, archivo)):
                            for _ in range(24):  # Adds 24 hours with zero value if there is no file
                                entropia_shannon.append(0)
                                entropia_promediada.append(0)
                                kurtosis_resultados.append(0)
                                frequency_index.append(0)
                            continue

                        # Designation of the data contained in the folder files
                        st = Stream()
                        st += read(os.path.join(carpeta, archivo))
                        frecuencia_muestreo = st[0].stats.sampling_rate
                        # calculation of the Bandstop filter with the parameters indicated by the user.
                        st.filter('bandstop', freqmin=frec7, freqmax=frec8, corners=orden7, zerophase=True)
                        # Data value
                        datos = st[0].data

                        # Divide the data into hours and calculate entropy for each hour.
                        for hora in range(24):
                            inicio = hora * 1440  # start of time in seconds.
                            fin = inicio + 84600  # End of time in seconds.
                            datos_hora = datos[inicio:fin]

                            if len(datos_hora) < 86400:  # If the hour is incomplete, add zeros to the end.
                                datos_hora = np.append(datos_hora, np.zeros(86400 - len(datos_hora)))

                            # Accumulator of the calculated values of the Shannon entropy and the averaged entropy.
                            entropia_shannon.append(calcular_entropia(datos_hora))
                            entropia_promediada.append(calcular_entropia(datos_hora) / len(datos_hora))
                            kurtosis_resultados.append(calcular_kurtosis(datos_hora))
                            frequency_index.append(calcular_indice_frecuencias(datos_hora, frecuencia_muestreo))

                    # Converting shannon entropy value and averaged entropy to data array.
                    entropia_shannon = np.array(entropia_shannon)
                    entropia_promediada = np.array(entropia_promediada)
                    kurtosis_resultados = np.array(kurtosis_resultados)
                    frequency_index=np.array(frequency_index)

                    # Shannon Entropy Graph. Value of non-zero indices where there is no data.
                    indices_no_cero_shannon = np.where(entropia_shannon != 0)[0]

                    indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                    indices_no_cero_frecuency = np.where(frequency_index != 0)[0]

                    indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]

                    # **** SAVE THE RESULTS FILE .CSV
                    archivoFil2 = (self.label_8.text())                         # Reading directory label.

                    # **** SAVE THE RESULTS .npy FILE FOR LATER GRAPH *****
                    TW = str(Tam1)                                              # Convert Envelope Window value to string for names.
                    F1 = (Nombre3 + '_Bandstop_Filter_24_Hrs_without_Time_interval_Dots_and_Time' + '_Windows=' + TW + '.csv')            # Assign F1, Capture the name of the record and add the .csv extension.

                    # Guardar resultados en archivos .npy
                    F1a = (Nombre3 + '_Bandstop_Filter_24_Hrs_without_Time_interval_Dots_and_Time' + '_Windows=' + TW)
                    F2 = (archivoFil2 + F1)                                     # Assigns to F2 the directory plus the previous name where the record will be stored.
                    F3 = (archivoFil2 + F1a)

                    with open(F2, 'w+', newline='') as archivo_csv:             # Each result is saved in the file, day, time and values of Shannon's entropy and averaged.
                        writer = csv.writer(archivo_csv)
                        writer.writerow(['Day', ' hour', ' Shannon Entropy', ' Averaged Shannon Entropy', ' Enveloped Shannon Entropy', ' Kurtosis', ' Frequency Index'])

                        for dia in range(1, timeIn + 1):                        # Save data by day and time according to the time interval (Start - End)
                            for hora in range(24):
                                writer.writerow([dia, hora, entropia_shannon[(dia - 1) * 24 + hora], entropia_promediada[(dia - 1) * 24 + hora], kurtosis_resultados[(dia - 1) * 24 + hora], frequency_index[(dia - 1) * 24 + hora] ])

                    # Use example
                    Y = entropia_shannon
                    Y = np.where(Y == 0, np.nan, Y)

                    Y1 = kurtosis_resultados
                    Y1 = np.where(Y1 == 0, np.nan, Y1)

                    Y2 = frequency_index
                    Y2 = np.where(Y2 == 0, np.nan, Y2)                                             # Close the existing chart.

                    if self.checkBox_2.isChecked():                                 # CheckBox 2 of the Initial Time is activated (This marks time on the x axis)

                        if not self.lineEdit_14.text():
                            MensCombo14 = QMessageBox()
                            MensCombo14.setIcon(QMessageBox.Warning)
                            MensCombo14.setWindowTitle("Empty Year value")
                            MensCombo14.setText("Please, enter a valid value")
                            returnValue = MensCombo14.exec()

                        elif not self.lineEdit_15.text():
                            MensCombo15 = QMessageBox()
                            MensCombo15.setIcon(QMessageBox.Warning)
                            MensCombo15.setWindowTitle("Empty Month value")
                            MensCombo15.setText("Please, enter a valid value")
                            returnValue = MensCombo15.exec()

                        elif not self.lineEdit_16.text():
                            MensCombo16 = QMessageBox()
                            MensCombo16.setIcon(QMessageBox.Warning)
                            MensCombo16.setWindowTitle("Empty Day value")
                            MensCombo16.setText("Please, enter a valid value")
                            returnValue = MensCombo16.exec()

                        else:

                            # Data entry for enveloped (this value is a string by default)
                            Anio = (self.lineEdit_14.text())                            # Reading the Year value label.
                            Mes = (self.lineEdit_15.text())                             # Reading the Month value label.
                            Dia1 = (self.lineEdit_16.text())                            # Reading the Day value label.

                            # Convert the string value of the input text boxes to  integer

                            Anio1=int(Anio)                                             # Converts the Year value to integer.
                            Mes1=int(Mes)                                               # Converts the Month value to integer.
                            Dia2=int(Dia1)                                              # Converts the NaN Day value to integer.

                            # The date vector is created
                            fecha_inicio = datetime(Anio1, Mes1, Dia2)
                            dias = [fecha_inicio + timedelta(hours=i) for i in range(len(entropia_shannon[indices_no_cero_shannon]))]

                            # "Indices_no_cero_shannon" = np.where(entropia_shannon != 0)[0]
                            st = (dias, entropia_shannon[indices_no_cero_shannon])
                            np.save(F3, st)  # Save the ".npy" file in the directory.
                            plt.close()

                            st = (dias, entropia_shannon[indices_no_cero_shannon])

                            # Save the ".npy" file in the directory.
                            np.save(F3, st)
                            plt.close()                                             # Close the existing chart.

                            # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                            # Graph 1 - ENTROPY BY POINTS.

                            plt.plot(dias, entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='ShannonEntropy: Points per hour -> 24 Hrs.')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_ShannonEntropy: Each point = 24 Hrs. with Bandstop filter', color ="darkgreen", fontsize=18)

                            # Graph 2 - Averaged Shannon Entropy Graph.

                            fig, ax = plt.subplots(1,1)
                            indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                            plt.plot(dias, entropia_promediada[indices_no_cero_promediada], "ob", mfc="b", mec = "b", label='ShannonAveragedEntropy: Points per hour -> 24 Hrs.')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Shannon Averaged Entropy: Each point = 24 Hrs. with Bandstop filter.', color ="darkgreen", fontsize=18)

                            # Graph 3 - Graph of Shannon Entropy with the envelope.

                            # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE.

                            fig, ax = plt.subplots(1,1)

                            y_filtered = nanfastsmooth(Y.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                            plt.plot(dias, entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='Shannon_Entropy')
                            plt.plot(dias, y_filtered[indices_no_cero_shannon], color='blue', label='Envelope')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Envelope - Shannon Entropy: Each point = 24 Hrs. with Bandstop filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            # Graph 4 - Envelope only graph.

                            fig, ax = plt.subplots(1,1)

                            plt.plot(dias, y_filtered[indices_no_cero_shannon], label='Filtered Signal', color='blue')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                            plt.title(Nombre3 + '_Only the envelope of Shannon entropy: Each point = 24 Hrs. with Bandstop filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                            # Graph 5 Frequency Index with enveloped
                            fig, ax = plt.subplots(1,1)

                            y_filtered3 = nanfastsmooth(Y2.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                            plt.plot(dias, frequency_index[indices_no_cero_frecuency], 'o-', label='Frequency Index')
                            plt.plot(dias, y_filtered3[indices_no_cero_frecuency], label='Envelope', color='red')

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                            plt.title(Nombre3 + ' Frequency Index: Each point = 24 Hrs. with Bandstop filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            # Graph 6 Kurtosis with Envelope
                            fig, ax = plt.subplots(1,1)
                            indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]

                            # The date vector is created
                            fecha_inicio = datetime(Anio1, Mes1, Dia2)
                            dias2 = [fecha_inicio + timedelta(hours=i) for i in range(len(entropia_shannon[indices_no_cero_kurtosis]))]

                            y_filtered2 = nanfastsmooth(Y1.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                            plt.plot(dias2, kurtosis_resultados[indices_no_cero_kurtosis], 'o', label='Kurtosis')
                            plt.plot(dias2, y_filtered2[indices_no_cero_kurtosis], label='Envelope', color='red')
                            plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                            plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                            plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                            plt.title(Nombre3 + ' Kurtosis: Each point = 24 Hrs. with Bandstop filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)

                            plt.show()

                    else:

                        # Plot the vectors into separate figures.
                        dias = np.arange(1, 8761 + 1)

                        st = (dias, entropia_shannon[indices_no_cero_shannon])

                        np.save(F3, st)  # Save the ".npy" file in the directory.
                        plt.close()

                        # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                        # Graph 1 - ENTROPY BY POINTS.

                        plt.plot(dias[indices_no_cero_shannon], entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='ShannonEntropy: Points per hour -> 24 Hrs.')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_ShannonEntropy: Each point = 24 Hrs. with Bandstop filter', color ="darkgreen", fontsize=18)

                        # Graph 2 - Averaged Shannon Entropy Graph.

                        fig, ax = plt.subplots(1,1)
                        indices_no_cero_promediada = np.where(entropia_promediada != 0)[0]

                        plt.plot(dias[indices_no_cero_promediada], entropia_promediada[indices_no_cero_promediada], "ob", mfc="b", mec = "b", label='ShannonAveragedEntropy: Points per hour -> 24 Hrs.')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Shannon Averaged Entropy: Each point = 1 Hr. with Bandstop filter.', color ="darkgreen", fontsize=18)

                        # Graph 3 - Graph of Shannon Entropy with the envelope.

                        # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE.

                        fig, ax = plt.subplots(1,1)

                        y_filtered = nanfastsmooth(Y.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                        plt.plot(dias[indices_no_cero_shannon], entropia_shannon[indices_no_cero_shannon], "ob", mfc="r", mec = "r", label='Shannon Entropy')
                        plt.plot(dias[indices_no_cero_shannon], y_filtered[indices_no_cero_shannon], label='Envelope', color='blue')
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Envelope - Shannon Entropy: Each point = 24 Hrs. with Bandstop filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                        # Graph 4 - Envelope only graph.

                        fig, ax = plt.subplots(1,1)

                        plt.plot(dias[indices_no_cero_shannon], y_filtered[indices_no_cero_shannon], label='Filtered Signal', color='blue')

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                        plt.title(Nombre3 + '_Only the envelope of Shannon entropy: Each point = 24 Hrs. with Bandstop filter.' + " Envelope Windows = " + TW, color ="darkgreen", fontsize=14)

                        # Graph 5 Frequency Index with Envelope
                        fig, ax = plt.subplots(1,1)

                        y_filtered3 = nanfastsmooth(Y2.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                        plt.plot(dias[indices_no_cero_frecuency], frequency_index[indices_no_cero_frecuency], 'o-', label='Frequency Index')
                        plt.plot(dias[indices_no_cero_frecuency], y_filtered3[indices_no_cero_frecuency], label='Envelope', color='red')
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                        plt.title(Nombre3 + ' Frequency Index: Each point = 24 Hrs. with Bandstop filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)

                        # Graph 6 Kurtosis with Envelope
                        fig, ax = plt.subplots(1,1)
                        indices_no_cero_kurtosis = np.where(kurtosis_resultados != 0)[0]
                        #dias2 = [fecha_inicio + timedelta(hours=i) for i in range(len(entropia_shannon[indices_no_cero_kurtosis]))]

                        y_filtered2 = nanfastsmooth(Y1.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                        plt.plot(dias[indices_no_cero_kurtosis], kurtosis_resultados[indices_no_cero_kurtosis], 'o', label='Kurtosis')
                        plt.plot(dias[indices_no_cero_kurtosis], y_filtered2[indices_no_cero_kurtosis], label='Envelope', color='red')
                        plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left

                        plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                        plt.ylabel('Value', fontfamily="serif", fontweight='bold', fontsize=18, color='blue')
                        plt.title(Nombre3 + ' Kurtosis: Each point = 24 Hrs. with Bandstop filter.' + " Envelope Windows =  " + TW , color ="darkgreen", fontsize=14)

                        plt.show()

        except:                         # In any other case of invalid or empty inputs
                plt.close()                                                 # Close the existing chart.
                msgBox = QMessageBox()
                msgBox.setIcon(QMessageBox.Warning)
                msgBox.setText("The File Does not exist, is Invalid or the CSV old file is open. Please close, try again ...")
                msgBox.setWindowTitle("Invalid Record inputs or CSV Old file is open ")
                returnValue = msgBox.exec()
                pass


    """ Function to go back at home (Main Menu) """

    def Back1(self):                                                        # Call function to Menu Module (Back)
        if sistema == "Windows":                                            # If the system is Windows
            plt.close()                                                     # Close the existing chart.
            subprocess.Popen(["python", "Menu1.py"])
            app.quit()
            #print("We are in {}".format(sistema))
        else:                                                               # If the system is Linux
            plt.close()                                                     # Close the existing chart
            subprocess.Popen(["python3", "Menu1.py"])
            app.quit()

    """  Fuction to exit system  """

    def Exit1(self):                                # Call function to show exit dialog box
        msg = QMessageBox()
        msg.setIcon(QMessageBox.Question)
        msg.setWindowTitle("Exit Entropy estimator")
        msg.setText("Are you sure to exit the Entropy estimator?")
        msg.setStandardButtons(QMessageBox.Ok | QMessageBox.Cancel)
        msg.setDefaultButton(QMessageBox.Ok)                            # By default, the focus is on the OK button
        returnValue = msg.exec()
        if returnValue == QMessageBox.Ok:                               # If the answer is OK
            app.closeAllWindows()                                       # Close all windows and exit
            app.quit()



if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())
    # Developed by: Ligdamis A. Gutiérrez E. PhD.
    # Shannon Entropy Work by Pablo Rey D.

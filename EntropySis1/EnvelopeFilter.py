# -*- coding: utf-8 -*-

# Created by: PyQt5 UI code generator 5.15.2 and modified by later code editing
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

# Developed by: Ligdamis A. GutiÃ©rrez E. PhD.
# Shannon Entropy estimator for Characterization of Volcanic Seismic Signals

# Andalusian Institute of Geophysics,
# Signal Theory, Telematics and Communications Department,
# Department of Theoretical Physics and the Cosmos,
# Science Faculty,
# Granada University, (Ugr), Spain, 2023

# FEMALE (PID2019-106260GB-I00) and PROOF334 FOREVER (EUR2022.134044) Spanish projects)
# Spanish Project PID2022-143083NB-100 founded by MCIN/AEI/10.13039/501100011033
# and by FEDER (EU) "Unam manera de hacer Europa".

''' WARNING: Do not modify or edit the code without permission of the author.
    In case of using this software, indicate and refer to the author and the institution he represents.
    The University of Granada, Ugr '''

# Program: EnvelopeFilter.py -> Performs the read, filtering and plot the entropy envelope with various frequencies.

# Load libraries to use

# For system use, threads and paths (path)
import sys
import os
import csv
import subprocess
import pathlib
from pathlib import Path

# Library for NumPy that provides support for creating vectors and matrices
# and scipy for the stadistics
import numpy as np
import scipy.stats as stats
from scipy import ndimage, datasets

# Libraries for the use of PyQt5 - binding of the graphical Qt library
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import QApplication, QWidget, QMessageBox
from PyQt5 import QtCore, QtGui, QtWidgets, uic

# Libraries for the use Matplotlib for make Graphics
import matplotlib.pyplot as plt
import matplotlib.dates as dates
import matplotlib.dates as mdates
from matplotlib.dates import DateFormatter
from matplotlib.ticker import MultipleLocator
import matplotlib.dates as mdates

# Use of the obspy Library, for seismic data processing.
# It contains routines for reading and analyzing time series of seismic records
# in the most general formats used in observatories (MSEED, SAC, etc.)
from obspy import read, Stream

# for use de time
import datetime
from datetime import date, timedelta
from datetime import date, time, datetime

# Identify the operating system
import platform
sistema = platform.system()  # Identify the operating system

# Libraries to use tkinter (Graphical interface)
import tkinter
from tkinter import *
import tkinter as tk
from tkinter.ttk import Combobox, Style
from tkinter import Frame, IntVar, Label, filedialog, Entry, Radiobutton, CURRENT

# For use the window as root (changes later)
root = tk.Tk()
root.withdraw()


class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(1098, 542)
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap("Images/Ugr.gif"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        MainWindow.setWindowIcon(icon)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")

        # Set Frame

        self.frame = QtWidgets.QFrame(self.centralwidget)
        self.frame.setGeometry(QtCore.QRect(10, 10, 1081, 231))
        palette = QtGui.QPalette()
        brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Base, brush)
        brush = QtGui.QBrush(QtGui.QColor(216, 225, 240))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Window, brush)
        brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Base, brush)
        brush = QtGui.QBrush(QtGui.QColor(216, 225, 240))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Window, brush)
        brush = QtGui.QBrush(QtGui.QColor(216, 225, 240))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Base, brush)
        brush = QtGui.QBrush(QtGui.QColor(216, 225, 240))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Window, brush)
        self.frame.setPalette(palette)
        self.frame.setAutoFillBackground(True)
        self.frame.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.frame.setFrameShadow(QtWidgets.QFrame.Plain)
        self.frame.setObjectName("frame")

        self.frame_2 = QtWidgets.QFrame(self.centralwidget)
        self.frame_2.setGeometry(QtCore.QRect(10, 250, 791, 271))
        palette = QtGui.QPalette()
        brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Base, brush)
        brush = QtGui.QBrush(QtGui.QColor(240, 228, 181))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Window, brush)
        brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Base, brush)
        brush = QtGui.QBrush(QtGui.QColor(240, 228, 181))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Window, brush)
        brush = QtGui.QBrush(QtGui.QColor(240, 228, 181))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Base, brush)
        brush = QtGui.QBrush(QtGui.QColor(240, 228, 181))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Window, brush)
        self.frame_2.setPalette(palette)
        self.frame_2.setAutoFillBackground(True)
        self.frame_2.setFrameShape(QtWidgets.QFrame.Panel)
        self.frame_2.setFrameShadow(QtWidgets.QFrame.Raised)
        self.frame_2.setObjectName("frame_2")

        self.frame_5 = QtWidgets.QFrame(self.centralwidget)
        self.frame_5.setGeometry(QtCore.QRect(800, 240, 291, 281))
        palette = QtGui.QPalette()
        brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Base, brush)
        brush = QtGui.QBrush(QtGui.QColor(216, 225, 240))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Window, brush)
        brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Base, brush)
        brush = QtGui.QBrush(QtGui.QColor(216, 225, 240))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Window, brush)
        brush = QtGui.QBrush(QtGui.QColor(216, 225, 240))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Base, brush)
        brush = QtGui.QBrush(QtGui.QColor(216, 225, 240))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Window, brush)
        self.frame_5.setPalette(palette)
        self.frame_5.setAutoFillBackground(True)
        self.frame_5.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.frame_5.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.frame_5.setObjectName("frame_5")

        # Set line

        self.line = QtWidgets.QFrame(self.frame)
        self.line.setGeometry(QtCore.QRect(133, 0, 20, 231))
        self.line.setFrameShape(QtWidgets.QFrame.VLine)
        self.line.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line.setObjectName("line")

        self.line_2 = QtWidgets.QFrame(self.frame)
        self.line_2.setGeometry(QtCore.QRect(640, 120, 20, 111))
        self.line_2.setFrameShape(QtWidgets.QFrame.VLine)
        self.line_2.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_2.setObjectName("line_2")

        self.line_3 = QtWidgets.QFrame(self.frame)
        self.line_3.setGeometry(QtCore.QRect(930, 140, 20, 91))
        self.line_3.setFrameShape(QtWidgets.QFrame.VLine)
        self.line_3.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_3.setObjectName("line_3")

        self.line_4 = QtWidgets.QFrame(self.frame)
        self.line_4.setGeometry(QtCore.QRect(780, 0, 20, 231))
        self.line_4.setFrameShape(QtWidgets.QFrame.VLine)
        self.line_4.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_4.setObjectName("line_4")

        self.line_5 = QtWidgets.QFrame(self.frame_2)
        self.line_5.setGeometry(QtCore.QRect(0, 110, 791, 16))
        self.line_5.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_5.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_5.setObjectName("line_5")

        self.line_6 = QtWidgets.QFrame(self.frame_5)
        self.line_6.setGeometry(QtCore.QRect(140, 0, 20, 281))
        self.line_6.setFrameShape(QtWidgets.QFrame.VLine)
        self.line_6.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_6.setObjectName("line_6")

        self.line_7 = QtWidgets.QFrame(self.frame)
        self.line_7.setGeometry(QtCore.QRect(350, 120, 20, 111))
        self.line_7.setFrameShape(QtWidgets.QFrame.VLine)
        self.line_7.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_7.setObjectName("line_7")

        self.line_8 = QtWidgets.QFrame(self.frame)
        self.line_8.setGeometry(QtCore.QRect(460, 120, 20, 111))
        self.line_8.setFrameShape(QtWidgets.QFrame.VLine)
        self.line_8.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_8.setObjectName("line_8")

        self.line_9 = QtWidgets.QFrame(self.frame)
        self.line_9.setGeometry(QtCore.QRect(0, 110, 141, 16))
        self.line_9.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_9.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_9.setObjectName("line_9")

        self.line_11 = QtWidgets.QFrame(self.frame)
        self.line_11.setGeometry(QtCore.QRect(140, 110, 651, 16))
        self.line_11.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_11.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_11.setObjectName("line_11")

        self.line_13 = QtWidgets.QFrame(self.frame)
        self.line_13.setGeometry(QtCore.QRect(790, 130, 291, 20))
        self.line_13.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_13.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_13.setObjectName("line_13")

        self.line_16 = QtWidgets.QFrame(self.frame_5)
        self.line_16.setGeometry(QtCore.QRect(0, 60, 291, 16))
        self.line_16.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_16.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_16.setObjectName("line_16")

        self.line_17 = QtWidgets.QFrame(self.frame_5)
        self.line_17.setGeometry(QtCore.QRect(0, 130, 291, 16))
        self.line_17.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_17.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_17.setObjectName("line_17")

        self.line_18 = QtWidgets.QFrame(self.frame_5)
        self.line_18.setGeometry(QtCore.QRect(0, 200, 291, 21))
        self.line_18.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_18.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_18.setObjectName("line_18")

        self.line_19 = QtWidgets.QFrame(self.frame_2)
        self.line_19.setGeometry(QtCore.QRect(135, 117, 20, 155))
        self.line_19.setFrameShape(QtWidgets.QFrame.VLine)
        self.line_19.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_19.setObjectName("line_19")

        self.line_20 = QtWidgets.QFrame(self.frame_2)
        self.line_20.setGeometry(QtCore.QRect(640, 117, 20, 155))
        self.line_20.setFrameShape(QtWidgets.QFrame.VLine)
        self.line_20.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_20.setObjectName("line_20")

        #w Set labels

        self.label = QtWidgets.QLabel(self.frame)
        self.label.setGeometry(QtCore.QRect(30, 20, 91, 81))
        self.label.setText("")
        self.label.setPixmap(QtGui.QPixmap("Images/Ugr.gif"))
        self.label.setScaledContents(True)
        self.label.setObjectName("label")

        self.label_2 = QtWidgets.QLabel(self.frame)
        self.label_2.setGeometry(QtCore.QRect(30, 130, 91, 81))
        self.label_2.setText("")
        self.label_2.setPixmap(QtGui.QPixmap("Images/IAG.gif"))
        self.label_2.setScaledContents(True)
        self.label_2.setObjectName("label_2")

        self.label_3 = QtWidgets.QLabel(self.frame)
        self.label_3.setGeometry(QtCore.QRect(190, 10, 531, 31))
        font = QtGui.QFont()
        font.setFamily("Times New Roman")
        font.setPointSize(36)
        font.setBold(True)
        font.setItalic(True)
        font.setWeight(75)
        self.label_3.setFont(font)
        self.label_3.setObjectName("label_3")

        self.label_4 = QtWidgets.QLabel(self.frame_2)
        self.label_4.setGeometry(QtCore.QRect(190, 150, 420, 71))
        self.label_4.setText("")
        self.label_4.setPixmap(QtGui.QPixmap("Images/Logodepto.gif"))
        self.label_4.setScaledContents(True)
        self.label_4.setObjectName("label_4")

        self.label_5 = QtWidgets.QLabel(self.frame_2)
        self.label_5.setGeometry(QtCore.QRect(10, 40, 771, 41))
        palette = QtGui.QPalette()
        brush = QtGui.QBrush(QtGui.QColor(0, 0, 0))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.WindowText, brush)
        brush = QtGui.QBrush(QtGui.QColor(170, 255, 255))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Window, brush)
        brush = QtGui.QBrush(QtGui.QColor(0, 0, 0))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.WindowText, brush)
        brush = QtGui.QBrush(QtGui.QColor(170, 255, 255))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Window, brush)
        brush = QtGui.QBrush(QtGui.QColor(120, 120, 120))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.WindowText, brush)
        brush = QtGui.QBrush(QtGui.QColor(240, 240, 240))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Window, brush)
        self.label_5.setPalette(palette)
        self.label_5.setAutoFillBackground(True)
        self.label_5.setFrameShape(QtWidgets.QFrame.Panel)
        self.label_5.setFrameShadow(QtWidgets.QFrame.Raised)
        self.label_5.setText("")
        self.label_5.setObjectName("label_5")

        self.label_6 = QtWidgets.QLabel(self.frame_2)
        self.label_6.setGeometry(QtCore.QRect(30, 10, 201, 16))
        self.label_6.setObjectName("label_6")

        self.label_18 = QtWidgets.QLabel(self.frame)
        self.label_18.setGeometry(QtCore.QRect(690, 190, 61, 16))
        font = QtGui.QFont()
        font.setPointSize(7)
        self.label_18.setFont(font)
        self.label_18.setObjectName("label_18")

        self.label_19 = QtWidgets.QLabel(self.frame)
        self.label_19.setGeometry(QtCore.QRect(680, 130, 71, 16))
        self.label_19.setObjectName("label_19")

        self.label_20 = QtWidgets.QLabel(self.frame)
        self.label_20.setGeometry(QtCore.QRect(960, 200, 61, 16))
        self.label_20.setObjectName("label_20")

        self.label_21 = QtWidgets.QLabel(self.frame)
        self.label_21.setGeometry(QtCore.QRect(960, 170, 61, 16))
        self.label_21.setObjectName("label_21")

        self.label_22 = QtWidgets.QLabel(self.frame)
        self.label_22.setGeometry(QtCore.QRect(860, 170, 61, 16))
        self.label_22.setObjectName("label_22")

        self.label_23 = QtWidgets.QLabel(self.frame)
        self.label_23.setGeometry(QtCore.QRect(800, 190, 51, 16))
        font = QtGui.QFont()
        font.setPointSize(7)
        self.label_23.setFont(font)
        self.label_23.setObjectName("label_23")

        self.label_24 = QtWidgets.QLabel(self.frame)
        self.label_24.setGeometry(QtCore.QRect(360, 40, 201, 16))
        self.label_24.setObjectName("label_24")

        self.label_25 = QtWidgets.QLabel(self.frame)
        self.label_25.setGeometry(QtCore.QRect(160, 80, 91, 21))
        self.label_25.setObjectName("label_25")

        self.label_26 = QtWidgets.QLabel(self.frame_5)
        self.label_26.setGeometry(QtCore.QRect(170, 10, 61, 16))
        self.label_26.setObjectName("label_26")

        self.label_27 = QtWidgets.QLabel(self.frame_2)
        self.label_27.setGeometry(QtCore.QRect(40, 140, 71, 21))
        self.label_27.setObjectName("label_27")

        self.label_28 = QtWidgets.QLabel(self.frame)
        self.label_28.setGeometry(QtCore.QRect(580, 170, 51, 16))
        font = QtGui.QFont()
        font.setPointSize(7)
        self.label_28.setFont(font)
        self.label_28.setObjectName("label_28")

        self.label_29 = QtWidgets.QLabel(self.frame_5)
        self.label_29.setGeometry(QtCore.QRect(170, 40, 61, 16))
        self.label_29.setObjectName("label_29")

        self.label_30 = QtWidgets.QLabel(self.frame_5)
        self.label_30.setGeometry(QtCore.QRect(10, 30, 51, 16))
        font = QtGui.QFont()
        font.setPointSize(7)
        self.label_30.setFont(font)
        self.label_30.setObjectName("label_30")

        self.label_33 = QtWidgets.QLabel(self.frame_5)
        self.label_33.setGeometry(QtCore.QRect(70, 10, 61, 16))
        self.label_33.setObjectName("label_33")

        self.label_34 = QtWidgets.QLabel(self.frame_5)
        self.label_34.setGeometry(QtCore.QRect(10, 100, 51, 16))
        font = QtGui.QFont()
        font.setPointSize(7)
        self.label_34.setFont(font)
        self.label_34.setObjectName("label_34")

        self.label_35 = QtWidgets.QLabel(self.frame_5)
        self.label_35.setGeometry(QtCore.QRect(170, 110, 61, 16))
        self.label_35.setObjectName("label_35")

        self.label_36 = QtWidgets.QLabel(self.frame_5)
        self.label_36.setGeometry(QtCore.QRect(70, 80, 61, 16))
        self.label_36.setObjectName("label_36")

        self.label_37 = QtWidgets.QLabel(self.frame_5)
        self.label_37.setGeometry(QtCore.QRect(170, 80, 61, 16))
        self.label_37.setObjectName("label_37")

        self.label_38 = QtWidgets.QLabel(self.frame_5)
        self.label_38.setGeometry(QtCore.QRect(10, 170, 51, 16))
        font = QtGui.QFont()
        font.setPointSize(7)
        self.label_38.setFont(font)
        self.label_38.setObjectName("label_38")

        self.label_39 = QtWidgets.QLabel(self.frame_5)
        self.label_39.setGeometry(QtCore.QRect(170, 180, 61, 16))
        self.label_39.setObjectName("label_39")

        self.label_40 = QtWidgets.QLabel(self.frame_5)
        self.label_40.setGeometry(QtCore.QRect(70, 150, 61, 16))
        self.label_40.setObjectName("label_40")

        self.label_41 = QtWidgets.QLabel(self.frame)
        self.label_41.setGeometry(QtCore.QRect(601, 74, 71, 31))
        self.label_41.setObjectName("label_41")

        self.label_42 = QtWidgets.QLabel(self.frame_5)
        self.label_42.setGeometry(QtCore.QRect(170, 150, 61, 16))
        self.label_42.setObjectName("label_42")

        self.label_43 = QtWidgets.QLabel(self.frame_5)
        self.label_43.setGeometry(QtCore.QRect(10, 240, 51, 16))
        font = QtGui.QFont()
        font.setPointSize(7)
        self.label_43.setFont(font)
        self.label_43.setObjectName("label_43")

        self.label_44 = QtWidgets.QLabel(self.frame_5)
        self.label_44.setGeometry(QtCore.QRect(170, 250, 61, 16))
        self.label_44.setObjectName("label_44")

        self.label_45 = QtWidgets.QLabel(self.frame_5)
        self.label_45.setGeometry(QtCore.QRect(70, 220, 61, 16))
        self.label_45.setObjectName("label_45")

        self.label_46 = QtWidgets.QLabel(self.frame_5)
        self.label_46.setGeometry(QtCore.QRect(170, 220, 61, 16))
        self.label_46.setObjectName("label_46")

        self.label_47 = QtWidgets.QLabel(self.frame)
        self.label_47.setGeometry(QtCore.QRect(410, 80, 71, 21))   # (160, 160, 71, 21)   (160, 80, 91, 21)
        self.label_47.setObjectName("label_47")

        self.label_48 = QtWidgets.QLabel(self.frame)
        self.label_48.setGeometry(QtCore.QRect(810, 140, 121, 21))
        self.label_48.setObjectName("label_48")

        self.label_49 = QtWidgets.QLabel(self.frame_2)
        self.label_49.setGeometry(QtCore.QRect(694, 140, 71, 21))   # 40, 140, 71, 21
        self.label_49.setObjectName("label_49")

        self.label_50 = QtWidgets.QLabel(self.frame)
        self.label_50.setGeometry(QtCore.QRect(950, 140, 121, 21))
        self.label_50.setObjectName("label_50")

        self.label_51 = QtWidgets.QLabel(self.frame)
        self.label_51.setGeometry(QtCore.QRect(480, 120, 81, 31))
        self.label_51.setObjectName("label_51")

        self.label_52 = QtWidgets.QLabel(self.frame)
        self.label_52.setGeometry(QtCore.QRect(580, 200, 51, 16))
        font = QtGui.QFont()
        font.setPointSize(7)
        self.label_52.setFont(font)
        self.label_52.setObjectName("label_52")

        self.label_53 = QtWidgets.QLabel(self.frame)
        self.label_53.setGeometry(QtCore.QRect(480, 160, 41, 31))
        self.label_53.setObjectName("label_53")

        self.label_54 = QtWidgets.QLabel(self.frame)
        self.label_54.setGeometry(QtCore.QRect(480, 190, 41, 31))
        self.label_54.setObjectName("label_54")

        self.label_55 = QtWidgets.QLabel(self.frame)
        self.label_55.setGeometry(QtCore.QRect(198, 125, 201, 16))
        self.label_55.setObjectName("label_55")

        self.label_56 = QtWidgets.QLabel(self.frame)
        self.label_56.setGeometry(QtCore.QRect(150, 150, 111, 20))
        self.label_56.setObjectName("label_56")

        self.label_57 = QtWidgets.QLabel(self.frame)
        self.label_57.setGeometry(QtCore.QRect(370, 130, 91, 89))   # 1024, 96, 111, 91     540, 145, 91, 89   380, 130, 71, 21
        self.label_57.setText("")
        self.label_57.setPixmap(QtGui.QPixmap("Images/LogoTSTC.gif"))
        self.label_57.setScaledContents(True)
        self.label_57.setObjectName("label_57")

        self.label_58 = QtWidgets.QLabel(self.frame)
        self.label_58.setGeometry(QtCore.QRect(150, 178, 201, 16))
        self.label_58.setObjectName("label_58")

        self.label_59 = QtWidgets.QLabel(self.frame)
        self.label_59.setGeometry(QtCore.QRect(150, 203, 201, 16))
        self.label_59.setObjectName("label_59")

        self.label_60 = QtWidgets.QLabel(self.frame)
        self.label_60.setGeometry(QtCore.QRect(282, 152, 71, 16))
        font = QtGui.QFont()
        font.setPointSize(7)
        self.label_60.setFont(font)
        self.label_60.setObjectName("label_60")

        self.label_61 = QtWidgets.QLabel(self.frame)
        self.label_61.setGeometry(QtCore.QRect(282, 178, 71, 16))
        font = QtGui.QFont()
        font.setPointSize(7)
        self.label_61.setFont(font)
        self.label_61.setObjectName("label_61")

        self.label_62 = QtWidgets.QLabel(self.frame)
        self.label_62.setGeometry(QtCore.QRect(282, 205, 71, 16))
        font = QtGui.QFont()
        font.setPointSize(7)
        self.label_62.setFont(font)
        self.label_62.setObjectName("label_62")

        # Set pushButtons

        self.pushButton = QtWidgets.QPushButton(self.frame)
        self.pushButton.setGeometry(QtCore.QRect(260, 70, 101, 41))
        palette = QtGui.QPalette()
        brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Button, brush)
        brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Window, brush)
        brush = QtGui.QBrush(QtGui.QColor(240, 240, 240))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Button, brush)
        brush = QtGui.QBrush(QtGui.QColor(240, 240, 240))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Window, brush)
        brush = QtGui.QBrush(QtGui.QColor(240, 240, 240))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Button, brush)
        brush = QtGui.QBrush(QtGui.QColor(240, 240, 240))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Window, brush)
        self.pushButton.setPalette(palette)
        self.pushButton.setAutoFillBackground(True)
        icon1 = QtGui.QIcon()
        icon1.addPixmap(QtGui.QPixmap("Images/Load.gif"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.pushButton.setIcon(icon1)
        self.pushButton.setObjectName("pushButton")

        self.pushButton_2 = QtWidgets.QPushButton(self.frame)
        self.pushButton_2.setGeometry(QtCore.QRect(678, 70, 101, 41))
        icon2 = QtGui.QIcon()
        icon2.addPixmap(QtGui.QPixmap("Images/Plot.gif"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.pushButton_2.setIcon(icon2)
        self.pushButton_2.setObjectName("pushButton_2")

        self.pushButton_3 = QtWidgets.QPushButton(self.frame)
        self.pushButton_3.setGeometry(QtCore.QRect(480, 70, 101, 41))   #I (230, 150, 101, 41)
        icon3 = QtGui.QIcon()
        icon3.addPixmap(QtGui.QPixmap("Images/Clean.gif"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.pushButton_3.setIcon(icon3)
        self.pushButton_3.setObjectName("pushButton_3")

        self.pushButton_4 = QtWidgets.QPushButton(self.frame_2)
        self.pushButton_4.setGeometry(QtCore.QRect(20, 170, 101, 51))
        palette = QtGui.QPalette()
        brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Button, brush)
        brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Window, brush)
        brush = QtGui.QBrush(QtGui.QColor(240, 240, 240))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Button, brush)
        brush = QtGui.QBrush(QtGui.QColor(240, 240, 240))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Window, brush)
        brush = QtGui.QBrush(QtGui.QColor(240, 240, 240))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Button, brush)
        brush = QtGui.QBrush(QtGui.QColor(240, 240, 240))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Window, brush)
        self.pushButton_4.setPalette(palette)
        self.pushButton_4.setAutoFillBackground(True)
        icon4 = QtGui.QIcon()
        icon4.addPixmap(QtGui.QPixmap("Images/Back.gif"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.pushButton_4.setIcon(icon4)
        self.pushButton_4.setObjectName("pushButton_4")

        self.pushButton_5 = QtWidgets.QPushButton(self.frame_2)
        self.pushButton_5.setGeometry(QtCore.QRect(670, 170, 101, 51))
        icon5 = QtGui.QIcon()
        icon5.addPixmap(QtGui.QPixmap("Images/Exit.gif"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.pushButton_5.setIcon(icon5)
        self.pushButton_5.setObjectName("pushButton_5")

        # Set LineEdit

        self.lineEdit_2 = QtWidgets.QLineEdit(self.frame)
        self.lineEdit_2.setGeometry(QtCore.QRect(530, 170, 41, 20))
        # Qt.ImhFormattedNumbersOnly -> Only allows the use of numbers including decimals and sign (-)
        self.lineEdit_2.setInputMethodHints(QtCore.Qt.ImhFormattedNumbersOnly)
        self.lineEdit_2.setInputMethodHints(QtCore.Qt.ImhPreferNumbers)
        self.lineEdit_2.setAlignment(QtCore.Qt.AlignCenter)                     # <----- Text AlignCenter
        self.lineEdit_2.setObjectName("lineEdit_2")

        self.lineEdit_3 = QtWidgets.QLineEdit(self.frame)
        self.lineEdit_3.setGeometry(QtCore.QRect(530, 200, 41, 20))
        # Qt.ImhFormattedNumbersOnly -> Only allows the use of numbers including decimals and sign (-)
        self.lineEdit_3.setInputMethodHints(QtCore.Qt.ImhFormattedNumbersOnly)
        self.lineEdit_3.setInputMethodHints(QtCore.Qt.ImhPreferNumbers)
        self.lineEdit_3.setAlignment(QtCore.Qt.AlignCenter)                     # <----- Text AlignCenter
        self.lineEdit_3.setObjectName("lineEdit_3")

        self.lineEdit_4 = QtWidgets.QLineEdit(self.frame)
        self.lineEdit_4.setGeometry(QtCore.QRect(700, 160, 41, 20))
        # Qt.ImhFormattedNumbersOnly -> Only allows the use of numbers including decimals and sign (-)
        self.lineEdit_4.setInputMethodHints(QtCore.Qt.ImhFormattedNumbersOnly)
        self.lineEdit_4.setInputMethodHints(QtCore.Qt.ImhPreferNumbers)
        self.lineEdit_4.setAlignment(QtCore.Qt.AlignCenter)                     # <----- Text AlignCenter
        self.lineEdit_4.setObjectName("lineEdit_4")

        self.lineEdit_5 = QtWidgets.QLineEdit(self.frame)
        self.lineEdit_5.setGeometry(QtCore.QRect(860, 190, 51, 20))
        # Qt.ImhFormattedNumbersOnly -> Only allows the use of numbers including decimals and sign (-)
        self.lineEdit_5.setInputMethodHints(QtCore.Qt.ImhFormattedNumbersOnly)
        self.lineEdit_5.setInputMethodHints(QtCore.Qt.ImhPreferNumbers)
        self.lineEdit_5.setAlignment(QtCore.Qt.AlignCenter)                     # <----- Text AlignCenter
        self.lineEdit_5.setObjectName("lineEdit_5")

        self.lineEdit_6 = QtWidgets.QLineEdit(self.frame_5)
        self.lineEdit_6.setGeometry(QtCore.QRect(70, 30, 51, 20))
        # Qt.ImhFormattedNumbersOnly -> Only allows the use of numbers including decimals and sign (-)
        self.lineEdit_6.setInputMethodHints(QtCore.Qt.ImhFormattedNumbersOnly)
        self.lineEdit_6.setInputMethodHints(QtCore.Qt.ImhPreferNumbers)
        self.lineEdit_6.setAlignment(QtCore.Qt.AlignCenter)                     # <----- Text AlignCenter
        self.lineEdit_6.setObjectName("lineEdit_6")

        self.lineEdit_7 = QtWidgets.QLineEdit(self.frame_5)
        self.lineEdit_7.setGeometry(QtCore.QRect(70, 100, 51, 20))
        # Qt.ImhFormattedNumbersOnly -> Only allows the use of numbers including decimals and sign (-)
        self.lineEdit_7.setInputMethodHints(QtCore.Qt.ImhFormattedNumbersOnly)
        self.lineEdit_7.setInputMethodHints(QtCore.Qt.ImhPreferNumbers)
        self.lineEdit_7.setAlignment(QtCore.Qt.AlignCenter)                     # <----- Text AlignCenter
        self.lineEdit_7.setObjectName("lineEdit_7")

        self.lineEdit_8 = QtWidgets.QLineEdit(self.frame_5)
        self.lineEdit_8.setGeometry(QtCore.QRect(70, 170, 51, 20))
        # Qt.ImhFormattedNumbersOnly -> Only allows the use of numbers including decimals and sign (-)
        self.lineEdit_8.setInputMethodHints(QtCore.Qt.ImhFormattedNumbersOnly)
        self.lineEdit_8.setInputMethodHints(QtCore.Qt.ImhPreferNumbers)
        self.lineEdit_8.setAlignment(QtCore.Qt.AlignCenter)                     # <----- Text AlignCenter
        self.lineEdit_8.setObjectName("lineEdit_8")

        self.lineEdit_9 = QtWidgets.QLineEdit(self.frame_5)
        self.lineEdit_9.setGeometry(QtCore.QRect(70, 240, 51, 20))
        # Qt.ImhFormattedNumbersOnly -> Only allows the use of numbers including decimals and sign (-)
        self.lineEdit_9.setInputMethodHints(QtCore.Qt.ImhFormattedNumbersOnly)
        self.lineEdit_9.setInputMethodHints(QtCore.Qt.ImhPreferNumbers)
        self.lineEdit_9.setAlignment(QtCore.Qt.AlignCenter)                     # <----- Text AlignCenter
        self.lineEdit_9.setObjectName("lineEdit_9")

        self.lineEdit_10 = QtWidgets.QLineEdit(self.frame)
        self.lineEdit_10.setGeometry(QtCore.QRect(1030, 170, 41, 20))
        # Qt.ImhFormattedNumbersOnly -> Only allows the use of numbers including decimals and sign (-)
        self.lineEdit_10.setInputMethodHints(QtCore.Qt.ImhFormattedNumbersOnly)
        self.lineEdit_10.setInputMethodHints(QtCore.Qt.ImhPreferNumbers)
        self.lineEdit_10.setAlignment(QtCore.Qt.AlignCenter)                    # <----- Text AlignCenter
        self.lineEdit_10.setObjectName("lineEdit_10")

        self.lineEdit_11 = QtWidgets.QLineEdit(self.frame)
        self.lineEdit_11.setGeometry(QtCore.QRect(1030, 200, 41, 20))
        # Qt.ImhFormattedNumbersOnly -> Only allows the use of numbers including decimals and sign (-)
        self.lineEdit_11.setInputMethodHints(QtCore.Qt.ImhFormattedNumbersOnly)
        self.lineEdit_11.setInputMethodHints(QtCore.Qt.ImhPreferNumbers)
        self.lineEdit_11.setAlignment(QtCore.Qt.AlignCenter)                    # <----- Text AlignCenter
        self.lineEdit_11.setObjectName("lineEdit_11")

        self.lineEdit_12 = QtWidgets.QLineEdit(self.frame_5)
        self.lineEdit_12.setGeometry(QtCore.QRect(240, 10, 41, 20))
        # Qt.ImhFormattedNumbersOnly -> Only allows the use of numbers including decimals and sign (-)
        self.lineEdit_12.setInputMethodHints(QtCore.Qt.ImhFormattedNumbersOnly)
        self.lineEdit_12.setInputMethodHints(QtCore.Qt.ImhPreferNumbers)
        self.lineEdit_12.setAlignment(QtCore.Qt.AlignCenter)                    # <----- Text AlignCenter
        self.lineEdit_12.setObjectName("lineEdit_12")

        self.lineEdit_13 = QtWidgets.QLineEdit(self.frame_5)
        self.lineEdit_13.setGeometry(QtCore.QRect(240, 40, 41, 20))
        # Qt.ImhFormattedNumbersOnly -> Only allows the use of numbers including decimals and sign (-)
        self.lineEdit_13.setInputMethodHints(QtCore.Qt.ImhFormattedNumbersOnly)
        self.lineEdit_13.setInputMethodHints(QtCore.Qt.ImhPreferNumbers)
        self.lineEdit_13.setAlignment(QtCore.Qt.AlignCenter)                    # <----- Text AlignCenter
        self.lineEdit_13.setObjectName("lineEdit_13")

        self.lineEdit_14 = QtWidgets.QLineEdit(self.frame_5)
        self.lineEdit_14.setGeometry(QtCore.QRect(240, 80, 41, 20))
        # Qt.ImhFormattedNumbersOnly -> Only allows the use of numbers including decimals and sign (-)
        self.lineEdit_14.setInputMethodHints(QtCore.Qt.ImhFormattedNumbersOnly)
        self.lineEdit_14.setInputMethodHints(QtCore.Qt.ImhPreferNumbers)
        self.lineEdit_14.setAlignment(QtCore.Qt.AlignCenter)                    # <----- Text AlignCenter
        self.lineEdit_14.setObjectName("lineEdit_14")

        self.lineEdit_15 = QtWidgets.QLineEdit(self.frame_5)
        self.lineEdit_15.setGeometry(QtCore.QRect(240, 110, 41, 20))
        # Qt.ImhFormattedNumbersOnly -> Only allows the use of numbers including decimals and sign (-)
        self.lineEdit_15.setInputMethodHints(QtCore.Qt.ImhFormattedNumbersOnly)
        self.lineEdit_15.setInputMethodHints(QtCore.Qt.ImhPreferNumbers)
        self.lineEdit_15.setAlignment(QtCore.Qt.AlignCenter)                    # <----- Text AlignCenter
        self.lineEdit_15.setObjectName("lineEdit_15")

        self.lineEdit_16 = QtWidgets.QLineEdit(self.frame_5)
        self.lineEdit_16.setGeometry(QtCore.QRect(240, 150, 41, 20))
        # Qt.ImhFormattedNumbersOnly -> Only allows the use of numbers including decimals and sign (-)
        self.lineEdit_16.setInputMethodHints(QtCore.Qt.ImhFormattedNumbersOnly)
        self.lineEdit_16.setInputMethodHints(QtCore.Qt.ImhPreferNumbers)
        self.lineEdit_16.setAlignment(QtCore.Qt.AlignCenter)                    # <----- Text AlignCenter
        self.lineEdit_16.setObjectName("lineEdit_16")

        self.lineEdit_17 = QtWidgets.QLineEdit(self.frame_5)
        self.lineEdit_17.setGeometry(QtCore.QRect(240, 180, 41, 20))
        # Qt.ImhFormattedNumbersOnly -> Only allows the use of numbers including decimals and sign (-)
        self.lineEdit_17.setInputMethodHints(QtCore.Qt.ImhFormattedNumbersOnly)
        self.lineEdit_17.setInputMethodHints(QtCore.Qt.ImhPreferNumbers)
        self.lineEdit_17.setAlignment(QtCore.Qt.AlignCenter)                    # <----- Text AlignCenter
        self.lineEdit_17.setObjectName("lineEdit_17")

        self.lineEdit_18 = QtWidgets.QLineEdit(self.frame_5)
        self.lineEdit_18.setGeometry(QtCore.QRect(240, 220, 41, 20))
        # Qt.ImhFormattedNumbersOnly -> Only allows the use of numbers including decimals and sign (-)
        self.lineEdit_18.setInputMethodHints(QtCore.Qt.ImhFormattedNumbersOnly)
        self.lineEdit_18.setInputMethodHints(QtCore.Qt.ImhPreferNumbers)
        self.lineEdit_18.setAlignment(QtCore.Qt.AlignCenter)                    # <----- Text AlignCenter
        self.lineEdit_18.setObjectName("lineEdit_18")

        self.lineEdit_19 = QtWidgets.QLineEdit(self.frame_5)
        self.lineEdit_19.setGeometry(QtCore.QRect(240, 250, 41, 20))
        # Qt.ImhFormattedNumbersOnly -> Only allows the use of numbers including decimals and sign (-)
        self.lineEdit_19.setInputMethodHints(QtCore.Qt.ImhFormattedNumbersOnly)
        self.lineEdit_19.setInputMethodHints(QtCore.Qt.ImhPreferNumbers)
        self.lineEdit_19.setAlignment(QtCore.Qt.AlignCenter)                    # <----- Text AlignCenter
        self.lineEdit_19.setObjectName("lineEdit_19")

        self.lineEdit_20 = QtWidgets.QLineEdit(self.frame)
        self.lineEdit_20.setGeometry(QtCore.QRect(230, 150, 41, 20))
        self.lineEdit_20.setInputMethodHints(QtCore.Qt.ImhPreferNumbers)
        rx2  = QtCore.QRegExp("[0-3]{999}")      # Format to only allow 3 integers
        val2 = QtGui.QRegExpValidator(rx2)
        self.lineEdit_20.setValidator(val2)
        self.lineEdit_20.setText("")
        self.lineEdit_20.setAlignment(QtCore.Qt.AlignCenter)              # <----- Text AlignCenter
        self.lineEdit_20.setDragEnabled(False)
        self.lineEdit_20.setValidator(val2)
        self.lineEdit_20.setObjectName("lineEdit_20")

        self.lineEdit_21 = QtWidgets.QLineEdit(self.frame)               # Smoothing type
        self.lineEdit_21.setGeometry(QtCore.QRect(230, 175, 41, 20))    # (225, 150, 41, 20)
        # Qt.ImhFormattedNumbersOnly -> Only allows the use of numbers including decimals and sign (-)
        self.lineEdit_21.setInputMethodHints(QtCore.Qt.ImhFormattedNumbersOnly)
        rx2  = QtCore.QRegExp("[0-3]{99}")      # Format to only allow 3 integers
        val2 = QtGui.QRegExpValidator(rx2)
        self.lineEdit_21.setValidator(val2)
        self.lineEdit_21.setInputMethodHints(QtCore.Qt.ImhPreferNumbers)
        self.lineEdit_21.setText("")
        self.lineEdit_21.setAlignment(QtCore.Qt.AlignCenter)              # <----- To Align text
        self.lineEdit_21.setDragEnabled(False)
        self.lineEdit_21.setValidator(val2)
        self.lineEdit_21.setObjectName("lineEdit_21")

        self.lineEdit_22 = QtWidgets.QLineEdit(self.frame)               # NaN Tolerance
        self.lineEdit_22.setGeometry(QtCore.QRect(230, 202, 41, 20))    # (225, 150, 41, 20)
        # Qt.ImhFormattedNumbersOnly -> Only allows the use of numbers including decimals and sign (-)
        self.lineEdit_22.setInputMethodHints(QtCore.Qt.ImhFormattedNumbersOnly)
        rx2  = QtCore.QRegExp("[0-3]{999}")      # Format to only allow 3 integers
        val2 = QtGui.QRegExpValidator(rx2)
        self.lineEdit_22.setValidator(val2)
        self.lineEdit_22.setInputMethodHints(QtCore.Qt.ImhPreferNumbers)
        self.lineEdit_22.setText("")
        self.lineEdit_22.setAlignment(QtCore.Qt.AlignCenter)              # <----- To Align text
        self.lineEdit_22.setDragEnabled(False)
        self.lineEdit_22.setValidator(val2)
        self.lineEdit_22.setObjectName("lineEdit_22")

        # Set groupBox

        self.groupBox_2 = QtWidgets.QGroupBox(self.frame)
        self.groupBox_2.setGeometry(QtCore.QRect(820, 10, 211, 101))
        palette = QtGui.QPalette()
        brush = QtGui.QBrush(QtGui.QColor(240, 255, 247))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Window, brush)
        brush = QtGui.QBrush(QtGui.QColor(240, 255, 247))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Window, brush)
        brush = QtGui.QBrush(QtGui.QColor(240, 255, 247))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Window, brush)
        self.groupBox_2.setPalette(palette)
        self.groupBox_2.setAutoFillBackground(True)
        self.groupBox_2.setObjectName("groupBox_2")

        self.comboBox_2 = QtWidgets.QComboBox(self.groupBox_2)
        self.comboBox_2.setGeometry(QtCore.QRect(10, 20, 191, 22))
        self.comboBox_2.setObjectName("comboBox_2")
        self.comboBox_2.addItem("")
        self.comboBox_2.addItem("")
        self.comboBox_2.addItem("")
        self.comboBox_2.addItem("")
        self.comboBox_2.addItem("")

        # Set CheckBox

        self.checkBox = QtWidgets.QCheckBox(self.frame)
        self.checkBox.setGeometry(QtCore.QRect(570, 130, 70, 17))
        self.checkBox.setObjectName("checkBox")

        MainWindow.setCentralWidget(self.centralwidget)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

        # Color and text formatting on Command Buttons
        self.pushButton.setStyleSheet("background-color: honeydew; color: blue")                # Text and Color of the Command Button (load records)
        self.pushButton_2.setStyleSheet("background-color: silver; color: blue")                # Text and Color of the Command Button (Plot Entropy)
        self.pushButton_3.setStyleSheet("background-color: skyblue; color: blue")               # Text and Color of the Command Button (Clean inputs)
        self.pushButton_4.setStyleSheet("background-color: bisque; color: blue")                # Text and Color of the Command Button (Back)  - bisque
        self.pushButton_5.setStyleSheet("background-color: CornflowerBlue; color: white")       # Text and Color of the Command Button (Exit)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "Performs the read, filtering and plot the entropy envelope with various frequencies - Granada University (Ugr)"))

        # PushButton Labels
        self.pushButton.setText(_translate("MainWindow", "Records"))
        self.pushButton_2.setText(_translate("MainWindow", " Plot Entropy"))
        self.pushButton_3.setText(_translate("MainWindow", "Clear entries"))
        self.pushButton_4.setText(_translate("MainWindow", " Back"))
        self.pushButton_5.setText(_translate("MainWindow", "  Exit"))

        # PushButton ToolTip
        self.pushButton.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-weight:600; color:#00007f;\">Load Records</span></p></body></html>"))
        self.pushButton_2.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-weight:600; color:#00007f;\">Plot Envelopes</span></p></body></html>"))
        self.pushButton_3.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-weight:600; color:#00007f;\">Clear Inputs</span></p></body></html>"))
        self.pushButton_4.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-weight:600; color:#00007f;\">Back to Menu</span></p></body></html>"))
        self.pushButton_5.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-weight:600; color:#aa0000;\">Exit System</span></p></body></html>"))

        # Set groupBox labels
        self.groupBox_2.setTitle(_translate("MainWindow", "Filter type"))
        self.comboBox_2.setItemText(0, _translate("MainWindow", "Please select"))
        self.comboBox_2.setItemText(1, _translate("MainWindow", "Lowpass"))
        self.comboBox_2.setItemText(2, _translate("MainWindow", "Highpass"))
        self.comboBox_2.setItemText(3, _translate("MainWindow", "Bandpass"))
        self.comboBox_2.setItemText(4, _translate("MainWindow", "Bandstop"))

        # Set checkBox labels
        self.checkBox.setText(_translate("MainWindow", "Yes/No"))

        # Set Labels text
        self.label_3.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:14pt; color:#0000ff;\">Comparison of entropy envelope using various filter frequencies</span></p></body></html>"))
        self.label_6.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-weight:600; color:#142cc8;\">Directory path to upload records:</span></p></body></html>"))
        self.label_18.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:6pt; font-weight:600; font-style:italic; color:#00007f;\">By default = 4</span></p></body></html>"))
        self.label_19.setText(_translate("MainWindow", "<html><head/><body><p align=\"center\"><span style=\" font-size:7pt; font-weight:600; font-style:italic; color:#aa5500;\">Filter Order</span></p></body></html>"))
        self.label_20.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:6pt; font-weight:600; font-style:italic; color:#aa5500;\">Frec Max (Hz):</span></p></body></html>"))
        self.label_21.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:6pt; font-weight:600; font-style:italic; color:#aa5500;\">Frec Min (Hz):</span></p></body></html>"))
        self.label_22.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:6pt; font-weight:600; color:#0055ff;\">Frecuency (Hz)</span></p></body></html>"))
        self.label_23.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-weight:600; font-style:italic; color:#00007f;\">Filter 1</span></p></body></html>"))
        self.label_24.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" color:#0000ff;\">Selection of loading records and plot files</span></p></body></html>"))
        self.label_25.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" color:#0000ff;\">Directory selection</span></p></body></html>"))
        self.label_26.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:6pt; font-weight:600; font-style:italic; color:#aa5500;\">Frec Min (Hz):</span></p></body></html>"))
        self.label_27.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" color:#0000ff;\">Back to menu </span></p></body></html>"))
        self.label_28.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:6pt; font-weight:600; font-style:italic; color:#00007f;\">Julian days</span></p></body></html>"))
        self.label_29.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:6pt; font-weight:600; font-style:italic; color:#aa5500;\">Frec Max (Hz):</span></p></body></html>"))
        self.label_30.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-weight:600; font-style:italic; color:#00007f;\">Filter 2</span></p></body></html>"))
        self.label_33.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:6pt; font-weight:600; color:#0055ff;\">Frecuency (Hz)</span></p></body></html>"))
        self.label_34.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-weight:600; font-style:italic; color:#00007f;\">Filter 3</span></p></body></html>"))
        self.label_35.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:6pt; font-weight:600; font-style:italic; color:#aa5500;\">Frec Max (Hz):</span></p></body></html>"))
        self.label_36.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:6pt; font-weight:600; color:#0055ff;\">Frecuency (Hz)</span></p></body></html>"))
        self.label_37.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:6pt; font-weight:600; font-style:italic; color:#aa5500;\">Frec Min (Hz):</span></p></body></html>"))
        self.label_38.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-weight:600; font-style:italic; color:#00007f;\">Filter 4</span></p></body></html>"))
        self.label_39.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:6pt; font-weight:600; font-style:italic; color:#aa5500;\">Frec Max (Hz):</span></p></body></html>"))
        self.label_40.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:6pt; font-weight:600; color:#0055ff;\">Frecuency (Hz)</span></p></body></html>"))
        self.label_41.setText(_translate("MainWindow", "<html><head/><body><p align=\"center\"><span style=\" color:#0000ff;\">Plot Envelope</span></p></body></html>"))
        self.label_42.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:6pt; font-weight:600; font-style:italic; color:#aa5500;\">Frec Min (Hz):</span></p></body></html>"))
        self.label_43.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-weight:600; font-style:italic; color:#00007f;\">Filter 5</span></p></body></html>"))
        self.label_44.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:6pt; font-weight:600; font-style:italic; color:#aa5500;\">Frec Max (Hz):</span></p></body></html>"))
        self.label_45.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:6pt; font-weight:600; color:#0055ff;\">Frecuency (Hz)</span></p></body></html>"))
        self.label_46.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:6pt; font-weight:600; font-style:italic; color:#aa5500;\">Frec Min (Hz):</span></p></body></html>"))
        self.label_47.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" color:#0000ff;\">Clear entries</span></p></body></html>"))
        self.label_48.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:7pt; color:#234735;\">Lowpass and Highpass filter</span></p></body></html>"))
        self.label_49.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" color:#0000ff;\">Exit System </span></p></body></html>"))
        self.label_50.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:7pt; color:#234735;\">Bandpass and Bandstop filter</span></p></body></html>"))
        self.label_51.setText(_translate("MainWindow", "<html><head/><body><p align=\"center\"><span style=\" color:#0000ff;\">Time interval</span></p></body></html>"))
        self.label_52.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:6pt; font-weight:600; font-style:italic; color:#00007f;\">Julian days</span></p></body></html>"))
        self.label_53.setText(_translate("MainWindow", "<html><head/><body><p align=\"center\"><span style=\" color:#0000ff;\">Start</span></p></body></html>"))
        self.label_54.setText(_translate("MainWindow", "<html><head/><body><p align=\"center\"><span style=\" color:#0000ff;\">End</span></p></body></html>"))
        self.label_55.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" color:#0000ff;\">Envelope parameters </span></p></body></html>"))
        self.label_56.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" color:#0000ff;\">Window width</span></p></body></html>"))
        self.label_58.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:6pt; color:#0000ff;\">Smoothing type (1-3) </span></p></body></html>"))
        self.label_59.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" color:#0000ff;\">NaN Tolerance </span></p></body></html>"))
        self.label_60.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:6pt; font-weight:600; font-style:italic; color:#00007f;\">By default = 50</span></p></body></html>"))
        self.label_61.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:6pt; font-weight:600; font-style:italic; color:#00007f;\">By default = 3</span></p></body></html>"))
        self.label_62.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:6pt; font-weight:600; font-style:italic; color:#00007f;\">By default = 1</span></p></body></html>"))

        # Validate so that only decimal numbers are accepted "QDoubleValidator": For "integers", you must put "QIntValidator".

        self.lineEdit_2.setValidator(QtGui.QIntValidator(1, 999))               # Only accepts numbers in the Start text box. Value three digits.
        self.lineEdit_3.setValidator(QtGui.QIntValidator(1, 999))               # Only accepts numbers in the End text box. Value three digits.
        self.lineEdit_4.setValidator(QtGui.QIntValidator(1, 99))                # Only accepts numbers in the filter order text box. Value two digits.
        self.lineEdit_20.setValidator(QtGui.QIntValidator(1, 9999))             # Only accepts numbers in the Envelope window size text box. Value four digits.
        self.lineEdit_21.setValidator(QtGui.QIntValidator(1, 99))               # Only accepts numbers in the Smoothing type text box. Value two digits.
        self.lineEdit_22.setValidator(QtGui.QIntValidator(1, 99))               # Only accepts numbers in the NaN Tolerance text box. Value two digits.

        # To work with Lowpass and Highpass filters.
        self.lineEdit_5.setValidator(QtGui.QDoubleValidator())                  # Only accepts decimal numbers in the frequency Filter 1 text box.
        self.lineEdit_6.setValidator(QtGui.QDoubleValidator())                  # Only accepts decimal numbers in the frequency Filter 2 text box.
        self.lineEdit_7.setValidator(QtGui.QDoubleValidator())                  # Only accepts decimal numbers in the frequency Filter 3 text box.
        self.lineEdit_8.setValidator(QtGui.QDoubleValidator())                  # Only accepts decimal numbers in the frequency Filter 4 text box.
        self.lineEdit_9.setValidator(QtGui.QDoubleValidator())                  # Only accepts decimal numbers in the frequency Filter 5 text box.

        # To work with Bandpass and Bandstop filters.
        self.lineEdit_10.setValidator(QtGui.QDoubleValidator())                 # Only accepts decimal numbers in the minimum frequency Filter 1 text box.
        self.lineEdit_11.setValidator(QtGui.QDoubleValidator())                 # Only accepts decimal numbers in the maximum frequency Filter 1 text box.

        self.lineEdit_12.setValidator(QtGui.QDoubleValidator())                 # Only accepts decimal numbers in the minimum frequency Filter 2 text box.
        self.lineEdit_13.setValidator(QtGui.QDoubleValidator())                 # Only accepts decimal numbers in the maximum frequency Filter 2 text box.

        self.lineEdit_14.setValidator(QtGui.QDoubleValidator())                 # Only accepts decimal numbers in the minimum frequency Filter 3 text box.
        self.lineEdit_15.setValidator(QtGui.QDoubleValidator())                 # Only accepts decimal numbers in the maximum frequency Filter 3 text box.

        self.lineEdit_16.setValidator(QtGui.QDoubleValidator())                 # Only accepts decimal numbers in the minimum frequency Filter 4 text box.
        self.lineEdit_17.setValidator(QtGui.QDoubleValidator())                 # Only accepts decimal numbers in the maximum frequency Filter 4 text box.

        self.lineEdit_18.setValidator(QtGui.QDoubleValidator())                 # Only accepts decimal numbers in the minimum frequency Filter 5 text box.
        self.lineEdit_19.setValidator(QtGui.QDoubleValidator())                 # Only accepts decimal numbers in the maximum frequency Filter 5 text box.

        # Set start LineEdit text boxes

        self.lineEdit_4.setText("4")                                        # Start filter order text box = 4.
        self.lineEdit_20.setText("50")                                      # Start Envelope window size text box = 50.
        self.lineEdit_21.setText("3")                                       # Starts initial Smoothing type text box contents = 3.
        self.lineEdit_22.setText("1")                                       # Start NaN Tolerance size text box = 1.

        # Disable text boxes again on startup

        self.lineEdit_2.setEnabled(False)                                   # Disable the Start time Text box.
        self.lineEdit_3.setEnabled(False)                                   # Disable the End time Text box.
        self.lineEdit_4.setEnabled(False)                                   # Disable the Filter Order Text box.

        self.lineEdit_5.setEnabled(False)                                   # Disable the Frequency Filter 1 text box.
        self.lineEdit_6.setEnabled(False)                                   # Disable the Frequency Filter 2 text box.
        self.lineEdit_7.setEnabled(False)                                   # Disable the Frequency Filter 3 text box.
        self.lineEdit_8.setEnabled(False)                                   # Disable the Frequency Filter 4 text box.
        self.lineEdit_9.setEnabled(False)                                   # Disable the Frequency Filter 5 text box.

        self.lineEdit_10.setEnabled(False)                                  # Disable the minimum frequency Filter 1 text box.
        self.lineEdit_11.setEnabled(False)                                  # Disable the maximum frequency Filter 1 text box.

        self.lineEdit_12.setEnabled(False)                                  # Disable the minimum frequency Filter 2 text box.
        self.lineEdit_13.setEnabled(False)                                  # Disable the maximum frequency Filter 2 text box.

        self.lineEdit_14.setEnabled(False)                                  # Disable the minimum frequency Filter 3 text box.
        self.lineEdit_15.setEnabled(False)                                  # Disable the maximum frequency Filter 3 text box.

        self.lineEdit_16.setEnabled(False)                                  # Disable the minimum frequency Filter 4 text box.
        self.lineEdit_17.setEnabled(False)                                  # Disable the maximum frequency Filter 4 text box.

        self.lineEdit_18.setEnabled(False)                                  # Disable the minimum frequency Filter 5 text box.
        self.lineEdit_19.setEnabled(False)                                  # Disable the maximum frequency Filter 5 text box.

        self.lineEdit_20.setEnabled(False)                                  # Disable the Envelope window size Text box.

        self.lineEdit_21.setEnabled(False)                                   # Disable Smoothing type text box.

        self.lineEdit_22.setEnabled(False)                                  # Disable NaN Tolerance Text box.

        #self.lineEdit_20.setEnabled(False)                                  # Disable the total days to analyze text box.

        # Disable pushButton (Plot Entropy) at startup
        self.pushButton_2.setEnabled(False)                                 # Disable the Plot Envelope Entropy Command Button.

        # Command button actions, function calls
        self.pushButton.clicked.connect(self.Load_records)                  # Call the function to upload file (Load Records).
        self.pushButton_2.clicked.connect(self.Plot_entropy)                # Call the function to Plot the envelope entropy filters (Plot Entropy).
        self.pushButton_3.clicked.connect(self.Clean_entries)               # Call the function to clean entries (Clean entries)
        self.pushButton_4.clicked.connect(self.Back1)                       # Call the function to return to the Home Screen (Back to menu).
        self.pushButton_5.clicked.connect(self.Exit1)                       # Calls the function to Exit (Exir module).

        # Call to the function according to the ComboBox list for the Filter type.
        self.comboBox_2.activated.connect(self.selection_changed1)

        # Call to the function according to the CheckBox
        self.checkBox.stateChanged.connect(self.state_changed2)


    """ -------------*** Start of Program Functions  ***------------ """

    """ Function to open and clean """

    def state_changed2(self):                                                # Para comprobar activaciÃ³n del checkBox, Si Lista
        if self.checkBox.isChecked():
            self.lineEdit_2.setEnabled(True)                                              # Enabled the Start time Text box.
            self.lineEdit_3.setEnabled(True)                                              # Enabled the End time Text box.

        else:
            self.lineEdit_2.setText("")                                                    # Clear the Start time Text box.
            self.lineEdit_3.setText("")                                                    # Clear the End time Text box.
            self.lineEdit_2.setEnabled(False)                                              # Disable the Start time Text box.
            self.lineEdit_3.setEnabled(False)                                              # Disable the End time Text box.

    def Load_records(self):                                 # Function to select the directory where the files are located.
        if sistema == "Windows":                            # Windows System.

            self.archivo_abierto3=filedialog.askdirectory(initialdir = "/",
              title = "Please Select Folder")

            self.ruta1 = Path(self.archivo_abierto3)
            self.ruta2 = self.ruta1.joinpath(self.ruta1).resolve()

            font=QtGui.QFont()
            font.setFamily("Times New Roman")
            font.setPointSize(8)
            font.setBold(False)
            font.setItalic(False)
            font.setWeight(60)
            self.label_5.setFont(font)                                          # Printing using text format.
            self.label_5.setText(self.archivo_abierto3 + "/")                   # Printing on the file path label.

        else:                                                                   # Linux System
            self.activacion4()                                                  # Call to the input cleaning function and Activation/Deactivation
            self.archivo_abierto3=filedialog.askdirectory(initialdir = "/",
              title = "Please Select Folder")

            self.ruta3 = Path(self.archivo_abierto3)
            self.ruta4 = self.ruta3.joinpath(self.ruta3).resolve()

            font=QtGui.QFont()
            font.setFamily("Times New Roman")
            font.setPointSize(8)
            font.setBold(False)
            font.setItalic(False)
            font.setWeight(60)
            self.label_5.setFont(font)                                          # Printing using text format.
            self.label_5.setText(self.archivo_abierto3 + "/")                   # Printing on the file path label.

    def Clean_entries(self):                                                    # Clean and leave everything as at the beginning.

        msg = QMessageBox()
        msg.setIcon(QMessageBox.Question)
        msg.setWindowTitle("Clean all inputs.")
        msg.setText("Are you sure to delete all entries?")
        msg.setStandardButtons(QMessageBox.Ok | QMessageBox.Cancel)
        msg.setDefaultButton(QMessageBox.Ok)                                    # By default, the focus is on the OK button
        returnValue = msg.exec()
        if returnValue == QMessageBox.Ok:                                       # If the answer is OK

            # Position the ComboBox at the start.
            self.comboBox_2.setCurrentIndex(0)                                  # Position in the first Item (Filter Type)
            plt.close()                                                         # Close the existing chart.

            # Delete label content and Text Boxes.
            self.label_5.setText("")                                            # Delete the contents of the label (Directory path where the files are located)

            self.lineEdit_2.setText("")                                         # Clear the content of the Star time text box.
            self.lineEdit_3.setText("")                                         # Clear the content of the End time text box.
            self.lineEdit_4.setText("4")                                        # Clear the content of the filter Order and Start filter order text box = 4.

            self.lineEdit_5.setText("")                                         # Clear the content of the Frequency Filter 1 text box.
            self.lineEdit_6.setText("")                                         # Clear the content of the Frequency Filter 2 text box.
            self.lineEdit_7.setText("")                                         # Clear the content of the Frequency Filter 3 text box.
            self.lineEdit_8.setText("")                                         # Clear the content of the Frequency Filter 4 text box.
            self.lineEdit_9.setText("")                                         # Clear the content of the Frequency Filter 5 text box.

            self.lineEdit_10.setText("")                                        # Clear the content of the minimum frequency Filter 1 text box.
            self.lineEdit_11.setText("")                                        # Clear the content of the maximum frequency Filter 1 text box.

            self.lineEdit_12.setText("")                                        # Clear the content of the minimum frequency Filter 2 text box.
            self.lineEdit_13.setText("")                                        # Clear the content of the maximum frequency Filter 2 text box.

            self.lineEdit_14.setText("")                                        # Clear the content of the minimum frequency Filter 3 text box.
            self.lineEdit_15.setText("")                                        # Clear the content of the maximum frequency Filter 3 text box.

            self.lineEdit_16.setText("")                                        # Clear the content of the minimum frequency Filter 4 text box.
            self.lineEdit_17.setText("")                                        # Clear the content of the maximum frequency Filter 4 text box.

            self.lineEdit_18.setText("")                                        # Clear the content of the minimum frequency Filter 5 text box.
            self.lineEdit_19.setText("")                                        # Clear the content of the maximum frequency Filter 5 text box.
            self.lineEdit_20.setText("50")                                      # Clear the content of "Window size" text box = 50.
            self.lineEdit_21.setText("3")                                       # Clear the content of Smoothing type text box contents = 3.
            self.lineEdit_22.setText("1")                                       # Clear the content of NaN Tolerance size text box = 1.

            # Disable text boxes again on startup

            self.lineEdit_2.setEnabled(False)                                   # Disable the Start time Text box.
            self.lineEdit_3.setEnabled(False)                                   # Disable the End time Text box.
            self.lineEdit_4.setEnabled(False)                                   # Disable the Filter Order Text box.

            self.lineEdit_5.setEnabled(False)                                   # Disable the Frequency Filter 1 text box.
            self.lineEdit_6.setEnabled(False)                                   # Disable the Frequency Filter 2 text box.
            self.lineEdit_7.setEnabled(False)                                   # Disable the Frequency Filter 3 text box.
            self.lineEdit_8.setEnabled(False)                                   # Disable the Frequency Filter 4 text box.
            self.lineEdit_9.setEnabled(False)                                   # Disable the Frequency Filter 5 text box.

            self.lineEdit_10.setEnabled(False)                                  # Disable the minimum frequency Filter 1 text box.
            self.lineEdit_11.setEnabled(False)                                  # Disable the maximum frequency Filter 1 text box.

            self.lineEdit_12.setEnabled(False)                                  # Disable the minimum frequency Filter 2 text box.
            self.lineEdit_13.setEnabled(False)                                  # Disable the maximum frequency Filter 2 text box.

            self.lineEdit_14.setEnabled(False)                                  # Disable the minimum frequency Filter 3 text box.
            self.lineEdit_15.setEnabled(False)                                  # Disable the maximum frequency Filter 3 text box.

            self.lineEdit_16.setEnabled(False)                                  # Disable the minimum frequency Filter 4 text box.
            self.lineEdit_17.setEnabled(False)                                  # Disable the maximum frequency Filter 4 text box.

            self.lineEdit_18.setEnabled(False)                                  # Disable the minimum frequency Filter 5 text box.
            self.lineEdit_19.setEnabled(False)                                  # Disable the maximum frequency Filter 5 text box.
            self.lineEdit_20.setEnabled(False)                                  # Disable the Window size text box.
            self.lineEdit_21.setEnabled(False)                                  # Disable Smoothing type text box.
            self.lineEdit_22.setEnabled(False)                                  # Disable NaN Tolerance Text box.

            self.pushButton_2.setEnabled(False)                                 # Disable the Plot Envelope filter Entropy Command Button.

            # Disable and enable the CheckBox on startup
            self.checkBox.setChecked(False)

            plt.close()                                                          # Close the existing chart.
        else:
            pass

    """  Function to manage the filter combobox  """

    def selection_changed1(self):  # Function that programs the list of the ComboBox for the Type of Filter

        index = self.comboBox_2.currentIndex()                          # According to Combobox selection, its index is captured.

        if (0 == index):                                                # *** In case the combo index is 0, (Select) """
            # Position the ComboBoxes at the beginning
            self.activacion1()                                          # Call to the cleaning function and Activation/Deactivation 1

        elif (1 == index):                                              # *** In case the combo index is 1, (Lowpass) """

            self.activacion2()                                          # Call to the cleaning function and Activation/Deactivation 2

        elif (2 == index):                                              # *** In case the combo index is 2, (Highpass) """

            self.activacion2()                                          # Call to the cleaning function and Activation/Deactivation 2

        elif (3 == index):                                              # *** In case the combo index is 3, (Bandpass) """

            self.activacion3()                                          # Call to the cleaning function and Activation/Deactivation 3

        elif (4 == index):                                              # *** In case the combo index is 3, (Bandstop) """

            self.activacion3()                                          # Call to the cleaning function and Activation/Deactivation 3

        else:
            pass

    def Plot_entropy(self):                                                 # Function to validate entries and plot Filters.

            index1 = self.comboBox_2.currentIndex()                         # Reading the ComboBox index.

            if (1 == index1):

                self.filtropasobajo()                                   # Lowpass filter with 1 hr. analysis.

            elif (2 == index1):

                self.filtropasoalto()                                   # Highpass filter with 1 hr. analysis.

            elif (3 == index1):

                self.filtropasabanda()                                  # Bandpass filter with 1 hr. analysis.

            elif (4 == index1):

                self.filtrobandstop()                                   # bandstop filter with 1 hr. analysis.

            else:
                pass


    def activacion1(self):                                              # To Activate / Deactivate and cleaning in "Selection" -> Index 0.

        plt.close()                                                         # Close the existing chart.

        # Clean entrances.
        self.label_5.setText("")                                            # Delete the contents of the label (Directory to load file)

        self.lineEdit_2.setText("")                                         # Clear the content of the Star time text box.
        self.lineEdit_3.setText("")                                         # Clear the content of the End time text box.
        self.lineEdit_4.setText("4")                                        # Clear the content of the filter Order and Start filter order text box = 4.

        self.lineEdit_5.setText("")                                         # Clear the content of the Frequency Filter 1 text box.
        self.lineEdit_6.setText("")                                         # Clear the content of the Frequency Filter 2 text box.
        self.lineEdit_7.setText("")                                         # Clear the content of the Frequency Filter 3 text box.
        self.lineEdit_8.setText("")                                         # Clear the content of the Frequency Filter 4 text box.
        self.lineEdit_9.setText("")                                         # Clear the content of the Frequency Filter 5 text box.

        self.lineEdit_10.setText("")                                        # Clear the content of the minimum frequency Filter 1 text box.
        self.lineEdit_11.setText("")                                        # Clear the content of the maximum frequency Filter 1 text box.

        self.lineEdit_12.setText("")                                        # Clear the content of the minimum frequency Filter 2 text box.
        self.lineEdit_13.setText("")                                        # Clear the content of the maximum frequency Filter 2 text box.

        self.lineEdit_14.setText("")                                        # Clear the content of the minimum frequency Filter 3 text box.
        self.lineEdit_15.setText("")                                        # Clear the content of the maximum frequency Filter 3 text box.

        self.lineEdit_16.setText("")                                        # Clear the content of the minimum frequency Filter 4 text box.
        self.lineEdit_17.setText("")                                        # Clear the content of the maximum frequency Filter 4 text box.

        self.lineEdit_18.setText("")                                        # Clear the content of the minimum frequency Filter 5 text box.
        self.lineEdit_19.setText("")                                        # Clear the content of the maximum frequency Filter 5 text box.
        self.lineEdit_20.setText("50")                                      # Clear and Start the Envelope windows text box = 50.
        self.lineEdit_21.setText("3")                                       # Clear the content of Smoothing type text box contents = 3.
        self.lineEdit_22.setText("1")                                       # Clear the content of NaN Tolerance size text box = 1.

        # Disable text boxes again as at startup

        self.lineEdit_2.setEnabled(False)                                   # Disable the Start time Text box.
        self.lineEdit_3.setEnabled(False)                                   # Disable the End time Text box.
        self.lineEdit_4.setEnabled(False)                                   # Disable the Filter Order Text box.

        self.lineEdit_5.setEnabled(False)                                   # Disable the Frequency Filter 1 text box.
        self.lineEdit_6.setEnabled(False)                                   # Disable the Frequency Filter 2 text box.
        self.lineEdit_7.setEnabled(False)                                   # Disable the Frequency Filter 3 text box.
        self.lineEdit_8.setEnabled(False)                                   # Disable the Frequency Filter 4 text box.
        self.lineEdit_9.setEnabled(False)                                   # Disable the Frequency Filter 5 text box.

        self.lineEdit_10.setEnabled(False)                                  # Disable the minimum frequency Filter 1 text box.
        self.lineEdit_11.setEnabled(False)                                  # Disable the maximum frequency Filter 1 text box.

        self.lineEdit_12.setEnabled(False)                                  # Disable the minimum frequency Filter 2 text box.
        self.lineEdit_13.setEnabled(False)                                  # Disable the maximum frequency Filter 2 text box.

        self.lineEdit_14.setEnabled(False)                                  # Disable the minimum frequency Filter 3 text box.
        self.lineEdit_15.setEnabled(False)                                  # Disable the maximum frequency Filter 3 text box.

        self.lineEdit_16.setEnabled(False)                                  # Disable the minimum frequency Filter 4 text box.
        self.lineEdit_17.setEnabled(False)                                  # Disable the maximum frequency Filter 4 text box.

        self.lineEdit_18.setEnabled(False)                                  # Disable the minimum frequency Filter 5 text box.
        self.lineEdit_19.setEnabled(False)                                  # Disable the maximum frequency Filter 5 text box.
        self.lineEdit_20.setEnabled(False)                                  # Disable the Window size text box.
        self.lineEdit_21.setEnabled(False)                                  # Disable Smoothing type text box.
        self.lineEdit_22.setEnabled(False)                                  # Disable NaN Tolerance Text box.

        # Disable and enable the radioButton and CheckBox on startup
        self.checkBox.setChecked(False)

        self.pushButton_2.setEnabled(False)                                 # Disable the Plot Envelope filter Entropy Command Button.

        plt.close()                                                         # Close the existing chart.


    def activacion2(self):                          # To Activate/Deactivate and clean in Lowpass and Highpass filter.

        plt.close()                                                         # Close the existing chart.

        # Clean entrances.
        self.lineEdit_10.setText("")                                        # Clear the content of the minimum frequency Filter 1 text box.
        self.lineEdit_11.setText("")                                        # Clear the content of the maximum frequency Filter 1 text box.

        self.lineEdit_12.setText("")                                        # Clear the content of the minimum frequency Filter 2 text box.
        self.lineEdit_13.setText("")                                        # Clear the content of the maximum frequency Filter 2 text box.

        self.lineEdit_14.setText("")                                        # Clear the content of the minimum frequency Filter 3 text box.
        self.lineEdit_15.setText("")                                        # Clear the content of the maximum frequency Filter 3 text box.

        self.lineEdit_16.setText("")                                        # Clear the content of the minimum frequency Filter 4 text box.
        self.lineEdit_17.setText("")                                        # Clear the content of the maximum frequency Filter 4 text box.

        self.lineEdit_18.setText("")                                        # Clear the content of the minimum frequency Filter 5 text box.
        self.lineEdit_19.setText("")                                        # Clear the content of the maximum frequency Filter 5 text box.

        # Enable/Disable text boxes

        self.lineEdit_4.setEnabled(True)                                    # Enabled the Filter Order Text box.

        self.lineEdit_5.setEnabled(True)                                    # Enabled the Frequency Filter 1 text box.
        self.lineEdit_6.setEnabled(True)                                    # Enabled the Frequency Filter 2 text box.
        self.lineEdit_7.setEnabled(True)                                    # Enabled the Frequency Filter 3 text box.
        self.lineEdit_8.setEnabled(True)                                    # Enabled the Frequency Filter 4 text box.
        self.lineEdit_9.setEnabled(True)                                    # Enabled the Frequency Filter 5 text box.

        self.lineEdit_10.setEnabled(False)                                  # Disable the minimum frequency Filter 1 text box.
        self.lineEdit_11.setEnabled(False)                                  # Disable the maximum frequency Filter 1 text box.

        self.lineEdit_12.setEnabled(False)                                  # Disable the minimum frequency Filter 2 text box.
        self.lineEdit_13.setEnabled(False)                                  # Disable the maximum frequency Filter 2 text box.

        self.lineEdit_14.setEnabled(False)                                  # Disable the minimum frequency Filter 3 text box.
        self.lineEdit_15.setEnabled(False)                                  # Disable the maximum frequency Filter 3 text box.

        self.lineEdit_16.setEnabled(False)                                  # Disable the minimum frequency Filter 4 text box.
        self.lineEdit_17.setEnabled(False)                                  # Disable the maximum frequency Filter 4 text box.

        self.lineEdit_18.setEnabled(False)                                  # Disable the minimum frequency Filter 5 text box.
        self.lineEdit_19.setEnabled(False)                                  # Disable the maximum frequency Filter 5 text box.
        self.lineEdit_20.setEnabled(True)                                   # Enabled the Window size text box.
        self.lineEdit_21.setEnabled(True)                                   # Enabled Smoothing type text box.
        self.lineEdit_22.setEnabled(True)                                   # Enabled NaN Tolerance Text box.


        self.pushButton_2.setEnabled(True)                                  # Enabled the Plot Envelope filter Entropy Command Button.

        if self.checkBox.isChecked() == True:                               # If the time interval checkBox is true.
            self.lineEdit_2.setEnabled(True)                                # Enabled the Start time Text box.
            self.lineEdit_3.setEnabled(True)                                # Enabled the End time Text box.
        else:
            self.lineEdit_2.setText("")                                     # Clear the content of the Star time text box.
            self.lineEdit_3.setText("")                                     # Clear the content of the End time text box.
            self.lineEdit_2.setEnabled(False)                               # Disable the Start time Text box.
            self.lineEdit_3.setEnabled(False)                               # Disable the End time Text box.

        plt.close()                                                         # Close the existing chart.


    def activacion3(self):                          # To Activate/Deactivate and clean in Bandpass and Bandstop filter.

        plt.close()                                                         # Close the existing chart.

        # Clean entrances.
        self.lineEdit_5.setText("")                                         # Clear the content of the Frequency Filter 1 text box.
        self.lineEdit_6.setText("")                                         # Clear the content of the Frequency Filter 2 text box.
        self.lineEdit_7.setText("")                                         # Clear the content of the Frequency Filter 3 text box.
        self.lineEdit_8.setText("")                                         # Clear the content of the Frequency Filter 4 text box.
        self.lineEdit_9.setText("")                                         # Clear the content of the Frequency Filter 5 text box.

        # Enable/Disable text boxes
        self.lineEdit_4.setEnabled(True)                                    # Enabled the Filter Order Text box.

        self.lineEdit_5.setEnabled(False)                                   # Disable the Frequency Filter 1 text box.
        self.lineEdit_6.setEnabled(False)                                   # Disable the Frequency Filter 2 text box.
        self.lineEdit_7.setEnabled(False)                                   # Disable the Frequency Filter 3 text box.
        self.lineEdit_8.setEnabled(False)                                   # Disable the Frequency Filter 4 text box.
        self.lineEdit_9.setEnabled(False)                                   # Disable the Frequency Filter 5 text box.

        self.lineEdit_10.setEnabled(True)                                   # Enabled the minimum frequency Filter 1 text box.
        self.lineEdit_11.setEnabled(True)                                   # Enabled the maximum frequency Filter 1 text box.

        self.lineEdit_12.setEnabled(True)                                   # Enabled the minimum frequency Filter 2 text box.
        self.lineEdit_13.setEnabled(True)                                   # Enabled the maximum frequency Filter 2 text box.

        self.lineEdit_14.setEnabled(True)                                   # Enabled the minimum frequency Filter 3 text box.
        self.lineEdit_15.setEnabled(True)                                   # Enabled the maximum frequency Filter 3 text box.

        self.lineEdit_16.setEnabled(True)                                   # Enabled the minimum frequency Filter 4 text box.
        self.lineEdit_17.setEnabled(True)                                   # Enabled the maximum frequency Filter 4 text box.

        self.lineEdit_18.setEnabled(True)                                   # Enabled the minimum frequency Filter 5 text box.
        self.lineEdit_19.setEnabled(True)                                   # Enabled the maximum frequency Filter 5 text box.
        self.lineEdit_20.setEnabled(True)                                   # Enabled the Window size text box.
        self.lineEdit_21.setEnabled(True)                                   # Enabled Smoothing type text box.
        self.lineEdit_22.setEnabled(True)                                   # Enabled NaN Tolerance Text box.

        self.pushButton_2.setEnabled(True)                                  # Enabled the Plot Envelope filter Entropy Command Button.

        if self.checkBox.isChecked() == True:                               # If the time interval checkBox is true.
            self.lineEdit_2.setEnabled(True)                                # Enabled the Start time Text box.
            self.lineEdit_3.setEnabled(True)                                # Enabled the End time Text box.
        else:
            self.lineEdit_2.setText("")                                     # Clear the content of the Star time text box.
            self.lineEdit_3.setText("")                                     # Clear the content of the End time text box.
            self.lineEdit_2.setEnabled(False)                               # Disable the Start time Text box.
            self.lineEdit_3.setEnabled(False)                               # Disable the End time Text box.

        plt.close()                                                         # Close the existing chart.


    """ Begin to filter functions """

    def filtropasobajo(self):                                           # 1.- Function to execute the Lowpass filter with 1 hr. analysis window.

        try:

            # Verifying that the checkbox is true. Work with time intervals.

            if self.checkBox.isChecked() == True:

                # Verify (Validation), that the text box and label is not empty

                if not self.label_5.text():
                    MensCombo1 = QMessageBox()
                    MensCombo1.setIcon(QMessageBox.Warning)
                    MensCombo1.setWindowTitle("Empty directory to upload records")
                    MensCombo1.setText("Please, enter a valid name of directory")
                    returnValue = MensCombo1.exec()

                elif not self.lineEdit_2.text():
                    MensCombo3 = QMessageBox()
                    MensCombo3.setIcon(QMessageBox.Warning)
                    MensCombo3.setWindowTitle("Empty Start time")
                    MensCombo3.setText("Please, enter a valid Value")
                    returnValue = MensCombo3.exec()

                elif not self.lineEdit_3.text():
                    MensCombo4 = QMessageBox()
                    MensCombo4.setIcon(QMessageBox.Warning)
                    MensCombo4.setWindowTitle("Empty End time")
                    MensCombo4.setText("Please, enter a valid Value")
                    returnValue = MensCombo4.exec()

                elif not self.lineEdit_4.text():
                    MensCombo5 = QMessageBox()
                    MensCombo5.setIcon(QMessageBox.Warning)
                    MensCombo5.setWindowTitle("Empty Filter Order")
                    MensCombo5.setText("Please, enter a valid Value")
                    returnValue = MensCombo5.exec()

                elif not self.lineEdit_5.text():
                    MensCombo6 = QMessageBox()
                    MensCombo6.setIcon(QMessageBox.Warning)
                    MensCombo6.setWindowTitle("Empty Frequency Filter 1")
                    MensCombo6.setText("Please, enter a valid Value")
                    returnValue = MensCombo6.exec()

                elif not self.lineEdit_6.text():
                    MensCombo7 = QMessageBox()
                    MensCombo7.setIcon(QMessageBox.Warning)
                    MensCombo7.setWindowTitle("Empty Frequency Filter 2")
                    MensCombo7.setText("Please, enter a valid Value")
                    returnValue = MensCombo7.exec()

                elif not self.lineEdit_7.text():
                    MensCombo3 = QMessageBox()
                    MensCombo3.setIcon(QMessageBox.Warning)
                    MensCombo3.setWindowTitle("Empty Frequency Filter 3")
                    MensCombo3.setText("Please, enter a valid Value")
                    returnValue = MensCombo3.exec()

                elif not self.lineEdit_8.text():
                    MensCombo8 = QMessageBox()
                    MensCombo8.setIcon(QMessageBox.Warning)
                    MensCombo8.setWindowTitle("Empty Frequency Filter 4")
                    MensCombo8.setText("Please, enter a valid Value")
                    returnValue = MensCombo8.exec()

                elif not self.lineEdit_9.text():
                    MensCombo9 = QMessageBox()
                    MensCombo9.setIcon(QMessageBox.Warning)
                    MensCombo9.setWindowTitle("Empty Frequency Filter 5")
                    MensCombo9.setText("Please, enter a valid Value")
                    returnValue = MensCombo9.exec()

                elif not self.lineEdit_20.text():
                    MensCombo10 = QMessageBox()
                    MensCombo10.setIcon(QMessageBox.Warning)
                    MensCombo10.setWindowTitle("Empty Envelope Window size")
                    MensCombo10.setText("Please, enter a valid Value")
                    returnValue = MensCombo10.exec()

                elif not self.lineEdit_21.text():
                    MensCombo11 = QMessageBox()
                    MensCombo11.setIcon(QMessageBox.Warning)
                    MensCombo11.setWindowTitle("Empty Smoothing type")
                    MensCombo11.setText("Please, enter a valid Value")
                    returnValue = MensCombo11.exec()

                elif not self.lineEdit_22.text():
                    MensCombo12 = QMessageBox()
                    MensCombo12.setIcon(QMessageBox.Warning)
                    MensCombo12.setWindowTitle("Empty NaN Tolerance")
                    MensCombo12.setText("Please, enter a valid Value")
                    returnValue = MensCombo12.exec()

                else:
                    # Filtering with a Lowpass.
                    plt.close()                                                 # Close the existing chart.

                    carpeta = (self.label_5.text())                             # Reading the directory or file folder label.

                    # Code to detect the contents of the folder and the files that the folder contains
                    with os.scandir(carpeta) as ficheros:
                        ficheros4 = [fichero.name for fichero in ficheros if fichero.is_file()]

                    # The contents of the files in "ficheros4" is a list. This code converts them to string
                    lfiles = [str(elemento) for elemento in ficheros4]

                    # Code used to determine the name of the files contained in the folder and to be used in the loading loop
                    Iniciolfiles = lfiles[0]                                    # Detects the numeric value of the "Start" in the name
                    Finlfiles = lfiles[-1]                                      # Detects the numerical value of the "End" in the name
                    Indice1 = Iniciolfiles.rfind('.')                           # Determines the index, which will be marked by the dot at the end for the extension
                    Nombre3 = Iniciolfiles[0:Indice1]                           # Indicates the name of the file in str (minus) the index or extension (each day)

                    # Data entry from labels and fields or text boxes (this value is a string by default)

                    orden1 = (self.lineEdit_4.text())                           # reading filter order label.
                    frec3 = (self.lineEdit_5.text())                            # reading frequency Filter 1 Label.
                    frec3b = (self.lineEdit_6.text())                           # reading frequency Filter 2 Label.
                    frec3c = (self.lineEdit_7.text())                           # reading frequency Filter 3 Label.
                    frec3d = (self.lineEdit_8.text())                           # reading frequency Filter 4 Label.
                    frec3e = (self.lineEdit_9.text())                           # reading frequency Filter 5 Label.

                    # Data entry for enveloped (this value is a string by default)
                    Tam = (self.lineEdit_20.text())                             # Reading the envelope window size label.
                    Tsua = (self.lineEdit_21.text())                            # Reading the Smoothing type label.
                    Tnan = (self.lineEdit_22.text())                            # Reading the NaN Tolerance label.

                    Start1 = (self.lineEdit_2.text())                           # Star Time Size label reading.
                    End1 = (self.lineEdit_3.text())                             # End Time Size label reading.

                    # Convert the string value of the input text boxes to float or integer
                    frec4=float(frec3)                                          # Converts Frequency Filter 1 value to float.
                    frec4b=float(frec3b)                                        # Converts Frequency Filter 2 value to float.
                    frec4c=float(frec3c)                                        # Converts Frequency Filter 3 value to float.
                    frec4d=float(frec3d)                                        # Converts Frequency Filter 4 value to float.
                    frec4e=float(frec3e)                                        # Converts Frequency Filter 5 value to float.

                    orden4=int(orden1)                                          # Converts filter order value to integer.

                    Tam1=int(Tam)                                               # Converts the envelope window size value to integer.
                    Tsua1=int(Tsua)                                             # Converts the Smoothing type value to integer.
                    Tnan1=int(Tnan)                                             # Converts the NaN Tolerance value to integer.

                    timeIn = 365

                    Start2=int(Start1)                                          # Converts the Start time window size value to an integer.
                    End2=int(End1)                                              # Converts the End time window size value to an integer.

                    Diferencia = End2 - Start2                                  # Value of the difference between end and start to obtain the number of days to calculate

                    TM = str(Tam1)                                              # Coverts the windows size to string to put in plot label

                    Start2=int(Start1)                                          # Converts the Start time window size value to an integer.
                    End2=int(End1)                                              # Converts the End time window size value to an integer.

                    # Function for Shannon entropy calculating
                    def calcular_entropia(datos):
                        params = stats.norm.fit(datos)
                        dist = stats.norm(*params)
                        probabilidades = dist.pdf(datos)
                        entropia = -np.sum(probabilidades * np.log2(probabilidades))
                        return entropia

                    # Function for Shannon entropy enveloped calculating
                    def nanfastsmooth(Y, w, type=1, tol=0.5):

                        """
                        Smooths vector Y with a moving average of width w, ignoring NaNs in data.

                        Parameters:
                        Y (numpy array): Input signal.
                        w (int): Window width.
                        type (int): Smooth type (1 for rectangular, 2 for triangular, 3 for pseudo-Gaussian).
                        tol (float): Tolerance to NaNs between 0 and 1.

                        Returns:
                        numpy array: Smoothed signal.
                        """
                        mask = ~np.isnan(Y)  # Create a boolean mask for non-NaN values
                        Y[mask] = nanfastsmooth_core(Y[mask], w, type, tol)  # Apply smoothing to non-NaN values
                        return Y

                    # Function for Shannon entropy enveloped type calculating. For default the value = 3
                    def nanfastsmooth_core(Y, w, type, tol):
                        if type == 1:
                            SmoothY = moving_average(Y, w)
                        elif type == 2:
                            SmoothY = moving_average(moving_average(Y, w), w)
                        elif type == 3:
                            SmoothY = moving_average(moving_average(moving_average(Y, w), w), w)

                        return SmoothY

                    def moving_average(Y, window_size):
                        return np.convolve(Y, np.ones(window_size)/window_size, mode='same')

                    def apply_bandpass_filter(datos, frecuencia_muestreo, freq_band):
                        nyquist = 0.5 * frecuencia_muestreo
                        normal_freq_band = np.array(freq_band) / nyquist
                        b, a = signal.butter(4, normal_freq_band, btype='band')
                        datos_filtrados = signal.filtfilt(b, a, datos)
                        return datos_filtrados

                    # Start entropy and averaged entropy values
                    entropia_shannon = []
                    entropia_promediada = []

                    entropia_shannon2 = []
                    entropia_promediada2 = []

                    entropia_shannon3 = []
                    entropia_promediada3 = []

                    entropia_shannon4 = []
                    entropia_promediada4 = []

                    entropia_shannon5 = []
                    entropia_promediada5 = []

                    # Cycle for the day-by-day calculation of the entropy in the files contained in the folder, using the time range (Start to End)
                    for dia in range(Start2, End2 + 1):

                        archivo = Nombre3 + '.'+ f"{dia:003}"       # Here you select the name previously calculated plus point and the value of each Julian day

                        # If there is no file in the list, the entire day is added with a value of zero
                        if not os.path.exists(os.path.join(carpeta, archivo)):
                            for _ in range(24):  # Adds 24 hours with zero value if there is no file
                                entropia_shannon.append(0)
                                entropia_promediada.append(0)
                            continue

                        elif not os.path.exists(os.path.join(carpeta, archivo)):
                            for _ in range(24):  # AÃ±ade 24 horas con valor cero si no hay archivo
                                entropia_shannon2.append(0)
                                entropia_promediada2.append(0)
                            continue

                        elif not os.path.exists(os.path.join(carpeta, archivo)):
                            for _ in range(24):  # AÃ±ade 24 horas con valor cero si no hay archivo
                                entropia_shannon3.append(0)
                                entropia_promediada3.append(0)
                            continue

                        elif not os.path.exists(os.path.join(carpeta, archivo)):
                            for _ in range(24):  # AÃ±ade 24 horas con valor cero si no hay archivo
                                entropia_shannon4.append(0)
                                entropia_promediada4.append(0)
                            continue

                        elif not os.path.exists(os.path.join(carpeta, archivo)):
                            for _ in range(24):  # AÃ±ade 24 horas con valor cero si no hay archivo
                                entropia_shannon5.append(0)
                                entropia_promediada5.append(0)
                            continue

                        # CreaciÃ³n de st para la lectura del fichero
                        st = Stream()
                        st += read(os.path.join(carpeta, archivo))

                        # CreaciÃ³n de st2 para la lectura del fichero
                        st2 = Stream()
                        st2 += read(os.path.join(carpeta, archivo))

                        # CreaciÃ³n de st3 para la lectura del fichero
                        st3 = Stream()
                        st3 += read(os.path.join(carpeta, archivo))

                        # CreaciÃ³n de st4 para la lectura del fichero
                        st4 = Stream()
                        st4 += read(os.path.join(carpeta, archivo))

                        # CreaciÃ³n de st5 para la lectura del fichero
                        st5 = Stream()
                        st5 += read(os.path.join(carpeta, archivo))

                        frecuencia_muestreo = st[0].stats.sampling_rate

                        # calculation of the lowpass filter with the parameters indicated by the user.
                        st.filter('lowpass', freq=frec4, corners=orden4, zerophase=True)

                        st2.filter('lowpass', freq=frec4b, corners=orden4, zerophase=True)

                        st3.filter('lowpass', freq=frec4c, corners=orden4, zerophase=True)

                        st4.filter('lowpass', freq=frec4d, corners=orden4, zerophase=True)

                        st5.filter('lowpass', freq=frec4e, corners=orden4, zerophase=True)

                        # Datos para st
                        datos = st[0].data

                        # Datos2 para st2
                        datos2 = st2[0].data

                        # Datos3 para st3
                        datos3 = st3[0].data

                        # Datos4 para st4
                        datos4 = st4[0].data

                        # Datos5 para st5
                        datos5 = st5[0].data

                        # Divide the data into hours and calculate entropy for each hour.
                        for hora in range(24*6):
                            inicio = hora * 600 * 100  # start of time in seconds.
                            fin = inicio + 600 * 100  # End of time in seconds.
                            datos_hora = datos[inicio:fin]

                            if len(datos_hora) < 600 * 100:  # If the hour is incomplete, add zeros to the end.
                                datos_hora = np.append(datos_hora, np.zeros(600 * 100 - len(datos_hora)))

                            entropia_shannon.append(calcular_entropia(datos_hora))
                            entropia_promediada.append(calcular_entropia(datos_hora) / len(datos_hora))

                        # Dividir los datos en horas y calcular entropÃ­a para cada hora con st2
                        for hora in range(24*6):
                            inicio = hora * 600 * 100  # inicio de la hora en segundos
                            fin = inicio + 600 * 100  # fin de la hora en segundos
                            datos_hora2 = datos2[inicio:fin]

                            if len(datos_hora2) < 600 * 100:  # Si la hora estÃ¡ incompleta, agregar ceros al final
                                datos_hora2 = np.append(datos_hora2, np.zeros(600 * 100 - len(datos_hora2)))

                            entropia_shannon2.append(calcular_entropia(datos_hora2))
                            entropia_promediada2.append(calcular_entropia(datos_hora2) / len(datos_hora2))

                        # Dividir los datos en horas y calcular entropÃ­a para cada hora con st3
                        for hora in range(24*6):
                            inicio = hora * 600 * 100  # inicio de la hora en segundos
                            fin = inicio + 600 * 100  # fin de la hora en segundos
                            datos_hora3 = datos3[inicio:fin]

                            if len(datos_hora3) < 600 * 100:  # Si la hora estÃ¡ incompleta, agregar ceros al final
                                datos_hora3 = np.append(datos_hora3, np.zeros(600 * 100 - len(datos_hora3)))

                            entropia_shannon3.append(calcular_entropia(datos_hora3))
                            entropia_promediada3.append(calcular_entropia(datos_hora3) / len(datos_hora3))

                        # Dividir los datos en horas y calcular entropÃ­a para cada hora con st4
                        for hora in range(24*6):
                            inicio = hora * 600 * 100  # inicio de la hora en segundos
                            fin = inicio + 600 * 100  # fin de la hora en segundos
                            datos_hora4 = datos4[inicio:fin]

                            if len(datos_hora4) < 600 * 100:  # Si la hora estÃ¡ incompleta, agregar ceros al final
                                datos_hora4 = np.append(datos_hora4, np.zeros(600 * 100 - len(datos_hora4)))

                            entropia_shannon4.append(calcular_entropia(datos_hora4))
                            entropia_promediada4.append(calcular_entropia(datos_hora4) / len(datos_hora4))

                        # Dividir los datos en horas y calcular entropÃ­a para cada hora con st5
                        for hora in range(24*6):
                            inicio = hora * 600 * 100  # inicio de la hora en segundos
                            fin = inicio + 600 * 100  # fin de la hora en segundos
                            datos_hora5 = datos5[inicio:fin]

                            if len(datos_hora5) < 600:  # Si la hora estÃ¡ incompleta, agregar ceros al final
                                datos_hora5 = np.append(datos_hora5, np.zeros(600 * 100 - len(datos_hora5)))

                            entropia_shannon5.append(calcular_entropia(datos_hora5))
                            entropia_promediada5.append(calcular_entropia(datos_hora5) / len(datos_hora5))

                    # CreaciÃ³n del array de la entropia normal y la promediada de Shannon para st1
                    entropia_shannon = np.array(entropia_shannon)
                    entropia_promediada = np.array(entropia_promediada)

                    # CreaciÃ³n del array de la entropia normal y la promediada de Shannon para st2
                    entropia_shannon2 = np.array(entropia_shannon2)
                    entropia_promediada2 = np.array(entropia_promediada2)

                    # CreaciÃ³n del array de la entropia normal y la promediada de Shannon para st3
                    entropia_shannon3 = np.array(entropia_shannon3)
                    entropia_promediada3 = np.array(entropia_promediada3)

                    # CreaciÃ³n del array de la entropia normal y la promediada de Shannon para st4
                    entropia_shannon4 = np.array(entropia_shannon4)
                    entropia_promediada4 = np.array(entropia_promediada4)

                    # CreaciÃ³n del array de la entropia normal y la promediada de Shannon para st4
                    entropia_shannon5 = np.array(entropia_shannon5)
                    entropia_promediada5 = np.array(entropia_promediada5)

                    # Shannon Entropy Graph. Value of non-zero indices where there is no data.
                    indices_no_cero_shannon = np.where(entropia_shannon != 0)[0]
                    indices_no_cero_shannon2 = np.where(entropia_shannon2 != 0)[0]
                    indices_no_cero_shannon3 = np.where(entropia_shannon3 != 0)[0]
                    indices_no_cero_shannon4 = np.where(entropia_shannon4 != 0)[0]
                    indices_no_cero_shannon5 = np.where(entropia_shannon5 != 0)[0]

                    # Use example
                    Y = entropia_shannon
                    Y = np.where(Y == 0, np.nan, Y)

                    Y1 = entropia_shannon2
                    Y1 = np.where(Y1 == 0, np.nan, Y1)

                    Y2 = entropia_shannon3
                    Y2 = np.where(Y2 == 0, np.nan, Y2)

                    Y3 = entropia_shannon4
                    Y3 = np.where(Y3 == 0, np.nan, Y3)

                    Y4 = entropia_shannon5
                    Y4 = np.where(Y4 == 0, np.nan, Y4)

                    # Plot the vectors into separate figures.

                    dias = np.arange(1, 8761*6+1)

                    # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE. *** The median filter function is used ***  PARA st1

                    y_filtered = nanfastsmooth(Y.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                    # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE. *** The median filter function is used ***  PARA st2
                    y_filtered2 = nanfastsmooth(Y1.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original   # By default work with size=50

                    # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE. *** The median filter function is used ***  PARA st3
                    y_filtered3 = nanfastsmooth(Y2.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original   # By default work with size=50

                    # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE. *** The median filter function is used ***  PARA st4
                    y_filtered4 = nanfastsmooth(Y3.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original   # By default work with size=50

                    # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE. *** The median filter function is used ***  PARA st5
                    y_filtered5 = nanfastsmooth(Y4.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original   # By default work with size=50


                    # Graph 4 - Envelope only graph.

                    fig, ax = plt.subplots() # To put several plot in same graphics.

                    ax.plot(dias[indices_no_cero_shannon], y_filtered[indices_no_cero_shannon], label='Filter Lowpass [ ' + str(frec4) + ' ] Hz.', color='darkblue')

                    ax.plot(dias[indices_no_cero_shannon2], y_filtered2[indices_no_cero_shannon2], label='Filter Lowpass [ ' + str(frec4b) + ' ] Hz.', color='red')

                    ax.plot(dias[indices_no_cero_shannon3], y_filtered3[indices_no_cero_shannon3], label='Filter Lowpass [ ' + str(frec4c) + ' ] Hz.', color='darkgreen')

                    ax.plot(dias[indices_no_cero_shannon4], y_filtered4[indices_no_cero_shannon4], label='Filter Lowpass [ ' + str(frec4d) + ' ] Hz.', color='darkorange')

                    ax.plot(dias[indices_no_cero_shannon5], y_filtered5[indices_no_cero_shannon5], label='Filter Lowpass [ ' + str(frec4e) + ' ] Hz.', color='darkgoldenrod')

                    plt.legend(prop = {'size': 10}, loc='upper right')          # Para colocar la leyenda a la izquierda
                    plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                    plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                    plt.title(Nombre3 + '_Envelope of Shannon entropy - Each point = 10 min. with Lowpass filter.' + " Envelope Windows = " + TM + '_Star = ' + Start1 + '_End = '+ End1, color ="darkgreen", fontsize=12)

                    # Graphs with dots

                    fig, ax = plt.subplots() # To put several plot in same graphics.

                    ax.plot(dias[indices_no_cero_shannon], entropia_shannon[indices_no_cero_shannon], "o", mfc="darkblue", mec = "darkblue", label='Filter Lowpass [ ' + str(frec4) + ' ] Hz.', color='darkblue')

                    ax.plot(dias[indices_no_cero_shannon2], entropia_shannon2[indices_no_cero_shannon2], "o", mfc="red", mec = "red", label='Filter Lowpass [ ' + str(frec4b) + ' ] Hz.', color='red')

                    ax.plot(dias[indices_no_cero_shannon3], entropia_shannon3[indices_no_cero_shannon3], "o", mfc="darkgreen", mec = "darkgreen", label='Filter Lowpass [ ' + str(frec4c) + ' ] Hz.', color='darkgreen')

                    ax.plot(dias[indices_no_cero_shannon4], entropia_shannon4[indices_no_cero_shannon4], "o", mfc="r", mec = "r", label='Filter Lowpass [ ' + str(frec4d) + ' ] Hz.', color='darkorange')

                    ax.plot(dias[indices_no_cero_shannon5], entropia_shannon5[indices_no_cero_shannon5], "o", mfc="darkgoldenrod", mec = "darkgoldenrod", label='Filter Lowpass [ ' + str(frec4e) + ' ] Hz.', color='darkgoldenrod')

                    plt.legend(prop = {'size': 10}, loc='upper right')          # Para colocar la leyenda a la izquierda
                    plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                    plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                    plt.title(Nombre3 + '_Shannon entropy with dots - Each point = 10 min. with Lowpass filter.' + " Envelope Windows = " + TM + '_Star = ' + Start1 + '_End = '+ End1, color ="darkgreen", fontsize=12)

                    plt.show()


            else:                                           # Here the value of the entropy is calculated without the time interval (Start - End)

                if not self.label_5.text():
                    MensCombo1 = QMessageBox()
                    MensCombo1.setIcon(QMessageBox.Warning)
                    MensCombo1.setWindowTitle("Empty directory to upload records")
                    MensCombo1.setText("Please, enter a valid name of directory")
                    returnValue = MensCombo1.exec()

                elif not self.lineEdit_4.text():
                    MensCombo3 = QMessageBox()
                    MensCombo3.setIcon(QMessageBox.Warning)
                    MensCombo3.setWindowTitle("Empty Filter Order")
                    MensCombo3.setText("Please, enter a valid Value")
                    returnValue = MensCombo3.exec()

                elif not self.lineEdit_5.text():
                    MensCombo4 = QMessageBox()
                    MensCombo4.setIcon(QMessageBox.Warning)
                    MensCombo4.setWindowTitle("Empty Frequency Filter 1")
                    MensCombo4.setText("Please, enter a valid Value")
                    returnValue = MensCombo4.exec()

                elif not self.lineEdit_6.text():
                    MensCombo5 = QMessageBox()
                    MensCombo5.setIcon(QMessageBox.Warning)
                    MensCombo5.setWindowTitle("Empty Frequency Filter 2")
                    MensCombo5.setText("Please, enter a valid Value")
                    returnValue = MensCombo5.exec()

                elif not self.lineEdit_7.text():
                    MensCombo6 = QMessageBox()
                    MensCombo6.setIcon(QMessageBox.Warning)
                    MensCombo6.setWindowTitle("Empty Frequency Filter 3")
                    MensCombo6.setText("Please, enter a valid Value")
                    returnValue = MensCombo6.exec()

                elif not self.lineEdit_8.text():
                    MensCombo7 = QMessageBox()
                    MensCombo7.setIcon(QMessageBox.Warning)
                    MensCombo7.setWindowTitle("Empty Frequency Filter 4")
                    MensCombo7.setText("Please, enter a valid Value")
                    returnValue = MensCombo7.exec()

                elif not self.lineEdit_9.text():
                    MensCombo8 = QMessageBox()
                    MensCombo8.setIcon(QMessageBox.Warning)
                    MensCombo8.setWindowTitle("Empty Frequency Filter 5")
                    MensCombo8.setText("Please, enter a valid Value")
                    returnValue = MensCombo8.exec()

                elif not self.lineEdit_20.text():
                    MensCombo9 = QMessageBox()
                    MensCombo9.setIcon(QMessageBox.Warning)
                    MensCombo9.setWindowTitle("Empty Envelope Window size")
                    MensCombo9.setText("Please, enter a valid Value")
                    returnValue = MensCombo9.exec()

                elif not self.lineEdit_21.text():
                    MensCombo10 = QMessageBox()
                    MensCombo10.setIcon(QMessageBox.Warning)
                    MensCombo10.setWindowTitle("Empty Smoothing type")
                    MensCombo10.setText("Please, enter a valid Value")
                    returnValue = MensCombo10.exec()

                elif not self.lineEdit_22.text():
                    MensCombo11 = QMessageBox()
                    MensCombo11.setIcon(QMessageBox.Warning)
                    MensCombo11.setWindowTitle("Empty NaN Tolerance")
                    MensCombo11.setText("Please, enter a valid Value")
                    returnValue = MensCombo11.exec()

                else:
                    # Filtering with a Lowpass.
                    plt.close()                                                 # Close the existing chart.

                    carpeta = (self.label_5.text())                             # Reading the directory or file folder label.

                    # Code to detect the contents of the folder and the files that the folder contains
                    with os.scandir(carpeta) as ficheros:
                        ficheros4 = [fichero.name for fichero in ficheros if fichero.is_file()]

                    # The contents of the files in "ficheros4" is a list. This code converts them to string
                    lfiles = [str(elemento) for elemento in ficheros4]

                    # Code used to determine the name of the files contained in the folder and to be used in the loading loop
                    Iniciolfiles = lfiles[0]                                    # Detects the numeric value of the "Start" in the name
                    Finlfiles = lfiles[-1]                                      # Detects the numerical value of the "End" in the name
                    Indice1 = Iniciolfiles.rfind('.')                           # Determines the index, which will be marked by the dot at the end for the extension
                    Nombre3 = Iniciolfiles[0:Indice1]                           # Indicates the name of the file in str (minus) the index or extension (each day)

                    # Data entry from labels and fields or text boxes (this value is a string by default)

                    frec3 = (self.lineEdit_5.text())                            # reading frequency Filter 1 Label.
                    frec3b = (self.lineEdit_6.text())                           # reading frequency Filter 2 Label.
                    frec3c = (self.lineEdit_7.text())                           # reading frequency Filter 3 Label.
                    frec3d = (self.lineEdit_8.text())                           # reading frequency Filter 4 Label.
                    frec3e = (self.lineEdit_9.text())                           # reading frequency Filter 5 Label.

                    orden1 = (self.lineEdit_4.text())                           # Reading the Filter Order Label.

                    # Data entry for enveloped (this value is a string by default)
                    Tam = (self.lineEdit_20.text())                             # Reading the envelope window size label.
                    Tsua = (self.lineEdit_21.text())                             # Reading the Smoothing type label.
                    Tnan = (self.lineEdit_22.text())                            # Reading the NaN Tolerance label.

                    # Convert the string value of the input text boxes to float or integer
                    frec4=float(frec3)                                          # Converts Frequency Filter 1 value to float.
                    frec4b=float(frec3b)                                        # Converts Frequency Filter 2 value to float.
                    frec4c=float(frec3c)                                        # Converts Frequency Filter 3 value to float.
                    frec4d=float(frec3d)                                        # Converts Frequency Filter 4 value to float.
                    frec4e=float(frec3e)                                        # Converts Frequency Filter 5 value to float.

                    orden4=int(orden1)                                          # Converts filter order value to integer.

                    Tam1=int(Tam)                                               # Converts the envelope window size value to integer.
                    Tsua1=int(Tsua)                                             # Converts the Smoothing type value to integer.
                    Tnan1=int(Tnan)                                             # Converts the NaN Tolerance value to integer.

                    timeIn = 365

                    TM = str(Tam1)                                              # Coverts the windows size to string to put in plot label

                    # Function for Shannon entropy calculating
                    def calcular_entropia(datos):
                        params = stats.norm.fit(datos)
                        dist = stats.norm(*params)
                        probabilidades = dist.pdf(datos)
                        entropia = -np.sum(probabilidades * np.log2(probabilidades))
                        return entropia

                    # Function for Shannon entropy enveloped calculating
                    def nanfastsmooth(Y, w, type=1, tol=0.5):

                        """
                        Smooths vector Y with a moving average of width w, ignoring NaNs in data.

                        Parameters:
                        Y (numpy array): Input signal.
                        w (int): Window width.
                        type (int): Smooth type (1 for rectangular, 2 for triangular, 3 for pseudo-Gaussian).
                        tol (float): Tolerance to NaNs between 0 and 1.

                        Returns:
                        numpy array: Smoothed signal.
                        """
                        mask = ~np.isnan(Y)  # Create a boolean mask for non-NaN values
                        Y[mask] = nanfastsmooth_core(Y[mask], w, type, tol)  # Apply smoothing to non-NaN values
                        return Y

                    # Function for Shannon entropy enveloped type calculating. For default the value = 3
                    def nanfastsmooth_core(Y, w, type, tol):
                        if type == 1:
                            SmoothY = moving_average(Y, w)
                        elif type == 2:
                            SmoothY = moving_average(moving_average(Y, w), w)
                        elif type == 3:
                            SmoothY = moving_average(moving_average(moving_average(Y, w), w), w)

                        return SmoothY

                    def moving_average(Y, window_size):
                        return np.convolve(Y, np.ones(window_size)/window_size, mode='same')

                    def apply_bandpass_filter(datos, frecuencia_muestreo, freq_band):
                        nyquist = 0.5 * frecuencia_muestreo
                        normal_freq_band = np.array(freq_band) / nyquist
                        b, a = signal.butter(4, normal_freq_band, btype='band')
                        datos_filtrados = signal.filtfilt(b, a, datos)
                        return datos_filtrados

                    # Start entropy and averaged entropy values
                    entropia_shannon = []
                    entropia_promediada = []

                    entropia_shannon2 = []
                    entropia_promediada2 = []

                    entropia_shannon3 = []
                    entropia_promediada3 = []

                    entropia_shannon4 = []
                    entropia_promediada4 = []

                    entropia_shannon5 = []
                    entropia_promediada5 = []

                    # Cycle for the day-by-day calculation of the entropy in the files contained in the folder, using the time range (Start to End)
                    for dia in range(1, timeIn + 1):

                        archivo = Nombre3 + '.'+ f"{dia:003}"       # Here you select the name previously calculated plus point and the value of each Julian day

                        # If there is no file in the list, the entire day is added with a value of zero
                        if not os.path.exists(os.path.join(carpeta, archivo)):
                            for _ in range(24*6):  # AÃ±ade 24 horas con valor cero si no hay archivo
                                entropia_shannon.append(0)
                                entropia_promediada.append(0)
                            continue

                        elif not os.path.exists(os.path.join(carpeta, archivo)):
                            for _ in range(24*6):  # AÃ±ade 24 horas con valor cero si no hay archivo
                                entropia_shannon2.append(0)
                                entropia_promediada2.append(0)
                            continue

                        elif not os.path.exists(os.path.join(carpeta, archivo)):
                            for _ in range(24*6):  # AÃ±ade 24 horas con valor cero si no hay archivo
                                entropia_shannon3.append(0)
                                entropia_promediada3.append(0)
                            continue

                        elif not os.path.exists(os.path.join(carpeta, archivo)):
                            for _ in range(24*6):  # AÃ±ade 24 horas con valor cero si no hay archivo
                                entropia_shannon4.append(0)
                                entropia_promediada4.append(0)
                            continue

                        elif not os.path.exists(os.path.join(carpeta, archivo)):
                            for _ in range(24*6):  # AÃ±ade 24 horas con valor cero si no hay archivo
                                entropia_shannon5.append(0)
                                entropia_promediada5.append(0)
                            continue

                        # CreaciÃ³n de st para la lectura del fichero
                        st = Stream()
                        st += read(os.path.join(carpeta, archivo))

                        # CreaciÃ³n de st2 para la lectura del fichero
                        st2 = Stream()
                        st2 += read(os.path.join(carpeta, archivo))

                        # CreaciÃ³n de st3 para la lectura del fichero
                        st3 = Stream()
                        st3 += read(os.path.join(carpeta, archivo))

                        # CreaciÃ³n de st4 para la lectura del fichero
                        st4 = Stream()
                        st4 += read(os.path.join(carpeta, archivo))

                        # CreaciÃ³n de st5 para la lectura del fichero
                        st5 = Stream()
                        st5 += read(os.path.join(carpeta, archivo))

                        # calculation of the lowpass filter with the parameters indicated by the user.
                        st.filter('lowpass', freq=frec4, corners=orden4, zerophase=True)

                        st2.filter('lowpass', freq=frec4b, corners=orden4, zerophase=True)

                        st3.filter('lowpass', freq=frec4c, corners=orden4, zerophase=True)

                        st4.filter('lowpass', freq=frec4d, corners=orden4, zerophase=True)

                        st5.filter('lowpass', freq=frec4e, corners=orden4, zerophase=True)

                        # Datos para st
                        datos = st[0].data

                        # Datos2 para st2
                        datos2 = st2[0].data

                        # Datos3 para st3
                        datos3 = st3[0].data

                        # Datos4 para st4
                        datos4 = st4[0].data

                        # Datos5 para st5
                        datos5 = st5[0].data

                        # Divide the data into hours and calculate entropy for each hour.
                        for hora in range(24*6):
                            inicio = hora * 600 * 100  # start of time in seconds.
                            fin = inicio + 600 * 100  # End of time in seconds.
                            datos_hora = datos[inicio:fin]

                            if len(datos_hora) < 600 * 100:  # If the hour is incomplete, add zeros to the end.
                                datos_hora = np.append(datos_hora, np.zeros(600 * 100 - len(datos_hora)))

                            entropia_shannon.append(calcular_entropia(datos_hora))
                            entropia_promediada.append(calcular_entropia(datos_hora) / len(datos_hora))

                        # Dividir los datos en horas y calcular entropÃ­a para cada hora con st2
                        for hora in range(24*6):
                            inicio = hora * 600 * 100  # inicio de la hora en segundos
                            fin = inicio + 600 * 100  # fin de la hora en segundos
                            datos_hora2 = datos2[inicio:fin]

                            if len(datos_hora2) < 600 * 100:  # Si la hora estÃ¡ incompleta, agregar ceros al final
                                datos_hora2 = np.append(datos_hora2, np.zeros(600 * 100 - len(datos_hora2)))

                            entropia_shannon2.append(calcular_entropia(datos_hora2))
                            entropia_promediada2.append(calcular_entropia(datos_hora2) / len(datos_hora2))

                        # Dividir los datos en horas y calcular entropÃ­a para cada hora con st3
                        for hora in range(24*6):
                            inicio = hora * 600 * 100  # inicio de la hora en segundos
                            fin = inicio + 600 * 100  # fin de la hora en segundos
                            datos_hora3 = datos3[inicio:fin]

                            if len(datos_hora3) < 600 * 100:  # Si la hora estÃ¡ incompleta, agregar ceros al final
                                datos_hora3 = np.append(datos_hora3, np.zeros(600 * 100 - len(datos_hora3)))

                            entropia_shannon3.append(calcular_entropia(datos_hora3))
                            entropia_promediada3.append(calcular_entropia(datos_hora3) / len(datos_hora3))

                        # Dividir los datos en horas y calcular entropÃ­a para cada hora con st4
                        for hora in range(24*6):
                            inicio = hora * 600 * 100  # inicio de la hora en segundos
                            fin = inicio + 600 * 100  # fin de la hora en segundos
                            datos_hora4 = datos4[inicio:fin]

                            if len(datos_hora4) < 600 * 100:  # Si la hora estÃ¡ incompleta, agregar ceros al final
                                datos_hora4 = np.append(datos_hora4, np.zeros(600 * 100 - len(datos_hora4)))

                            entropia_shannon4.append(calcular_entropia(datos_hora4))
                            entropia_promediada4.append(calcular_entropia(datos_hora4) / len(datos_hora4))

                        # Dividir los datos en horas y calcular entropÃ­a para cada hora con st5
                        for hora in range(24*6):
                            inicio = hora * 600 * 100  # inicio de la hora en segundos
                            fin = inicio + 600 * 100  # fin de la hora en segundos
                            datos_hora5 = datos5[inicio:fin]

                            if len(datos_hora5) < 600:  # Si la hora estÃ¡ incompleta, agregar ceros al final
                                datos_hora5 = np.append(datos_hora5, np.zeros(600 * 100 - len(datos_hora5)))

                            entropia_shannon5.append(calcular_entropia(datos_hora5))
                            entropia_promediada5.append(calcular_entropia(datos_hora5) / len(datos_hora5))


                    # CreaciÃ³n del array de la entropia normal y la promediada de Shannon para st1
                    entropia_shannon = np.array(entropia_shannon)
                    entropia_promediada = np.array(entropia_promediada)

                    # CreaciÃ³n del array de la entropia normal y la promediada de Shannon para st2
                    entropia_shannon2 = np.array(entropia_shannon2)
                    entropia_promediada2 = np.array(entropia_promediada2)

                    # CreaciÃ³n del array de la entropia normal y la promediada de Shannon para st3
                    entropia_shannon3 = np.array(entropia_shannon3)
                    entropia_promediada3 = np.array(entropia_promediada3)

                    # CreaciÃ³n del array de la entropia normal y la promediada de Shannon para st4
                    entropia_shannon4 = np.array(entropia_shannon4)
                    entropia_promediada4 = np.array(entropia_promediada4)

                    # CreaciÃ³n del array de la entropia normal y la promediada de Shannon para st4
                    entropia_shannon5 = np.array(entropia_shannon5)
                    entropia_promediada5 = np.array(entropia_promediada5)

                    # Graficar los vectores en figuras separadas

                    dias = np.arange(1, 8761*6+1)

                    # GrÃ¡fico de EntropÃ­a de Shannon

                    indices_no_cero_shannon = np.where(entropia_shannon != 0)[0]
                    indices_no_cero_shannon2 = np.where(entropia_shannon2 != 0)[0]
                    indices_no_cero_shannon3 = np.where(entropia_shannon3 != 0)[0]
                    indices_no_cero_shannon4 = np.where(entropia_shannon4 != 0)[0]
                    indices_no_cero_shannon5 = np.where(entropia_shannon5 != 0)[0]

                    # Use example
                    Y = entropia_shannon
                    Y = np.where(Y == 0, np.nan, Y)

                    Y1 = entropia_shannon2
                    Y1 = np.where(Y1 == 0, np.nan, Y1)

                    Y2 = entropia_shannon3
                    Y2 = np.where(Y2 == 0, np.nan, Y2)

                    Y3 = entropia_shannon4
                    Y3 = np.where(Y3 == 0, np.nan, Y3)

                    Y4 = entropia_shannon5
                    Y4 = np.where(Y4 == 0, np.nan, Y4)

                    # Plot the vectors into separate figures.

                    # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE. *** The median filter function is used ***  PARA st1

                    y_filtered = nanfastsmooth(Y.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                    # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE. *** The median filter function is used ***  PARA st2
                    y_filtered2 = nanfastsmooth(Y1.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original   # By default work with size=50

                    # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE. *** The median filter function is used ***  PARA st3
                    y_filtered3 = nanfastsmooth(Y2.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original   # By default work with size=50

                    # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE. *** The median filter function is used ***  PARA st4
                    y_filtered4 = nanfastsmooth(Y3.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original   # By default work with size=50

                    # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE. *** The median filter function is used ***  PARA st5
                    y_filtered5 = nanfastsmooth(Y4.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original   # By default work with size=50


                    # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                    # Graph 4 - Envelope only graph.

                    fig, ax = plt.subplots() # To put several plot in same graphics.

                    ax.plot(dias[indices_no_cero_shannon], y_filtered[indices_no_cero_shannon], label='Filter Lowpass [ ' + str(frec4) + ' ] Hz.', color='darkblue')

                    ax.plot(dias[indices_no_cero_shannon2], y_filtered2[indices_no_cero_shannon2], label='Filter Lowpass [ ' + str(frec4b) + ' ] Hz.', color='red')

                    ax.plot(dias[indices_no_cero_shannon3], y_filtered3[indices_no_cero_shannon3], label='Filter Lowpass [ ' + str(frec4c) + ' ] Hz.', color='darkgreen')

                    ax.plot(dias[indices_no_cero_shannon4], y_filtered4[indices_no_cero_shannon4], label='Filter Lowpass [ ' + str(frec4d) + ' ] Hz.', color='darkorange')

                    ax.plot(dias[indices_no_cero_shannon5], y_filtered5[indices_no_cero_shannon5], label='Filter Lowpass [ ' + str(frec4e) + ' ] Hz.', color='darkgoldenrod')

                    plt.legend(prop = {'size': 10}, loc='upper right')          # Para colocar la leyenda a la izquierda
                    plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                    plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                    plt.title(Nombre3 + '_Envelope of Shannon entropy - Each point = 10 min. with Lowpass filter.' + " Envelope Windows = " + TM , color ="darkgreen", fontsize=12)

                    # Grahps with dots.

                    fig, ax = plt.subplots() # To put several plot in same graphics.

                    ax.plot(dias[indices_no_cero_shannon], entropia_shannon[indices_no_cero_shannon], "o", mfc="darkblue", mec = "darkblue", label='Filter Lowpass [ ' + str(frec4) + ' ] Hz.', color='darkblue')

                    ax.plot(dias[indices_no_cero_shannon], entropia_shannon2[indices_no_cero_shannon2], "o", mfc="red", mec = "red", label='Filter Lowpass [ ' + str(frec4b) + ' ] Hz.', color='red')

                    ax.plot(dias[indices_no_cero_shannon], entropia_shannon3[indices_no_cero_shannon3], "o", mfc="darkgreen", mec = "darkgreen", label='Filter Lowpass [ ' + str(frec4c) + ' ] Hz.', color='darkgreen')

                    ax.plot(dias[indices_no_cero_shannon], entropia_shannon4[indices_no_cero_shannon4], "o", mfc="r", mec = "r", label='Filter Lowpass [ ' + str(frec4d) + ' ] Hz.', color='darkorange')

                    ax.plot(dias[indices_no_cero_shannon], entropia_shannon5[indices_no_cero_shannon5], "o", mfc="darkgoldenrod", mec = "darkgoldenrod", label='Filter Lowpass [ ' + str(frec4e) + ' ] Hz.', color='darkgoldenrod')

                    plt.legend(prop = {'size': 10}, loc='upper right')          # Para colocar la leyenda a la izquierda
                    plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                    plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                    plt.title(Nombre3 + '_Shannon entropy with dots - Each point = 10 min. with Lowpass filter.' + " Envelope Windows = " + TM , color ="darkgreen", fontsize=12)

                    plt.show()


        except:                         # In any other case of invalid or empty inputs
                plt.close()                                                 # Close the existing chart.
                msgBox = QMessageBox()
                msgBox.setIcon(QMessageBox.Warning)
                msgBox.setText("The File Does not exist, is Invalid or the Format is not recognized. Please, try again ... ...")
                msgBox.setWindowTitle("Invalid input parameter or registry file")
                returnValue = msgBox.exec()
                pass



    def filtropasoalto(self):                                           # 2.- Function to execute the Highpass filter with 1 hr. analysis window.

        try:

            # Verifying that the checkbox is true. Work with time intervals.

            if self.checkBox.isChecked() == True:

                # Verify (Validation), that the text box and label is not empty

                if not self.label_5.text():
                    MensCombo1 = QMessageBox()
                    MensCombo1.setIcon(QMessageBox.Warning)
                    MensCombo1.setWindowTitle("Empty directory to upload records")
                    MensCombo1.setText("Please, enter a valid name of directory")
                    returnValue = MensCombo1.exec()

                elif not self.lineEdit_2.text():
                    MensCombo3 = QMessageBox()
                    MensCombo3.setIcon(QMessageBox.Warning)
                    MensCombo3.setWindowTitle("Empty Start time")
                    MensCombo3.setText("Please, enter a valid Value")
                    returnValue = MensCombo3.exec()

                elif not self.lineEdit_3.text():
                    MensCombo4 = QMessageBox()
                    MensCombo4.setIcon(QMessageBox.Warning)
                    MensCombo4.setWindowTitle("Empty End time")
                    MensCombo4.setText("Please, enter a valid Value")
                    returnValue = MensCombo4.exec()

                elif not self.lineEdit_4.text():
                    MensCombo5 = QMessageBox()
                    MensCombo5.setIcon(QMessageBox.Warning)
                    MensCombo5.setWindowTitle("Empty Filter Order")
                    MensCombo5.setText("Please, enter a valid Value")
                    returnValue = MensCombo5.exec()

                elif not self.lineEdit_5.text():
                    MensCombo6 = QMessageBox()
                    MensCombo6.setIcon(QMessageBox.Warning)
                    MensCombo6.setWindowTitle("Empty Frequency Filter 1")
                    MensCombo6.setText("Please, enter a valid Value")
                    returnValue = MensCombo6.exec()

                elif not self.lineEdit_6.text():
                    MensCombo7 = QMessageBox()
                    MensCombo7.setIcon(QMessageBox.Warning)
                    MensCombo7.setWindowTitle("Empty Frequency Filter 2")
                    MensCombo7.setText("Please, enter a valid Value")
                    returnValue = MensCombo7.exec()

                elif not self.lineEdit_7.text():
                    MensCombo3 = QMessageBox()
                    MensCombo3.setIcon(QMessageBox.Warning)
                    MensCombo3.setWindowTitle("Empty Frequency Filter 3")
                    MensCombo3.setText("Please, enter a valid Value")
                    returnValue = MensCombo3.exec()

                elif not self.lineEdit_8.text():
                    MensCombo8 = QMessageBox()
                    MensCombo8.setIcon(QMessageBox.Warning)
                    MensCombo8.setWindowTitle("Empty Frequency Filter 4")
                    MensCombo8.setText("Please, enter a valid Value")
                    returnValue = MensCombo8.exec()

                elif not self.lineEdit_9.text():
                    MensCombo9 = QMessageBox()
                    MensCombo9.setIcon(QMessageBox.Warning)
                    MensCombo9.setWindowTitle("Empty Frequency Filter 5")
                    MensCombo9.setText("Please, enter a valid Value")
                    returnValue = MensCombo9.exec()

                elif not self.lineEdit_20.text():
                    MensCombo10 = QMessageBox()
                    MensCombo10.setIcon(QMessageBox.Warning)
                    MensCombo10.setWindowTitle("Empty Envelope Window size")
                    MensCombo10.setText("Please, enter a valid Value")
                    returnValue = MensCombo10.exec()

                elif not self.lineEdit_21.text():
                    MensCombo11 = QMessageBox()
                    MensCombo11.setIcon(QMessageBox.Warning)
                    MensCombo11.setWindowTitle("Empty Smoothing type")
                    MensCombo11.setText("Please, enter a valid Value")
                    returnValue = MensCombo11.exec()

                elif not self.lineEdit_22.text():
                    MensCombo12 = QMessageBox()
                    MensCombo12.setIcon(QMessageBox.Warning)
                    MensCombo12.setWindowTitle("Empty NaN Tolerance")
                    MensCombo12.setText("Please, enter a valid Value")
                    returnValue = MensCombo12.exec()

                else:
                    # Filtering with a Highpass.
                    plt.close()                                                 # Close the existing chart.

                    carpeta = (self.label_5.text())                             # Reading the directory or file folder label.

                    # Code to detect the contents of the folder and the files that the folder contains
                    with os.scandir(carpeta) as ficheros:
                        ficheros4 = [fichero.name for fichero in ficheros if fichero.is_file()]

                    # The contents of the files in "ficheros4" is a list. This code converts them to string
                    lfiles = [str(elemento) for elemento in ficheros4]

                    # Code used to determine the name of the files contained in the folder and to be used in the loading loop
                    Iniciolfiles = lfiles[0]                                    # Detects the numeric value of the "Start" in the name
                    Finlfiles = lfiles[-1]                                      # Detects the numerical value of the "End" in the name
                    Indice1 = Iniciolfiles.rfind('.')                           # Determines the index, which will be marked by the dot at the end for the extension
                    Nombre3 = Iniciolfiles[0:Indice1]                           # Indicates the name of the file in str (minus) the index or extension (each day)

                    # Data entry from labels and fields or text boxes (this value is a string by default)

                    orden1 = (self.lineEdit_4.text())                           # reading filter order label.
                    frec3 = (self.lineEdit_5.text())                            # reading frequency Filter 1 Label.
                    frec3b = (self.lineEdit_6.text())                           # reading frequency Filter 2 Label.
                    frec3c = (self.lineEdit_7.text())                           # reading frequency Filter 3 Label.
                    frec3d = (self.lineEdit_8.text())                           # reading frequency Filter 4 Label.
                    frec3e = (self.lineEdit_9.text())                           # reading frequency Filter 5 Label.

                    # Data entry for enveloped (this value is a string by default)
                    Tam = (self.lineEdit_20.text())                             # Reading the envelope window size label.
                    Tsua = (self.lineEdit_21.text())                            # Reading the Smoothing type label.
                    Tnan = (self.lineEdit_22.text())                            # Reading the NaN Tolerance label.

                    Start1 = (self.lineEdit_2.text())                           # Star Time Size label reading.
                    End1 = (self.lineEdit_3.text())                             # End Time Size label reading.

                    # Convert the string value of the input text boxes to float or integer
                    frec4=float(frec3)                                          # Converts Frequency Filter 1 value to float.
                    frec4b=float(frec3b)                                        # Converts Frequency Filter 2 value to float.
                    frec4c=float(frec3c)                                        # Converts Frequency Filter 3 value to float.
                    frec4d=float(frec3d)                                        # Converts Frequency Filter 4 value to float.
                    frec4e=float(frec3e)                                        # Converts Frequency Filter 5 value to float.

                    orden4=int(orden1)                                          # Converts filter order value to integer.

                    Tam1=int(Tam)                                               # Converts the envelope window size value to integer.
                    Tsua1=int(Tsua)                                             # Converts the Smoothing type value to integer.
                    Tnan1=int(Tnan)                                             # Converts the NaN Tolerance value to integer.

                    timeIn = 365

                    Start2=int(Start1)                                          # Converts the Start time window size value to an integer.
                    End2=int(End1)                                              # Converts the End time window size value to an integer.

                    Diferencia = End2 - Start2                                  # Value of the difference between end and start to obtain the number of days to calculate

                    TM = str(Tam1)                                              # Coverts the windows size to string to put in plot label

                    Start2=int(Start1)                                          # Converts the Start time window size value to an integer.
                    End2=int(End1)                                              # Converts the End time window size value to an integer.

                    # Function for Shannon entropy calculating
                    def calcular_entropia(datos):
                        params = stats.norm.fit(datos)
                        dist = stats.norm(*params)
                        probabilidades = dist.pdf(datos)
                        entropia = -np.sum(probabilidades * np.log2(probabilidades))
                        return entropia

                    # Function for Shannon entropy enveloped calculating
                    def nanfastsmooth(Y, w, type=1, tol=0.5):

                        """
                        Smooths vector Y with a moving average of width w, ignoring NaNs in data.

                        Parameters:
                        Y (numpy array): Input signal.
                        w (int): Window width.
                        type (int): Smooth type (1 for rectangular, 2 for triangular, 3 for pseudo-Gaussian).
                        tol (float): Tolerance to NaNs between 0 and 1.

                        Returns:
                        numpy array: Smoothed signal.
                        """
                        mask = ~np.isnan(Y)  # Create a boolean mask for non-NaN values
                        Y[mask] = nanfastsmooth_core(Y[mask], w, type, tol)  # Apply smoothing to non-NaN values
                        return Y

                    # Function for Shannon entropy enveloped type calculating. For default the value = 3
                    def nanfastsmooth_core(Y, w, type, tol):
                        if type == 1:
                            SmoothY = moving_average(Y, w)
                        elif type == 2:
                            SmoothY = moving_average(moving_average(Y, w), w)
                        elif type == 3:
                            SmoothY = moving_average(moving_average(moving_average(Y, w), w), w)

                        return SmoothY

                    def moving_average(Y, window_size):
                        return np.convolve(Y, np.ones(window_size)/window_size, mode='same')

                    def apply_bandpass_filter(datos, frecuencia_muestreo, freq_band):
                        nyquist = 0.5 * frecuencia_muestreo
                        normal_freq_band = np.array(freq_band) / nyquist
                        b, a = signal.butter(4, normal_freq_band, btype='band')
                        datos_filtrados = signal.filtfilt(b, a, datos)
                        return datos_filtrados

                    # Start entropy and averaged entropy values
                    entropia_shannon = []
                    entropia_promediada = []

                    entropia_shannon2 = []
                    entropia_promediada2 = []

                    entropia_shannon3 = []
                    entropia_promediada3 = []

                    entropia_shannon4 = []
                    entropia_promediada4 = []

                    entropia_shannon5 = []
                    entropia_promediada5 = []

                    # Cycle for the day-by-day calculation of the entropy in the files contained in the folder, using the time range (Start to End)
                    for dia in range(Start2, End2 + 1):

                        archivo = Nombre3 + '.'+ f"{dia:003}"       # Here you select the name previously calculated plus point and the value of each Julian day

                        # If there is no file in the list, the entire day is added with a value of zero
                        if not os.path.exists(os.path.join(carpeta, archivo)):
                            for _ in range(24):  # Adds 24 hours with zero value if there is no file
                                entropia_shannon.append(0)
                                entropia_promediada.append(0)
                            continue

                        elif not os.path.exists(os.path.join(carpeta, archivo)):
                            for _ in range(24):  # AÃ±ade 24 horas con valor cero si no hay archivo
                                entropia_shannon2.append(0)
                                entropia_promediada2.append(0)
                            continue

                        elif not os.path.exists(os.path.join(carpeta, archivo)):
                            for _ in range(24):  # AÃ±ade 24 horas con valor cero si no hay archivo
                                entropia_shannon3.append(0)
                                entropia_promediada3.append(0)
                            continue

                        elif not os.path.exists(os.path.join(carpeta, archivo)):
                            for _ in range(24):  # AÃ±ade 24 horas con valor cero si no hay archivo
                                entropia_shannon4.append(0)
                                entropia_promediada4.append(0)
                            continue

                        elif not os.path.exists(os.path.join(carpeta, archivo)):
                            for _ in range(24):  # AÃ±ade 24 horas con valor cero si no hay archivo
                                entropia_shannon5.append(0)
                                entropia_promediada5.append(0)
                            continue

                        # CreaciÃ³n de st para la lectura del fichero
                        st = Stream()
                        st += read(os.path.join(carpeta, archivo))

                        # CreaciÃ³n de st2 para la lectura del fichero
                        st2 = Stream()
                        st2 += read(os.path.join(carpeta, archivo))

                        # CreaciÃ³n de st3 para la lectura del fichero
                        st3 = Stream()
                        st3 += read(os.path.join(carpeta, archivo))

                        # CreaciÃ³n de st4 para la lectura del fichero
                        st4 = Stream()
                        st4 += read(os.path.join(carpeta, archivo))

                        # CreaciÃ³n de st5 para la lectura del fichero
                        st5 = Stream()
                        st5 += read(os.path.join(carpeta, archivo))

                        frecuencia_muestreo = st[0].stats.sampling_rate

                        # calculation of the Highpass filter with the parameters indicated by the user.
                        st.filter('highpass', freq=frec4, corners=orden4, zerophase=True)

                        st2.filter('highpass', freq=frec4b, corners=orden4, zerophase=True)

                        st3.filter('highpass', freq=frec4c, corners=orden4, zerophase=True)

                        st4.filter('highpass', freq=frec4d, corners=orden4, zerophase=True)

                        st5.filter('highpass', freq=frec4e, corners=orden4, zerophase=True)

                        # Datos para st
                        datos = st[0].data

                        # Datos2 para st2
                        datos2 = st2[0].data

                        # Datos3 para st3
                        datos3 = st3[0].data

                        # Datos4 para st4
                        datos4 = st4[0].data

                        # Datos5 para st5
                        datos5 = st5[0].data

                        # Divide the data into hours and calculate entropy for each hour.
                        for hora in range(24*6):
                            inicio = hora * 600 * 100  # start of time in seconds.
                            fin = inicio + 600 * 100  # End of time in seconds.
                            datos_hora = datos[inicio:fin]

                            if len(datos_hora) < 600 * 100:  # If the hour is incomplete, add zeros to the end.
                                datos_hora = np.append(datos_hora, np.zeros(600 * 100 - len(datos_hora)))

                            entropia_shannon.append(calcular_entropia(datos_hora))
                            entropia_promediada.append(calcular_entropia(datos_hora) / len(datos_hora))

                        # Dividir los datos en horas y calcular entropÃ­a para cada hora con st2
                        for hora in range(24*6):
                            inicio = hora * 600 * 100  # inicio de la hora en segundos
                            fin = inicio + 600 * 100  # fin de la hora en segundos
                            datos_hora2 = datos2[inicio:fin]

                            if len(datos_hora2) < 600 * 100:  # Si la hora estÃ¡ incompleta, agregar ceros al final
                                datos_hora2 = np.append(datos_hora2, np.zeros(600 * 100 - len(datos_hora2)))

                            entropia_shannon2.append(calcular_entropia(datos_hora2))
                            entropia_promediada2.append(calcular_entropia(datos_hora2) / len(datos_hora2))

                        # Dividir los datos en horas y calcular entropÃ­a para cada hora con st3
                        for hora in range(24*6):
                            inicio = hora * 600 * 100  # inicio de la hora en segundos
                            fin = inicio + 600 * 100  # fin de la hora en segundos
                            datos_hora3 = datos3[inicio:fin]

                            if len(datos_hora3) < 600 * 100:  # Si la hora estÃ¡ incompleta, agregar ceros al final
                                datos_hora3 = np.append(datos_hora3, np.zeros(600 * 100 - len(datos_hora3)))

                            entropia_shannon3.append(calcular_entropia(datos_hora3))
                            entropia_promediada3.append(calcular_entropia(datos_hora3) / len(datos_hora3))

                        # Dividir los datos en horas y calcular entropÃ­a para cada hora con st4
                        for hora in range(24*6):
                            inicio = hora * 600 * 100  # inicio de la hora en segundos
                            fin = inicio + 600 * 100  # fin de la hora en segundos
                            datos_hora4 = datos4[inicio:fin]

                            if len(datos_hora4) < 600 * 100:  # Si la hora estÃ¡ incompleta, agregar ceros al final
                                datos_hora4 = np.append(datos_hora4, np.zeros(600 * 100 - len(datos_hora4)))

                            entropia_shannon4.append(calcular_entropia(datos_hora4))
                            entropia_promediada4.append(calcular_entropia(datos_hora4) / len(datos_hora4))

                        # Dividir los datos en horas y calcular entropÃ­a para cada hora con st5
                        for hora in range(24*6):
                            inicio = hora * 600 * 100  # inicio de la hora en segundos
                            fin = inicio + 600 * 100  # fin de la hora en segundos
                            datos_hora5 = datos5[inicio:fin]

                            if len(datos_hora5) < 600:  # Si la hora estÃ¡ incompleta, agregar ceros al final
                                datos_hora5 = np.append(datos_hora5, np.zeros(600 * 100 - len(datos_hora5)))

                            entropia_shannon5.append(calcular_entropia(datos_hora5))
                            entropia_promediada5.append(calcular_entropia(datos_hora5) / len(datos_hora5))

                    # CreaciÃ³n del array de la entropia normal y la promediada de Shannon para st1
                    entropia_shannon = np.array(entropia_shannon)
                    entropia_promediada = np.array(entropia_promediada)

                    # CreaciÃ³n del array de la entropia normal y la promediada de Shannon para st2
                    entropia_shannon2 = np.array(entropia_shannon2)
                    entropia_promediada2 = np.array(entropia_promediada2)

                    # CreaciÃ³n del array de la entropia normal y la promediada de Shannon para st3
                    entropia_shannon3 = np.array(entropia_shannon3)
                    entropia_promediada3 = np.array(entropia_promediada3)

                    # CreaciÃ³n del array de la entropia normal y la promediada de Shannon para st4
                    entropia_shannon4 = np.array(entropia_shannon4)
                    entropia_promediada4 = np.array(entropia_promediada4)

                    # CreaciÃ³n del array de la entropia normal y la promediada de Shannon para st4
                    entropia_shannon5 = np.array(entropia_shannon5)
                    entropia_promediada5 = np.array(entropia_promediada5)

                    # Shannon Entropy Graph. Value of non-zero indices where there is no data.
                    indices_no_cero_shannon = np.where(entropia_shannon != 0)[0]
                    indices_no_cero_shannon2 = np.where(entropia_shannon2 != 0)[0]
                    indices_no_cero_shannon3 = np.where(entropia_shannon3 != 0)[0]
                    indices_no_cero_shannon4 = np.where(entropia_shannon4 != 0)[0]
                    indices_no_cero_shannon5 = np.where(entropia_shannon5 != 0)[0]

                    # Use example
                    Y = entropia_shannon
                    Y = np.where(Y == 0, np.nan, Y)

                    Y1 = entropia_shannon2
                    Y1 = np.where(Y1 == 0, np.nan, Y1)

                    Y2 = entropia_shannon3
                    Y2 = np.where(Y2 == 0, np.nan, Y2)

                    Y3 = entropia_shannon4
                    Y3 = np.where(Y3 == 0, np.nan, Y3)

                    Y4 = entropia_shannon5
                    Y4 = np.where(Y4 == 0, np.nan, Y4)


                    # Plot the vectors into separate figures.

                    dias = np.arange(1, 8761*6+1)

                    # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE. *** The median filter function is used ***  PARA st1

                    y_filtered = nanfastsmooth(Y.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                    # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE. *** The median filter function is used ***  PARA st2
                    y_filtered2 = nanfastsmooth(Y1.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original   # By default work with size=50

                    # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE. *** The median filter function is used ***  PARA st3
                    y_filtered3 = nanfastsmooth(Y2.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original   # By default work with size=50

                    # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE. *** The median filter function is used ***  PARA st4
                    y_filtered4 = nanfastsmooth(Y3.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original   # By default work with size=50

                    # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE. *** The median filter function is used ***  PARA st5
                    y_filtered5 = nanfastsmooth(Y4.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original   # By default work with size=50


                    # Graph 4 - Envelope only graph.

                    fig, ax = plt.subplots() # To put several plot in same graphics.

                    ax.plot(dias[indices_no_cero_shannon], y_filtered[indices_no_cero_shannon], label='Filter Highpass [ ' + str(frec4) + ' ] Hz.', color='darkblue')

                    ax.plot(dias[indices_no_cero_shannon2], y_filtered2[indices_no_cero_shannon2], label='Filter Highpass [ ' + str(frec4b) + ' ] Hz.', color='red')

                    ax.plot(dias[indices_no_cero_shannon3], y_filtered3[indices_no_cero_shannon3], label='Filter Highpass [ ' + str(frec4c) + ' ] Hz.', color='darkgreen')

                    ax.plot(dias[indices_no_cero_shannon4], y_filtered4[indices_no_cero_shannon4], label='Filter Highpass [ ' + str(frec4d) + ' ] Hz.', color='darkorange')

                    ax.plot(dias[indices_no_cero_shannon5], y_filtered5[indices_no_cero_shannon5], label='Filter Highpass [ ' + str(frec4e) + ' ] Hz.', color='darkgoldenrod')

                    plt.legend(prop = {'size': 10}, loc='upper right')          # Para colocar la leyenda a la izquierda
                    plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                    plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                    plt.title(Nombre3 + '_Envelope of Shannon entropy - Each point = 10 min. with Highpass filter.' + " Envelope Windows = " + TM + '_Star = ' + Start1 + '_End = '+ End1, color ="darkgreen", fontsize=12)

                    # Graphs with dots

                    fig, ax = plt.subplots() # To put several plot in same graphics.

                    ax.plot(dias[indices_no_cero_shannon], entropia_shannon[indices_no_cero_shannon], "o", mfc="darkblue", mec = "darkblue", label='Filter Highpass [ ' + str(frec4) + ' ] Hz.', color='darkblue')

                    ax.plot(dias[indices_no_cero_shannon2], entropia_shannon2[indices_no_cero_shannon2], "o", mfc="red", mec = "red", label='Filter Highpass [ ' + str(frec4b) + ' ] Hz.', color='red')

                    ax.plot(dias[indices_no_cero_shannon3], entropia_shannon3[indices_no_cero_shannon3], "o", mfc="darkgreen", mec = "darkgreen", label='Filter Highpass [ ' + str(frec4c) + ' ] Hz.', color='darkgreen')

                    ax.plot(dias[indices_no_cero_shannon4], entropia_shannon4[indices_no_cero_shannon4], "o", mfc="r", mec = "r", label='Filter Highpass [ ' + str(frec4d) + ' ] Hz.', color='darkorange')

                    ax.plot(dias[indices_no_cero_shannon5], entropia_shannon5[indices_no_cero_shannon5], "o", mfc="darkgoldenrod", mec = "darkgoldenrod", label='Filter Highpass [ ' + str(frec4e) + ' ] Hz.', color='darkgoldenrod')

                    plt.legend(prop = {'size': 10}, loc='upper right')          # Para colocar la leyenda a la izquierda
                    plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                    plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                    plt.title(Nombre3 + '_Shannon entropy with dots - Each point = 10 min. with Highpass filter.' + " Envelope Windows = " + TM + '_Star = ' + Start1 + '_End = '+ End1, color ="darkgreen", fontsize=12)

                    plt.show()


            else:                                           # Here the value of the entropy is calculated without the time interval (Start - End)

                if not self.label_5.text():
                    MensCombo1 = QMessageBox()
                    MensCombo1.setIcon(QMessageBox.Warning)
                    MensCombo1.setWindowTitle("Empty directory to upload records")
                    MensCombo1.setText("Please, enter a valid name of directory")
                    returnValue = MensCombo1.exec()

                elif not self.lineEdit_4.text():
                    MensCombo3 = QMessageBox()
                    MensCombo3.setIcon(QMessageBox.Warning)
                    MensCombo3.setWindowTitle("Empty Filter Order")
                    MensCombo3.setText("Please, enter a valid Value")
                    returnValue = MensCombo3.exec()

                elif not self.lineEdit_5.text():
                    MensCombo4 = QMessageBox()
                    MensCombo4.setIcon(QMessageBox.Warning)
                    MensCombo4.setWindowTitle("Empty Frequency Filter 1")
                    MensCombo4.setText("Please, enter a valid Value")
                    returnValue = MensCombo4.exec()

                elif not self.lineEdit_6.text():
                    MensCombo5 = QMessageBox()
                    MensCombo5.setIcon(QMessageBox.Warning)
                    MensCombo5.setWindowTitle("Empty Frequency Filter 2")
                    MensCombo5.setText("Please, enter a valid Value")
                    returnValue = MensCombo5.exec()

                elif not self.lineEdit_7.text():
                    MensCombo6 = QMessageBox()
                    MensCombo6.setIcon(QMessageBox.Warning)
                    MensCombo6.setWindowTitle("Empty Frequency Filter 3")
                    MensCombo6.setText("Please, enter a valid Value")
                    returnValue = MensCombo6.exec()

                elif not self.lineEdit_8.text():
                    MensCombo7 = QMessageBox()
                    MensCombo7.setIcon(QMessageBox.Warning)
                    MensCombo7.setWindowTitle("Empty Frequency Filter 4")
                    MensCombo7.setText("Please, enter a valid Value")
                    returnValue = MensCombo7.exec()

                elif not self.lineEdit_9.text():
                    MensCombo8 = QMessageBox()
                    MensCombo8.setIcon(QMessageBox.Warning)
                    MensCombo8.setWindowTitle("Empty Frequency Filter 5")
                    MensCombo8.setText("Please, enter a valid Value")
                    returnValue = MensCombo8.exec()

                elif not self.lineEdit_20.text():
                    MensCombo9 = QMessageBox()
                    MensCombo9.setIcon(QMessageBox.Warning)
                    MensCombo9.setWindowTitle("Empty Envelope Window size")
                    MensCombo9.setText("Please, enter a valid Value")
                    returnValue = MensCombo9.exec()

                elif not self.lineEdit_21.text():
                    MensCombo10 = QMessageBox()
                    MensCombo10.setIcon(QMessageBox.Warning)
                    MensCombo10.setWindowTitle("Empty Smoothing type")
                    MensCombo10.setText("Please, enter a valid Value")
                    returnValue = MensCombo10.exec()

                elif not self.lineEdit_22.text():
                    MensCombo11 = QMessageBox()
                    MensCombo11.setIcon(QMessageBox.Warning)
                    MensCombo11.setWindowTitle("Empty NaN Tolerance")
                    MensCombo11.setText("Please, enter a valid Value")
                    returnValue = MensCombo11.exec()

                else:
                    # Filtering with a Highpass.
                    plt.close()                                                 # Close the existing chart.

                    carpeta = (self.label_5.text())                             # Reading the directory or file folder label.

                    # Code to detect the contents of the folder and the files that the folder contains
                    with os.scandir(carpeta) as ficheros:
                        ficheros4 = [fichero.name for fichero in ficheros if fichero.is_file()]

                    # The contents of the files in "ficheros4" is a list. This code converts them to string
                    lfiles = [str(elemento) for elemento in ficheros4]

                    # Code used to determine the name of the files contained in the folder and to be used in the loading loop
                    Iniciolfiles = lfiles[0]                                    # Detects the numeric value of the "Start" in the name
                    Finlfiles = lfiles[-1]                                      # Detects the numerical value of the "End" in the name
                    Indice1 = Iniciolfiles.rfind('.')                           # Determines the index, which will be marked by the dot at the end for the extension
                    Nombre3 = Iniciolfiles[0:Indice1]                           # Indicates the name of the file in str (minus) the index or extension (each day)

                    # Data entry from labels and fields or text boxes (this value is a string by default)

                    frec3 = (self.lineEdit_5.text())                            # reading frequency Filter 1 Label.
                    frec3b = (self.lineEdit_6.text())                           # reading frequency Filter 2 Label.
                    frec3c = (self.lineEdit_7.text())                           # reading frequency Filter 3 Label.
                    frec3d = (self.lineEdit_8.text())                           # reading frequency Filter 4 Label.
                    frec3e = (self.lineEdit_9.text())                           # reading frequency Filter 5 Label.

                    orden1 = (self.lineEdit_4.text())                           # Reading the Filter Order Label.

                    # Data entry for enveloped (this value is a string by default)
                    Tam = (self.lineEdit_20.text())                             # Reading the envelope window size label.
                    Tsua = (self.lineEdit_21.text())                             # Reading the Smoothing type label.
                    Tnan = (self.lineEdit_22.text())                            # Reading the NaN Tolerance label.

                    # Convert the string value of the input text boxes to float or integer
                    frec4=float(frec3)                                          # Converts Frequency Filter 1 value to float.
                    frec4b=float(frec3b)                                        # Converts Frequency Filter 2 value to float.
                    frec4c=float(frec3c)                                        # Converts Frequency Filter 3 value to float.
                    frec4d=float(frec3d)                                        # Converts Frequency Filter 4 value to float.
                    frec4e=float(frec3e)                                        # Converts Frequency Filter 5 value to float.

                    orden4=int(orden1)                                          # Converts filter order value to integer.

                    Tam1=int(Tam)                                               # Converts the envelope window size value to integer.
                    Tsua1=int(Tsua)                                             # Converts the Smoothing type value to integer.
                    Tnan1=int(Tnan)                                             # Converts the NaN Tolerance value to integer.

                    timeIn = 365

                    TM = str(Tam1)                                              # Coverts the windows size to string to put in plot label

                    # Function for Shannon entropy calculating
                    def calcular_entropia(datos):
                        params = stats.norm.fit(datos)
                        dist = stats.norm(*params)
                        probabilidades = dist.pdf(datos)
                        entropia = -np.sum(probabilidades * np.log2(probabilidades))
                        return entropia

                    # Function for Shannon entropy enveloped calculating
                    def nanfastsmooth(Y, w, type=1, tol=0.5):

                        """
                        Smooths vector Y with a moving average of width w, ignoring NaNs in data.

                        Parameters:
                        Y (numpy array): Input signal.
                        w (int): Window width.
                        type (int): Smooth type (1 for rectangular, 2 for triangular, 3 for pseudo-Gaussian).
                        tol (float): Tolerance to NaNs between 0 and 1.

                        Returns:
                        numpy array: Smoothed signal.
                        """
                        mask = ~np.isnan(Y)  # Create a boolean mask for non-NaN values
                        Y[mask] = nanfastsmooth_core(Y[mask], w, type, tol)  # Apply smoothing to non-NaN values
                        return Y

                    # Function for Shannon entropy enveloped type calculating. For default the value = 3
                    def nanfastsmooth_core(Y, w, type, tol):
                        if type == 1:
                            SmoothY = moving_average(Y, w)
                        elif type == 2:
                            SmoothY = moving_average(moving_average(Y, w), w)
                        elif type == 3:
                            SmoothY = moving_average(moving_average(moving_average(Y, w), w), w)

                        return SmoothY

                    def moving_average(Y, window_size):
                        return np.convolve(Y, np.ones(window_size)/window_size, mode='same')

                    def apply_bandpass_filter(datos, frecuencia_muestreo, freq_band):
                        nyquist = 0.5 * frecuencia_muestreo
                        normal_freq_band = np.array(freq_band) / nyquist
                        b, a = signal.butter(4, normal_freq_band, btype='band')
                        datos_filtrados = signal.filtfilt(b, a, datos)
                        return datos_filtrados

                    # Start entropy and averaged entropy values
                    entropia_shannon = []
                    entropia_promediada = []

                    entropia_shannon2 = []
                    entropia_promediada2 = []

                    entropia_shannon3 = []
                    entropia_promediada3 = []

                    entropia_shannon4 = []
                    entropia_promediada4 = []

                    entropia_shannon5 = []
                    entropia_promediada5 = []

                    # Cycle for the day-by-day calculation of the entropy in the files contained in the folder, using the time range (Start to End)
                    for dia in range(1, timeIn + 1):

                        archivo = Nombre3 + '.'+ f"{dia:003}"       # Here you select the name previously calculated plus point and the value of each Julian day

                        # If there is no file in the list, the entire day is added with a value of zero
                        if not os.path.exists(os.path.join(carpeta, archivo)):
                            for _ in range(24*6):  # AÃ±ade 24 horas con valor cero si no hay archivo
                                entropia_shannon.append(0)
                                entropia_promediada.append(0)
                            continue

                        elif not os.path.exists(os.path.join(carpeta, archivo)):
                            for _ in range(24*6):  # AÃ±ade 24 horas con valor cero si no hay archivo
                                entropia_shannon2.append(0)
                                entropia_promediada2.append(0)
                            continue

                        elif not os.path.exists(os.path.join(carpeta, archivo)):
                            for _ in range(24*6):  # AÃ±ade 24 horas con valor cero si no hay archivo
                                entropia_shannon3.append(0)
                                entropia_promediada3.append(0)
                            continue

                        elif not os.path.exists(os.path.join(carpeta, archivo)):
                            for _ in range(24*6):  # AÃ±ade 24 horas con valor cero si no hay archivo
                                entropia_shannon4.append(0)
                                entropia_promediada4.append(0)
                            continue

                        elif not os.path.exists(os.path.join(carpeta, archivo)):
                            for _ in range(24*6):  # AÃ±ade 24 horas con valor cero si no hay archivo
                                entropia_shannon5.append(0)
                                entropia_promediada5.append(0)
                            continue

                        # CreaciÃ³n de st para la lectura del fichero
                        st = Stream()
                        st += read(os.path.join(carpeta, archivo))

                        # CreaciÃ³n de st2 para la lectura del fichero
                        st2 = Stream()
                        st2 += read(os.path.join(carpeta, archivo))

                        # CreaciÃ³n de st3 para la lectura del fichero
                        st3 = Stream()
                        st3 += read(os.path.join(carpeta, archivo))

                        # CreaciÃ³n de st4 para la lectura del fichero
                        st4 = Stream()
                        st4 += read(os.path.join(carpeta, archivo))

                        # CreaciÃ³n de st5 para la lectura del fichero
                        st5 = Stream()
                        st5 += read(os.path.join(carpeta, archivo))

                        # calculation of the Highpass filter with the parameters indicated by the user.
                        st.filter('highpass', freq=frec4, corners=orden4, zerophase=True)

                        st2.filter('highpass', freq=frec4b, corners=orden4, zerophase=True)

                        st3.filter('highpass', freq=frec4c, corners=orden4, zerophase=True)

                        st4.filter('highpass', freq=frec4d, corners=orden4, zerophase=True)

                        st5.filter('highpass', freq=frec4e, corners=orden4, zerophase=True)

                        # Datos para st
                        datos = st[0].data

                        # Datos2 para st2
                        datos2 = st2[0].data

                        # Datos3 para st3
                        datos3 = st3[0].data

                        # Datos4 para st4
                        datos4 = st4[0].data

                        # Datos5 para st5
                        datos5 = st5[0].data

                        # Divide the data into hours and calculate entropy for each hour.
                        for hora in range(24*6):
                            inicio = hora * 600 * 100  # start of time in seconds.
                            fin = inicio + 600 * 100  # End of time in seconds.
                            datos_hora = datos[inicio:fin]

                            if len(datos_hora) < 600 * 100:  # If the hour is incomplete, add zeros to the end.
                                datos_hora = np.append(datos_hora, np.zeros(600 * 100 - len(datos_hora)))

                            entropia_shannon.append(calcular_entropia(datos_hora))
                            entropia_promediada.append(calcular_entropia(datos_hora) / len(datos_hora))

                        # Dividir los datos en horas y calcular entropÃ­a para cada hora con st2
                        for hora in range(24*6):
                            inicio = hora * 600 * 100  # inicio de la hora en segundos
                            fin = inicio + 600 * 100  # fin de la hora en segundos
                            datos_hora2 = datos2[inicio:fin]

                            if len(datos_hora2) < 600 * 100:  # Si la hora estÃ¡ incompleta, agregar ceros al final
                                datos_hora2 = np.append(datos_hora2, np.zeros(600 * 100 - len(datos_hora2)))

                            entropia_shannon2.append(calcular_entropia(datos_hora2))
                            entropia_promediada2.append(calcular_entropia(datos_hora2) / len(datos_hora2))

                        # Dividir los datos en horas y calcular entropÃ­a para cada hora con st3
                        for hora in range(24*6):
                            inicio = hora * 600 * 100  # inicio de la hora en segundos
                            fin = inicio + 600 * 100  # fin de la hora en segundos
                            datos_hora3 = datos3[inicio:fin]

                            if len(datos_hora3) < 600 * 100:  # Si la hora estÃ¡ incompleta, agregar ceros al final
                                datos_hora3 = np.append(datos_hora3, np.zeros(600 * 100 - len(datos_hora3)))

                            entropia_shannon3.append(calcular_entropia(datos_hora3))
                            entropia_promediada3.append(calcular_entropia(datos_hora3) / len(datos_hora3))

                        # Dividir los datos en horas y calcular entropÃ­a para cada hora con st4
                        for hora in range(24*6):
                            inicio = hora * 600 * 100  # inicio de la hora en segundos
                            fin = inicio + 600 * 100  # fin de la hora en segundos
                            datos_hora4 = datos4[inicio:fin]

                            if len(datos_hora4) < 600 * 100:  # Si la hora estÃ¡ incompleta, agregar ceros al final
                                datos_hora4 = np.append(datos_hora4, np.zeros(600 * 100 - len(datos_hora4)))

                            entropia_shannon4.append(calcular_entropia(datos_hora4))
                            entropia_promediada4.append(calcular_entropia(datos_hora4) / len(datos_hora4))

                        # Dividir los datos en horas y calcular entropÃ­a para cada hora con st5
                        for hora in range(24*6):
                            inicio = hora * 600 * 100  # inicio de la hora en segundos
                            fin = inicio + 600 * 100  # fin de la hora en segundos
                            datos_hora5 = datos5[inicio:fin]

                            if len(datos_hora5) < 600:  # Si la hora estÃ¡ incompleta, agregar ceros al final
                                datos_hora5 = np.append(datos_hora5, np.zeros(600 * 100 - len(datos_hora5)))

                            entropia_shannon5.append(calcular_entropia(datos_hora5))
                            entropia_promediada5.append(calcular_entropia(datos_hora5) / len(datos_hora5))


                    # CreaciÃ³n del array de la entropia normal y la promediada de Shannon para st1
                    entropia_shannon = np.array(entropia_shannon)
                    entropia_promediada = np.array(entropia_promediada)

                    # CreaciÃ³n del array de la entropia normal y la promediada de Shannon para st2
                    entropia_shannon2 = np.array(entropia_shannon2)
                    entropia_promediada2 = np.array(entropia_promediada2)

                    # CreaciÃ³n del array de la entropia normal y la promediada de Shannon para st3
                    entropia_shannon3 = np.array(entropia_shannon3)
                    entropia_promediada3 = np.array(entropia_promediada3)

                    # CreaciÃ³n del array de la entropia normal y la promediada de Shannon para st4
                    entropia_shannon4 = np.array(entropia_shannon4)
                    entropia_promediada4 = np.array(entropia_promediada4)

                    # CreaciÃ³n del array de la entropia normal y la promediada de Shannon para st4
                    entropia_shannon5 = np.array(entropia_shannon5)
                    entropia_promediada5 = np.array(entropia_promediada5)

                    # Graficar los vectores en figuras separadas

                    dias = np.arange(1, 8761*6+1)

                    # GrÃ¡fico de EntropÃ­a de Shannon

                    indices_no_cero_shannon = np.where(entropia_shannon != 0)[0]
                    indices_no_cero_shannon2 = np.where(entropia_shannon2 != 0)[0]
                    indices_no_cero_shannon3 = np.where(entropia_shannon3 != 0)[0]
                    indices_no_cero_shannon4 = np.where(entropia_shannon4 != 0)[0]
                    indices_no_cero_shannon5 = np.where(entropia_shannon5 != 0)[0]

                    # Use example
                    Y = entropia_shannon
                    Y = np.where(Y == 0, np.nan, Y)

                    Y1 = entropia_shannon2
                    Y1 = np.where(Y1 == 0, np.nan, Y1)

                    Y2 = entropia_shannon3
                    Y2 = np.where(Y2 == 0, np.nan, Y2)

                    Y3 = entropia_shannon4
                    Y3 = np.where(Y3 == 0, np.nan, Y3)

                    Y4 = entropia_shannon5
                    Y4 = np.where(Y4 == 0, np.nan, Y4)


                    # Plot the vectors into separate figures.

                    # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE. *** The median filter function is used ***  PARA st1

                    y_filtered = nanfastsmooth(Y.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                    # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE. *** The median filter function is used ***  PARA st2
                    y_filtered2 = nanfastsmooth(Y1.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original   # By default work with size=50

                    # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE. *** The median filter function is used ***  PARA st3
                    y_filtered3 = nanfastsmooth(Y2.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original   # By default work with size=50

                    # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE. *** The median filter function is used ***  PARA st4
                    y_filtered4 = nanfastsmooth(Y3.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original   # By default work with size=50

                    # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE. *** The median filter function is used ***  PARA st5
                    y_filtered5 = nanfastsmooth(Y4.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original   # By default work with size=50


                    # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                    # Graph 4 - Envelope only graph.

                    fig, ax = plt.subplots() # To put several plot in same graphics.

                    ax.plot(dias[indices_no_cero_shannon], y_filtered[indices_no_cero_shannon], label='Filter Highpass [ ' + str(frec4) + ' ] Hz.', color='darkblue')

                    ax.plot(dias[indices_no_cero_shannon2], y_filtered2[indices_no_cero_shannon2], label='Filter Highpass [ ' + str(frec4b) + ' ] Hz.', color='red')

                    ax.plot(dias[indices_no_cero_shannon3], y_filtered3[indices_no_cero_shannon3], label='Filter Highpass [ ' + str(frec4c) + ' ] Hz.', color='darkgreen')

                    ax.plot(dias[indices_no_cero_shannon4], y_filtered4[indices_no_cero_shannon4], label='Filter Highpass [ ' + str(frec4d) + ' ] Hz.', color='darkorange')

                    ax.plot(dias[indices_no_cero_shannon5], y_filtered5[indices_no_cero_shannon5], label='Filter Highpass [ ' + str(frec4e) + ' ] Hz.', color='darkgoldenrod')

                    plt.legend(prop = {'size': 10}, loc='upper right')          # Para colocar la leyenda a la izquierda
                    plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                    plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                    plt.title(Nombre3 + '_Envelope of Shannon entropy - Each point = 10 min. with Highpass filter.' + " Envelope Windows = " + TM , color ="darkgreen", fontsize=12)

                    # Grahps with dots

                    fig, ax = plt.subplots() # To put several plot in same graphics.

                    ax.plot(dias[indices_no_cero_shannon], entropia_shannon[indices_no_cero_shannon], "o", mfc="darkblue", mec = "darkblue", label='Filter Highpass [ ' + str(frec4) + ' ] Hz.', color='darkblue')

                    ax.plot(dias[indices_no_cero_shannon], entropia_shannon2[indices_no_cero_shannon2], "o", mfc="red", mec = "red", label='Filter Highpass [ ' + str(frec4b) + ' ] Hz.', color='red')

                    ax.plot(dias[indices_no_cero_shannon], entropia_shannon3[indices_no_cero_shannon3], "o", mfc="darkgreen", mec = "darkgreen", label='Filter Highpass [ ' + str(frec4c) + ' ] Hz.', color='darkgreen')

                    ax.plot(dias[indices_no_cero_shannon], entropia_shannon4[indices_no_cero_shannon4], "o", mfc="r", mec = "r", label='Filter Highpass [ ' + str(frec4d) + ' ] Hz.', color='darkorange')

                    ax.plot(dias[indices_no_cero_shannon], entropia_shannon5[indices_no_cero_shannon5], "o", mfc="darkgoldenrod", mec = "darkgoldenrod", label='Filter Highpass [ ' + str(frec4e) + ' ] Hz.', color='darkgoldenrod')

                    plt.legend(prop = {'size': 10}, loc='upper right')          # Para colocar la leyenda a la izquierda
                    plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                    plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                    plt.title(Nombre3 + '_Shannon entropy with dots - Each point = 10 min. with Highpass filter.' + " Envelope Windows = " + TM , color ="darkgreen", fontsize=12)

                    plt.show()


        except:                         # In any other case of invalid or empty inputs
                plt.close()                                                 # Close the existing chart.
                msgBox = QMessageBox()
                msgBox.setIcon(QMessageBox.Warning)
                msgBox.setText("The File Does not exist, is Invalid or the Format is not recognized. Please, try again ... ...")
                msgBox.setWindowTitle("Invalid input parameter or registry file")
                returnValue = msgBox.exec()
                pass



    def filtropasabanda(self):                                           # 3.- Function to execute the Bandpass filter with 1 hr. analysis window.

        try:

            # Verifying that the checkbox is true. Work with time intervals.

            if self.checkBox.isChecked() == True:

                # Verify (Validation), that the text box and label is not empty.

                if not self.label_5.text():
                    MensCombo1 = QMessageBox()
                    MensCombo1.setIcon(QMessageBox.Warning)
                    MensCombo1.setWindowTitle("Empty directory to upload records")
                    MensCombo1.setText("Please, enter a valid name of directory")
                    returnValue = MensCombo1.exec()

                elif not self.lineEdit_2.text():
                    MensCombo3 = QMessageBox()
                    MensCombo3.setIcon(QMessageBox.Warning)
                    MensCombo3.setWindowTitle("Empty Start time")
                    MensCombo3.setText("Please, enter a valid Value")
                    returnValue = MensCombo3.exec()

                elif not self.lineEdit_3.text():
                    MensCombo4 = QMessageBox()
                    MensCombo4.setIcon(QMessageBox.Warning)
                    MensCombo4.setWindowTitle("Empty End time")
                    MensCombo4.setText("Please, enter a valid Value")
                    returnValue = MensCombo4.exec()

                elif not self.lineEdit_4.text():
                    MensCombo5 = QMessageBox()
                    MensCombo5.setIcon(QMessageBox.Warning)
                    MensCombo5.setWindowTitle("Empty Filter Order")
                    MensCombo5.setText("Please, enter a valid Value")
                    returnValue = MensCombo5.exec()

                elif not self.lineEdit_10.text():
                    MensCombo6 = QMessageBox()
                    MensCombo6.setIcon(QMessageBox.Warning)
                    MensCombo6.setWindowTitle("Empty Min. Freq. Filter 1")
                    MensCombo6.setText("Please, enter a valid Value")
                    returnValue = MensCombo6.exec()

                elif not self.lineEdit_11.text():
                    MensCombo7 = QMessageBox()
                    MensCombo7.setIcon(QMessageBox.Warning)
                    MensCombo7.setWindowTitle("Empty Max. Freq. Filter 1")
                    MensCombo7.setText("Please, enter a valid Value")
                    returnValue = MensCombo7.exec()

                elif not self.lineEdit_12.text():
                    MensCombo8 = QMessageBox()
                    MensCombo8.setIcon(QMessageBox.Warning)
                    MensCombo8.setWindowTitle("Empty Min. Freq. Filter 2")
                    MensCombo8.setText("Please, enter a valid Value")
                    returnValue = MensCombo8.exec()

                elif not self.lineEdit_13.text():
                    MensCombo9 = QMessageBox()
                    MensCombo9.setIcon(QMessageBox.Warning)
                    MensCombo9.setWindowTitle("Empty Max. Freq. Filter 2")
                    MensCombo9.setText("Please, enter a valid Value")
                    returnValue = MensCombo9.exec()

                elif not self.lineEdit_14.text():
                    MensCombo10 = QMessageBox()
                    MensCombo10.setIcon(QMessageBox.Warning)
                    MensCombo10.setWindowTitle("Empty Min. Freq. Filter 3")
                    MensCombo10.setText("Please, enter a valid Value")
                    returnValue = MensCombo10.exec()

                elif not self.lineEdit_15.text():
                    MensCombo11 = QMessageBox()
                    MensCombo11.setIcon(QMessageBox.Warning)
                    MensCombo11.setWindowTitle("Empty Max. Freq. Filter 3")
                    MensCombo11.setText("Please, enter a valid Value")
                    returnValue = MensCombo11.exec()

                elif not self.lineEdit_16.text():
                    MensCombo12 = QMessageBox()
                    MensCombo12.setIcon(QMessageBox.Warning)
                    MensCombo12.setWindowTitle("Empty Min. Freq. Filter 4")
                    MensCombo12.setText("Please, enter a valid Value")
                    returnValue = MensCombo12.exec()

                elif not self.lineEdit_17.text():
                    MensCombo13 = QMessageBox()
                    MensCombo13.setIcon(QMessageBox.Warning)
                    MensCombo13.setWindowTitle("Empty Max. Freq. Filter 4")
                    MensCombo13.setText("Please, enter a valid Value")
                    returnValue = MensCombo13.exec()

                elif not self.lineEdit_18.text():
                    MensCombo14 = QMessageBox()
                    MensCombo14.setIcon(QMessageBox.Warning)
                    MensCombo14.setWindowTitle("Empty Min. Freq. Filter 5")
                    MensCombo14.setText("Please, enter a valid Value")
                    returnValue = MensCombo14.exec()

                elif not self.lineEdit_19.text():
                    MensCombo15 = QMessageBox()
                    MensCombo15.setIcon(QMessageBox.Warning)
                    MensCombo15.setWindowTitle("Empty Max. Freq. Filter 5")
                    MensCombo15.setText("Please, enter a valid Value")
                    returnValue = MensCombo15.exec()

                elif not self.lineEdit_20.text():
                    MensCombo16 = QMessageBox()
                    MensCombo16.setIcon(QMessageBox.Warning)
                    MensCombo16.setWindowTitle("Empty Envelope Window size")
                    MensCombo16.setText("Please, enter a valid Value")
                    returnValue = MensCombo16.exec()

                elif not self.lineEdit_21.text():
                    MensCombo17 = QMessageBox()
                    MensCombo17.setIcon(QMessageBox.Warning)
                    MensCombo17.setWindowTitle("Empty Smoothing type")
                    MensCombo17.setText("Please, enter a valid Value")
                    returnValue = MensCombo17.exec()

                elif not self.lineEdit_22.text():
                    MensCombo18 = QMessageBox()
                    MensCombo18.setIcon(QMessageBox.Warning)
                    MensCombo18.setWindowTitle("Empty NaN Tolerance")
                    MensCombo18.setText("Please, enter a valid Value")
                    returnValue = MensCombo18.exec()

                else:
                    # Filtering with a Bandpass.
                    plt.close()                                                 # Close the existing chart.

                    carpeta = (self.label_5.text())                             # Reading the directory or file folder label.

                    # Code to detect the contents of the folder and the files that the folder contains
                    with os.scandir(carpeta) as ficheros:
                        ficheros4 = [fichero.name for fichero in ficheros if fichero.is_file()]

                    # The contents of the files in "ficheros4" is a list. This code converts them to string
                    lfiles = [str(elemento) for elemento in ficheros4]

                    # Code used to determine the name of the files contained in the folder and to be used in the loading loop
                    Iniciolfiles = lfiles[0]                                    # Detects the numeric value of the "Start" in the name
                    Finlfiles = lfiles[-1]                                      # Detects the numerical value of the "End" in the name
                    Indice1 = Iniciolfiles.rfind('.')                           # Determines the index, which will be marked by the dot at the end for the extension
                    Nombre3 = Iniciolfiles[0:Indice1]                           # Indicates the name of the file in str (minus) the index or extension (each day)

                    # Data entry from labels and fields or text boxes (this value is a string by default)

                    frecMin = (self.lineEdit_10.text())                          # Minimum Frequency, Filter 1 label reading.
                    frecMax = (self.lineEdit_11.text())                          # Maximum Frequency, Filter 1 label reading.

                    frecMin2 = (self.lineEdit_12.text())                          # Minimum Frequency, Filter 2 label reading.
                    frecMax2 = (self.lineEdit_13.text())                          # Maximum Frequency, Filter 2 label reading.

                    frecMin3 = (self.lineEdit_14.text())                          # Minimum Frequency, Filter 3 label reading.
                    frecMax3 = (self.lineEdit_15.text())                          # Maximum Frequency, Filter 3 label reading.

                    frecMin4 = (self.lineEdit_16.text())                          # Minimum Frequency, Filter 4 label reading.
                    frecMax4 = (self.lineEdit_17.text())                          # Maximum Frequency, Filter 4 label reading.

                    frecMin5 = (self.lineEdit_18.text())                          # Minimum Frequency, Filter 5 label reading.
                    frecMax5 = (self.lineEdit_19.text())                          # Maximum Frequency, Filter 5 label reading.

                    orden1 = (self.lineEdit_4.text())                           # Reading the Filter Order Label.

                    # Data entry for enveloped (this value is a string by default)
                    Tam = (self.lineEdit_20.text())                             # Reading the envelope window size label.
                    Tsua = (self.lineEdit_21.text())                            # Reading the Smoothing type label.
                    Tnan = (self.lineEdit_22.text())                            # Reading the NaN Tolerance label.

                    Start1 = (self.lineEdit_2.text())                           # Star Time Size label reading.
                    End1 = (self.lineEdit_3.text())                             # End Time Size label reading.

                    # Convert the string value of the input text boxes to float or integer
                    frecMinB=float(frecMin)                                     # Converts Minimum Frequency, Filter 1 value to float.
                    frecMaxB=float(frecMax)                                     # Converts Maximum Frequency, Filter 1 value to float.

                    frecMin2B=float(frecMin2)                                   # Converts Minimum Frequency, Filter 2 value to float.
                    frecMax2B=float(frecMax2)                                   # Converts Maximum Frequency, Filter 2 value to float.

                    frecMin3B=float(frecMin3)                                   # Converts Minimum Frequency, Filter 3 value to float.
                    frecMax3B=float(frecMax3)                                   # Converts Maximum Frequency, Filter 3 value to float.

                    frecMin4B=float(frecMin4)                                   # Converts Minimum Frequency, Filter 4 value to float.
                    frecMax4B=float(frecMax4)                                   # Converts Maximum Frequency, Filter 4 value to float.

                    frecMin5B=float(frecMin5)                                   # Converts Minimum Frequency, Filter 5 value to float.
                    frecMax5B=float(frecMax5)                                   # Converts Maximum Frequency, Filter 5 value to float.

                    orden4=int(orden1)                                          # Converts filter order value to integer.

                    Tam1=int(Tam)                                               # Converts the envelope window size value to integer.
                    Tsua1=int(Tsua)                                             # Converts the Smoothing type value to integer.
                    Tnan1=int(Tnan)                                             # Converts the NaN Tolerance value to integer.

                    timeIn = 365

                    Start2=int(Start1)                                          # Converts the Start time window size value to an integer.
                    End2=int(End1)                                              # Converts the End time window size value to an integer.

                    Diferencia = End2 - Start2                                  # Value of the difference between end and start to obtain the number of days to calculate

                    TM = str(Tam1)                                              # Coverts the windows size to string to put in plot label

                    Start2=int(Start1)                                          # Converts the Start time window size value to an integer.
                    End2=int(End1)                                              # Converts the End time window size value to an integer.

                    # Function for Shannon entropy calculating
                    def calcular_entropia(datos):
                        params = stats.norm.fit(datos)
                        dist = stats.norm(*params)
                        probabilidades = dist.pdf(datos)
                        entropia = -np.sum(probabilidades * np.log2(probabilidades))
                        return entropia

                    # Function for Shannon entropy enveloped calculating
                    def nanfastsmooth(Y, w, type=1, tol=0.5):

                        """
                        Smooths vector Y with a moving average of width w, ignoring NaNs in data.

                        Parameters:
                        Y (numpy array): Input signal.
                        w (int): Window width.
                        type (int): Smooth type (1 for rectangular, 2 for triangular, 3 for pseudo-Gaussian).
                        tol (float): Tolerance to NaNs between 0 and 1.

                        Returns:
                        numpy array: Smoothed signal.
                        """
                        mask = ~np.isnan(Y)  # Create a boolean mask for non-NaN values
                        Y[mask] = nanfastsmooth_core(Y[mask], w, type, tol)  # Apply smoothing to non-NaN values
                        return Y

                    # Function for Shannon entropy enveloped type calculating. For default the value = 3
                    def nanfastsmooth_core(Y, w, type, tol):
                        if type == 1:
                            SmoothY = moving_average(Y, w)
                        elif type == 2:
                            SmoothY = moving_average(moving_average(Y, w), w)
                        elif type == 3:
                            SmoothY = moving_average(moving_average(moving_average(Y, w), w), w)

                        return SmoothY

                    def moving_average(Y, window_size):
                        return np.convolve(Y, np.ones(window_size)/window_size, mode='same')

                    def apply_bandpass_filter(datos, frecuencia_muestreo, freq_band):
                        nyquist = 0.5 * frecuencia_muestreo
                        normal_freq_band = np.array(freq_band) / nyquist
                        b, a = signal.butter(4, normal_freq_band, btype='band')
                        datos_filtrados = signal.filtfilt(b, a, datos)
                        return datos_filtrados

                    # Start entropy and averaged entropy values
                    entropia_shannon = []
                    entropia_promediada = []

                    entropia_shannon2 = []
                    entropia_promediada2 = []

                    entropia_shannon3 = []
                    entropia_promediada3 = []

                    entropia_shannon4 = []
                    entropia_promediada4 = []

                    entropia_shannon5 = []
                    entropia_promediada5 = []

                    # Cycle for the day-by-day calculation of the entropy in the files contained in the folder, using the time range (Start to End)
                    for dia in range(Start2, End2 + 1):

                        archivo = Nombre3 + '.'+ f"{dia:003}"       # Here you select the name previously calculated plus point and the value of each Julian day

                        # If there is no file in the list, the entire day is added with a value of zero
                        if not os.path.exists(os.path.join(carpeta, archivo)):
                            for _ in range(24):  # Adds 24 hours with zero value if there is no file
                                entropia_shannon.append(0)
                                entropia_promediada.append(0)
                            continue

                        elif not os.path.exists(os.path.join(carpeta, archivo)):
                            for _ in range(24):  # AÃ±ade 24 horas con valor cero si no hay archivo
                                entropia_shannon2.append(0)
                                entropia_promediada2.append(0)
                            continue

                        elif not os.path.exists(os.path.join(carpeta, archivo)):
                            for _ in range(24):  # AÃ±ade 24 horas con valor cero si no hay archivo
                                entropia_shannon3.append(0)
                                entropia_promediada3.append(0)
                            continue

                        elif not os.path.exists(os.path.join(carpeta, archivo)):
                            for _ in range(24):  # AÃ±ade 24 horas con valor cero si no hay archivo
                                entropia_shannon4.append(0)
                                entropia_promediada4.append(0)
                            continue

                        elif not os.path.exists(os.path.join(carpeta, archivo)):
                            for _ in range(24):  # AÃ±ade 24 horas con valor cero si no hay archivo
                                entropia_shannon5.append(0)
                                entropia_promediada5.append(0)
                            continue

                        # CreaciÃ³n de st para la lectura del fichero
                        st = Stream()
                        st += read(os.path.join(carpeta, archivo))

                        # CreaciÃ³n de st2 para la lectura del fichero
                        st2 = Stream()
                        st2 += read(os.path.join(carpeta, archivo))

                        # CreaciÃ³n de st3 para la lectura del fichero
                        st3 = Stream()
                        st3 += read(os.path.join(carpeta, archivo))

                        # CreaciÃ³n de st4 para la lectura del fichero
                        st4 = Stream()
                        st4 += read(os.path.join(carpeta, archivo))

                        # CreaciÃ³n de st5 para la lectura del fichero
                        st5 = Stream()
                        st5 += read(os.path.join(carpeta, archivo))

                        # calculation of the bandpass filter with the parameters indicated by the user.
                        st.filter('bandpass', freqmin=frecMinB, freqmax=frecMaxB, corners=4, zerophase=True)

                        st2.filter('bandpass', freqmin=frecMin2B, freqmax=frecMax2B, corners=4, zerophase=True)

                        st3.filter('bandpass', freqmin=frecMin3B, freqmax=frecMax3B, corners=4, zerophase=True)

                        st4.filter('bandpass', freqmin=frecMin4B, freqmax=frecMax4B, corners=4, zerophase=True)

                        st5.filter('bandpass', freqmin=frecMin5B, freqmax=frecMax5B, corners=4, zerophase=True)

                        # Datos para st
                        datos = st[0].data
                        #diff = datos[1:] - datos[0:-1]

                        # Datos2 para st2
                        datos2 = st2[0].data
                        #diff2 = datos2[1:] - datos2[0:-1]

                        # Datos3 para st3
                        datos3 = st3[0].data
                        #diff3 = datos3[1:] - datos3[0:-1]

                        # Datos4 para st4
                        datos4 = st4[0].data
                        #diff4 = datos4[1:] - datos4[0:-1]

                        # Datos5 para st5
                        datos5 = st5[0].data
                        #diff5 = datos5[1:] - datos5[0:-1]

                        # Divide the data into hours and calculate entropy for each hour.

                        # CreaciÃ³n de las entropias en base a los datos con st
                        for hora in range(24*6):
                            inicio = hora * 600 * 100  # start of time in seconds.
                            fin = inicio + 600 * 100  # End of time in seconds.
                            datos_hora = datos[inicio:fin]

                            if len(datos_hora) < 600 * 100:  # If the hour is incomplete, add zeros to the end.
                                datos_hora = np.append(datos_hora, np.zeros(600 * 100 - len(datos_hora)))

                            # Accumulator of the calculated values of the Shannon entropy and the averaged entropy.
                            entropia_shannon.append(calcular_entropia(datos_hora))
                            entropia_promediada.append(calcular_entropia(datos_hora) / len(datos_hora))

                        # Dividir los datos en horas y calcular entropÃ­a para cada hora con st2
                        for hora in range(24*6):
                            inicio = hora * 600 * 100  # inicio de la hora en segundos
                            fin = inicio + 600 * 100  # fin de la hora en segundos
                            datos_hora2 = datos2[inicio:fin]

                            if len(datos_hora2) < 600 * 100:  # Si la hora estÃ¡ incompleta, agregar ceros al final
                                datos_hora2 = np.append(datos_hora2, np.zeros(600 * 100 - len(datos_hora2)))

                            entropia_shannon2.append(calcular_entropia(datos_hora2))
                            entropia_promediada2.append(calcular_entropia(datos_hora2) / len(datos_hora2))

                        # Dividir los datos en horas y calcular entropÃ­a para cada hora con st3
                        for hora in range(24*6):
                            inicio = hora * 600 * 100  # inicio de la hora en segundos
                            fin = inicio + 600 * 100  # fin de la hora en segundos
                            datos_hora3 = datos3[inicio:fin]

                            if len(datos_hora3) < 600 * 100:  # Si la hora estÃ¡ incompleta, agregar ceros al final
                                datos_hora3 = np.append(datos_hora3, np.zeros(600 * 100 - len(datos_hora3)))

                            entropia_shannon3.append(calcular_entropia(datos_hora3))
                            entropia_promediada3.append(calcular_entropia(datos_hora3) / len(datos_hora3))

                        # Dividir los datos en horas y calcular entropÃ­a para cada hora con st4
                        for hora in range(24*6):
                            inicio = hora * 600 * 100  # inicio de la hora en segundos
                            fin = inicio + 600 * 100  # fin de la hora en segundos
                            datos_hora4 = datos4[inicio:fin]

                            if len(datos_hora4) < 600 * 100:  # Si la hora estÃ¡ incompleta, agregar ceros al final
                                datos_hora4 = np.append(datos_hora4, np.zeros(600 * 100 - len(datos_hora4)))

                            entropia_shannon4.append(calcular_entropia(datos_hora4))
                            entropia_promediada4.append(calcular_entropia(datos_hora4) / len(datos_hora4))

                        # Dividir los datos en horas y calcular entropÃ­a para cada hora con st5
                        for hora in range(24*6):
                            inicio = hora * 600 * 100  # inicio de la hora en segundos
                            fin = inicio + 600 * 100  # fin de la hora en segundos
                            datos_hora5 = datos5[inicio:fin]

                            if len(datos_hora5) < 600 * 100:  # Si la hora estÃ¡ incompleta, agregar ceros al final
                                datos_hora5 = np.append(datos_hora5, np.zeros(600 * 100 - len(datos_hora5)))

                            entropia_shannon5.append(calcular_entropia(datos_hora5))
                            entropia_promediada5.append(calcular_entropia(datos_hora5) / len(datos_hora5))

                    # CreaciÃ³n del array de la entropia normal y la promediada de Shannon para st1
                    entropia_shannon = np.array(entropia_shannon)
                    entropia_promediada = np.array(entropia_promediada)

                    # CreaciÃ³n del array de la entropia normal y la promediada de Shannon para st2
                    entropia_shannon2 = np.array(entropia_shannon2)
                    entropia_promediada2 = np.array(entropia_promediada2)

                    # CreaciÃ³n del array de la entropia normal y la promediada de Shannon para st3
                    entropia_shannon3 = np.array(entropia_shannon3)
                    entropia_promediada3 = np.array(entropia_promediada3)

                    # CreaciÃ³n del array de la entropia normal y la promediada de Shannon para st4
                    entropia_shannon4 = np.array(entropia_shannon4)
                    entropia_promediada4 = np.array(entropia_promediada4)

                    # CreaciÃ³n del array de la entropia normal y la promediada de Shannon para st4
                    entropia_shannon5 = np.array(entropia_shannon5)
                    entropia_promediada5 = np.array(entropia_promediada5)

                    # Shannon Entropy Graph. Value of non-zero indices where there is no data.
                    indices_no_cero_shannon = np.where(entropia_shannon != 0)[0]
                    indices_no_cero_shannon2 = np.where(entropia_shannon2 != 0)[0]
                    indices_no_cero_shannon3 = np.where(entropia_shannon3 != 0)[0]
                    indices_no_cero_shannon4 = np.where(entropia_shannon4 != 0)[0]
                    indices_no_cero_shannon5 = np.where(entropia_shannon5 != 0)[0]

                    # Use example
                    Y = entropia_shannon
                    Y = np.where(Y == 0, np.nan, Y)

                    Y1 = entropia_shannon2
                    Y1 = np.where(Y1 == 0, np.nan, Y1)

                    Y2 = entropia_shannon3
                    Y2 = np.where(Y2 == 0, np.nan, Y2)

                    Y3 = entropia_shannon4
                    Y3 = np.where(Y3 == 0, np.nan, Y3)

                    Y4 = entropia_shannon5
                    Y4 = np.where(Y4 == 0, np.nan, Y4)

                    # Plot the vectors into separate figures.

                    dias = np.arange(1, 8761*6+1)


                    # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE. *** The median filter function is used ***  PARA st1

                    y_filtered = nanfastsmooth(Y.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                    # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE. *** The median filter function is used ***  PARA st2
                    y_filtered2 = nanfastsmooth(Y1.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original   # By default work with size=50

                    # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE. *** The median filter function is used ***  PARA st3
                    y_filtered3 = nanfastsmooth(Y2.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original   # By default work with size=50

                    # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE. *** The median filter function is used ***  PARA st4
                    y_filtered4 = nanfastsmooth(Y3.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original   # By default work with size=50

                    # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE. *** The median filter function is used ***  PARA st5
                    y_filtered5 = nanfastsmooth(Y4.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original   # By default work with size=50


                    # Graph 4 - Envelope only graph.

                    fig, ax = plt.subplots() # To put several plot in same graphics.

                    ax.plot(dias[indices_no_cero_shannon], y_filtered[indices_no_cero_shannon], label='Filter Bandpass [ ' + str(frecMinB) + ' - ' + str(frecMaxB) + ' ] Hz.', color='darkblue')

                    ax.plot(dias[indices_no_cero_shannon], y_filtered2[indices_no_cero_shannon2], label='Filter Bandpass [ ' + str(frecMin2B) + ' - ' + str(frecMax2B) + ' ] Hz.', color='red')

                    ax.plot(dias[indices_no_cero_shannon], y_filtered3[indices_no_cero_shannon3], label='Filter Bandpass [ ' + str(frecMin3B) + ' - ' + str(frecMax3B) + ' ] Hz.', color='darkgreen')

                    ax.plot(dias[indices_no_cero_shannon], y_filtered4[indices_no_cero_shannon4], label='Filter Bandpass [ ' + str(frecMin4B) + ' - ' + str(frecMax4B) + ' ] Hz.', color='darkorange')

                    ax.plot(dias[indices_no_cero_shannon], y_filtered5[indices_no_cero_shannon5], label='Filter Bandpass [ ' + str(frecMin5B) + ' - ' + str(frecMax5B) + ' ] Hz.', color='darkgoldenrod')

                    plt.legend(prop = {'size': 10}, loc='upper right')          # Para colocar la leyenda a la izquierda
                    plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                    plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                    plt.title(Nombre3 + '_Envelope of Shannon entropy - Each point = 10 min. with Bandpass filter.' + " Envelope Windows = " + TM, color ="darkgreen", fontsize=12)

                    # Graphs with dots

                    fig, ax = plt.subplots() # To put several plot in same graphics.

                    ax.plot(dias[indices_no_cero_shannon], entropia_shannon[indices_no_cero_shannon], "o", mfc="darkblue", mec = "darkblue", label='Filter Bandpass [ ' + str(frecMinB) + ' - ' + str(frecMaxB) + ' ] Hz.', color='darkblue')

                    ax.plot(dias[indices_no_cero_shannon], entropia_shannon2[indices_no_cero_shannon2], "o", mfc="red", mec = "red", label='Filter Bandpass [ ' + str(frecMin2B) + ' - ' + str(frecMax2B) + ' ] Hz.', color='red')

                    ax.plot(dias[indices_no_cero_shannon], entropia_shannon3[indices_no_cero_shannon3], "o", mfc="darkgreen", mec = "darkgreen", label='Filter Bandpass [ ' + str(frecMin3B) + ' - ' + str(frecMax3B) + ' ] Hz.', color='darkgreen')

                    ax.plot(dias[indices_no_cero_shannon], entropia_shannon4[indices_no_cero_shannon4], "o", mfc="r", mec = "r", label='Filter Bandpass [ ' + str(frecMin4B) + ' - ' + str(frecMax4B) + ' ] Hz.', color='darkorange')

                    ax.plot(dias[indices_no_cero_shannon], entropia_shannon5[indices_no_cero_shannon5], "o", mfc="darkgoldenrod", mec = "darkgoldenrod", label='Filter Bandpass [ ' + str(frecMin5B) + ' - ' + str(frecMax5B) + ' ] Hz.', color='darkgoldenrod')

                    plt.legend(prop = {'size': 10}, loc='upper right')          # Para colocar la leyenda a la izquierda
                    plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                    plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                    plt.title(Nombre3 + '_Envelope of Shannon entropy - Each point = 10 min. with Bandpass filter.' + " Envelope Windows = " + TM , color ="darkgreen", fontsize=12)

                    plt.show()


            else:                                           # Here the value of the entropy is calculated without the time interval (Start - End)

                if not self.label_5.text():
                    MensCombo1 = QMessageBox()
                    MensCombo1.setIcon(QMessageBox.Warning)
                    MensCombo1.setWindowTitle("Empty directory to upload records")
                    MensCombo1.setText("Please, enter a valid name of directory")
                    returnValue = MensCombo1.exec()

                elif not self.lineEdit_4.text():
                    MensCombo3 = QMessageBox()
                    MensCombo3.setIcon(QMessageBox.Warning)
                    MensCombo3.setWindowTitle("Empty Filter Order")
                    MensCombo3.setText("Please, enter a valid Value")
                    returnValue = MensCombo3.exec()

                elif not self.lineEdit_10.text():
                    MensCombo6 = QMessageBox()
                    MensCombo6.setIcon(QMessageBox.Warning)
                    MensCombo6.setWindowTitle("Empty Min. Freq. Filter 1")
                    MensCombo6.setText("Please, enter a valid Value")
                    returnValue = MensCombo6.exec()

                elif not self.lineEdit_11.text():
                    MensCombo7 = QMessageBox()
                    MensCombo7.setIcon(QMessageBox.Warning)
                    MensCombo7.setWindowTitle("Empty Max. Freq. Filter 1")
                    MensCombo7.setText("Please, enter a valid Value")
                    returnValue = MensCombo7.exec()

                elif not self.lineEdit_12.text():
                    MensCombo8 = QMessageBox()
                    MensCombo8.setIcon(QMessageBox.Warning)
                    MensCombo8.setWindowTitle("Empty Min. Freq. Filter 2")
                    MensCombo8.setText("Please, enter a valid Value")
                    returnValue = MensCombo8.exec()

                elif not self.lineEdit_13.text():
                    MensCombo9 = QMessageBox()
                    MensCombo9.setIcon(QMessageBox.Warning)
                    MensCombo9.setWindowTitle("Empty Max. Freq. Filter 2")
                    MensCombo9.setText("Please, enter a valid Value")
                    returnValue = MensCombo9.exec()

                elif not self.lineEdit_14.text():
                    MensCombo10 = QMessageBox()
                    MensCombo10.setIcon(QMessageBox.Warning)
                    MensCombo10.setWindowTitle("Empty Min. Freq. Filter 3")
                    MensCombo10.setText("Please, enter a valid Value")
                    returnValue = MensCombo10.exec()

                elif not self.lineEdit_15.text():
                    MensCombo11 = QMessageBox()
                    MensCombo11.setIcon(QMessageBox.Warning)
                    MensCombo11.setWindowTitle("Empty Max. Freq. Filter 3")
                    MensCombo11.setText("Please, enter a valid Value")
                    returnValue = MensCombo11.exec()

                elif not self.lineEdit_16.text():
                    MensCombo12 = QMessageBox()
                    MensCombo12.setIcon(QMessageBox.Warning)
                    MensCombo12.setWindowTitle("Empty Min. Freq. Filter 4")
                    MensCombo12.setText("Please, enter a valid Value")
                    returnValue = MensCombo12.exec()

                elif not self.lineEdit_17.text():
                    MensCombo13 = QMessageBox()
                    MensCombo13.setIcon(QMessageBox.Warning)
                    MensCombo13.setWindowTitle("Empty Max. Freq. Filter 4")
                    MensCombo13.setText("Please, enter a valid Value")
                    returnValue = MensCombo13.exec()

                elif not self.lineEdit_18.text():
                    MensCombo14 = QMessageBox()
                    MensCombo14.setIcon(QMessageBox.Warning)
                    MensCombo14.setWindowTitle("Empty Min. Freq. Filter 5")
                    MensCombo14.setText("Please, enter a valid Value")
                    returnValue = MensCombo14.exec()

                elif not self.lineEdit_19.text():
                    MensCombo15 = QMessageBox()
                    MensCombo15.setIcon(QMessageBox.Warning)
                    MensCombo15.setWindowTitle("Empty Max. Freq. Filter 5")
                    MensCombo15.setText("Please, enter a valid Value")
                    returnValue = MensCombo15.exec()

                elif not self.lineEdit_20.text():
                    MensCombo16 = QMessageBox()
                    MensCombo16.setIcon(QMessageBox.Warning)
                    MensCombo16.setWindowTitle("Empty Envelope Window size")
                    MensCombo16.setText("Please, enter a valid Value")
                    returnValue = MensCombo16.exec()

                elif not self.lineEdit_21.text():
                    MensCombo17 = QMessageBox()
                    MensCombo17.setIcon(QMessageBox.Warning)
                    MensCombo17.setWindowTitle("Empty Smoothing type")
                    MensCombo17.setText("Please, enter a valid Value")
                    returnValue = MensCombo17.exec()

                elif not self.lineEdit_22.text():
                    MensCombo18 = QMessageBox()
                    MensCombo18.setIcon(QMessageBox.Warning)
                    MensCombo18.setWindowTitle("Empty NaN Tolerance")
                    MensCombo18.setText("Please, enter a valid Value")
                    returnValue = MensCombo18.exec()

                else:
                    # Filtering with a Bandpass.
                    plt.close()                                                 # Close the existing chart.

                    carpeta = (self.label_5.text())                             # Reading the directory or file folder label.

                    # Code to detect the contents of the folder and the files that the folder contains
                    with os.scandir(carpeta) as ficheros:
                        ficheros4 = [fichero.name for fichero in ficheros if fichero.is_file()]

                    # The contents of the files in "ficheros4" is a list. This code converts them to string
                    lfiles = [str(elemento) for elemento in ficheros4]

                    # Code used to determine the name of the files contained in the folder and to be used in the loading loop
                    Iniciolfiles = lfiles[0]                                    # Detects the numeric value of the "Start" in the name
                    Finlfiles = lfiles[-1]                                      # Detects the numerical value of the "End" in the name
                    Indice1 = Iniciolfiles.rfind('.')                           # Determines the index, which will be marked by the dot at the end for the extension
                    Nombre3 = Iniciolfiles[0:Indice1]                           # Indicates the name of the file in str (minus) the index or extension (each day)

                    # Data entry from labels and fields or text boxes (this value is a string by default)

                    frecMin = (self.lineEdit_10.text())                          # Minimum Frequency, Filter 1 label reading.
                    frecMax = (self.lineEdit_11.text())                          # Maximum Frequency, Filter 1 label reading.

                    frecMin2 = (self.lineEdit_12.text())                          # Minimum Frequency, Filter 2 label reading.
                    frecMax2 = (self.lineEdit_13.text())                          # Maximum Frequency, Filter 2 label reading.

                    frecMin3 = (self.lineEdit_14.text())                          # Minimum Frequency, Filter 3 label reading.
                    frecMax3 = (self.lineEdit_15.text())                          # Maximum Frequency, Filter 3 label reading.

                    frecMin4 = (self.lineEdit_16.text())                          # Minimum Frequency, Filter 4 label reading.
                    frecMax4 = (self.lineEdit_17.text())                          # Maximum Frequency, Filter 4 label reading.

                    frecMin5 = (self.lineEdit_18.text())                          # Minimum Frequency, Filter 5 label reading.
                    frecMax5 = (self.lineEdit_19.text())                          # Maximum Frequency, Filter 5 label reading.

                    orden1 = (self.lineEdit_4.text())                           # Reading the Filter Order Label.

                    # Data entry for enveloped (this value is a string by default)
                    Tam = (self.lineEdit_20.text())                             # Reading the envelope window size label.
                    Tsua = (self.lineEdit_21.text())                             # Reading the Smoothing type label.
                    Tnan = (self.lineEdit_22.text())                            # Reading the NaN Tolerance label.

                    # Convert the string value of the input text boxes to float or integer
                    frecMinB=float(frecMin)                                     # Converts Minimum Frequency, Filter 1 value to float.
                    frecMaxB=float(frecMax)                                     # Converts Maximum Frequency, Filter 1 value to float.

                    frecMin2B=float(frecMin2)                                   # Converts Minimum Frequency, Filter 2 value to float.
                    frecMax2B=float(frecMax2)                                   # Converts Maximum Frequency, Filter 2 value to float.

                    frecMin3B=float(frecMin3)                                   # Converts Minimum Frequency, Filter 3 value to float.
                    frecMax3B=float(frecMax3)                                   # Converts Maximum Frequency, Filter 3 value to float.

                    frecMin4B=float(frecMin4)                                   # Converts Minimum Frequency, Filter 4 value to float.
                    frecMax4B=float(frecMax4)                                   # Converts Maximum Frequency, Filter 4 value to float.

                    frecMin5B=float(frecMin5)                                   # Converts Minimum Frequency, Filter 5 value to float.
                    frecMax5B=float(frecMax5)                                   # Converts Maximum Frequency, Filter 5 value to float.

                    orden4=int(orden1)                                          # Converts filter order value to integer.

                    Tam1=int(Tam)                                               # Converts the envelope window size value to integer.
                    Tsua1=int(Tsua)                                             # Converts the Smoothing type value to integer.
                    Tnan1=int(Tnan)                                             # Converts the NaN Tolerance value to integer.

                    timeIn = 365

                    TM = str(Tam1)                                              # Coverts the windows size to string to put in plot label

                    # Function for Shannon entropy calculating
                    def calcular_entropia(datos):
                        params = stats.norm.fit(datos)
                        dist = stats.norm(*params)
                        probabilidades = dist.pdf(datos)
                        entropia = -np.sum(probabilidades * np.log2(probabilidades))
                        return entropia

                    # Function for Shannon entropy enveloped calculating
                    def nanfastsmooth(Y, w, type=1, tol=0.5):

                        """
                        Smooths vector Y with a moving average of width w, ignoring NaNs in data.

                        Parameters:
                        Y (numpy array): Input signal.
                        w (int): Window width.
                        type (int): Smooth type (1 for rectangular, 2 for triangular, 3 for pseudo-Gaussian).
                        tol (float): Tolerance to NaNs between 0 and 1.

                        Returns:
                        numpy array: Smoothed signal.
                        """
                        mask = ~np.isnan(Y)  # Create a boolean mask for non-NaN values
                        Y[mask] = nanfastsmooth_core(Y[mask], w, type, tol)  # Apply smoothing to non-NaN values
                        return Y

                    # Function for Shannon entropy enveloped type calculating. For default the value = 3
                    def nanfastsmooth_core(Y, w, type, tol):
                        if type == 1:
                            SmoothY = moving_average(Y, w)
                        elif type == 2:
                            SmoothY = moving_average(moving_average(Y, w), w)
                        elif type == 3:
                            SmoothY = moving_average(moving_average(moving_average(Y, w), w), w)

                        return SmoothY

                    def moving_average(Y, window_size):
                        return np.convolve(Y, np.ones(window_size)/window_size, mode='same')

                    def apply_bandpass_filter(datos, frecuencia_muestreo, freq_band):
                        nyquist = 0.5 * frecuencia_muestreo
                        normal_freq_band = np.array(freq_band) / nyquist
                        b, a = signal.butter(4, normal_freq_band, btype='band')
                        datos_filtrados = signal.filtfilt(b, a, datos)
                        return datos_filtrados

                    # Start entropy and averaged entropy values
                    entropia_shannon = []
                    entropia_promediada = []

                    entropia_shannon2 = []
                    entropia_promediada2 = []

                    entropia_shannon3 = []
                    entropia_promediada3 = []

                    entropia_shannon4 = []
                    entropia_promediada4 = []

                    entropia_shannon5 = []
                    entropia_promediada5 = []

                    # Cycle for the day-by-day calculation of the entropy in the files contained in the folder, using the time range (Start to End)
                    for dia in range(1, timeIn + 1):

                        archivo = Nombre3 + '.'+ f"{dia:003}"       # Here you select the name previously calculated plus point and the value of each Julian day

                        # If there is no file in the list, the entire day is added with a value of zero
                        if not os.path.exists(os.path.join(carpeta, archivo)):
                            for _ in range(24):  # AÃ±ade 24 horas con valor cero si no hay archivo
                                entropia_shannon.append(0)
                                entropia_promediada.append(0)
                            continue

                        elif not os.path.exists(os.path.join(carpeta, archivo)):
                            for _ in range(24):  # AÃ±ade 24 horas con valor cero si no hay archivo
                                entropia_shannon2.append(0)
                                entropia_promediada2.append(0)
                            continue

                        elif not os.path.exists(os.path.join(carpeta, archivo)):
                            for _ in range(24):  # AÃ±ade 24 horas con valor cero si no hay archivo
                                entropia_shannon3.append(0)
                                entropia_promediada3.append(0)
                            continue

                        elif not os.path.exists(os.path.join(carpeta, archivo)):
                            for _ in range(24):  # AÃ±ade 24 horas con valor cero si no hay archivo
                                entropia_shannon4.append(0)
                                entropia_promediada4.append(0)
                            continue

                        elif not os.path.exists(os.path.join(carpeta, archivo)):
                            for _ in range(24):  # AÃ±ade 24 horas con valor cero si no hay archivo
                                entropia_shannon5.append(0)
                                entropia_promediada5.append(0)
                            continue

                        # CreaciÃ³n de st para la lectura del fichero
                        st = Stream()
                        st += read(os.path.join(carpeta, archivo))

                        # CreaciÃ³n de st2 para la lectura del fichero
                        st2 = Stream()
                        st2 += read(os.path.join(carpeta, archivo))

                        # CreaciÃ³n de st3 para la lectura del fichero
                        st3 = Stream()
                        st3 += read(os.path.join(carpeta, archivo))

                        # CreaciÃ³n de st4 para la lectura del fichero
                        st4 = Stream()
                        st4 += read(os.path.join(carpeta, archivo))

                        # CreaciÃ³n de st5 para la lectura del fichero
                        st5 = Stream()
                        st5 += read(os.path.join(carpeta, archivo))

                        # calculation of the bandpass filter with the parameters indicated by the user.
                        st.filter('bandpass', freqmin=frecMinB, freqmax=frecMaxB, corners=4, zerophase=True)

                        st2.filter('bandpass', freqmin=frecMin2B, freqmax=frecMax2B, corners=4, zerophase=True)

                        st3.filter('bandpass', freqmin=frecMin3B, freqmax=frecMax3B, corners=4, zerophase=True)

                        st4.filter('bandpass', freqmin=frecMin4B, freqmax=frecMax4B, corners=4, zerophase=True)

                        st5.filter('bandpass', freqmin=frecMin5B, freqmax=frecMax5B, corners=4, zerophase=True)

                        # Datos para st
                        datos = st[0].data

                        # Datos2 para st2
                        datos2 = st2[0].data

                        # Datos3 para st3
                        datos3 = st3[0].data

                        # Datos4 para st4
                        datos4 = st4[0].data

                        # Datos5 para st5
                        datos5 = st5[0].data

                        # Dividir los datos en horas y calcular entropÃ­a para cada hora con st
                        for hora in range(24*6):
                            inicio = hora * 600 * 100  # inicio de la hora en segundos
                            fin = inicio + 600 * 100  # fin de la hora en segundos
                            #datos_hora = diff[inicio:fin]
                            datos_hora = datos[inicio:fin]

                            if len(datos_hora) < 600 * 100:  # Si la hora estÃ¡ incompleta, agregar ceros al final
                                datos_hora = np.append(datos_hora, np.zeros(600 * 100 - len(datos_hora)))

                            entropia_shannon.append(calcular_entropia(datos_hora))
                            entropia_promediada.append(calcular_entropia(datos_hora) / len(datos_hora))

                        # Dividir los datos en horas y calcular entropÃ­a para cada hora con st2
                        for hora in range(24*6):
                            inicio = hora * 600 * 100  # inicio de la hora en segundos
                            fin = inicio + 600 * 100  # fin de la hora en segundos
                            datos_hora2 = datos2[inicio:fin]

                            if len(datos_hora2) < 600 * 100:  # Si la hora estÃ¡ incompleta, agregar ceros al final
                                datos_hora2 = np.append(datos_hora2, np.zeros(600 * 100 - len(datos_hora2)))

                            entropia_shannon2.append(calcular_entropia(datos_hora2))
                            entropia_promediada2.append(calcular_entropia(datos_hora2) / len(datos_hora2))

                        # Dividir los datos en horas y calcular entropÃ­a para cada hora con st3
                        for hora in range(24*6):
                            inicio = hora * 600 * 100  # inicio de la hora en segundos
                            fin = inicio + 600 * 100  # fin de la hora en segundos
                            datos_hora3 = datos3[inicio:fin]

                            if len(datos_hora3) < 600 * 100:  # Si la hora estÃ¡ incompleta, agregar ceros al final
                                datos_hora3 = np.append(datos_hora3, np.zeros(600 * 100 - len(datos_hora3)))

                            entropia_shannon3.append(calcular_entropia(datos_hora3))
                            entropia_promediada3.append(calcular_entropia(datos_hora3) / len(datos_hora3))

                        # Dividir los datos en horas y calcular entropÃ­a para cada hora con st4
                        for hora in range(24*6):
                            inicio = hora * 600 * 100  # inicio de la hora en segundos
                            fin = inicio + 600 * 100  # fin de la hora en segundos
                            datos_hora4 = datos4[inicio:fin]

                            if len(datos_hora4) < 600 * 100:  # Si la hora estÃ¡ incompleta, agregar ceros al final
                                datos_hora4 = np.append(datos_hora4, np.zeros(600 * 100 - len(datos_hora4)))

                            entropia_shannon4.append(calcular_entropia(datos_hora4))
                            entropia_promediada4.append(calcular_entropia(datos_hora4) / len(datos_hora4))

                        # Dividir los datos en horas y calcular entropÃ­a para cada hora con st5
                        for hora in range(24*6):
                            inicio = hora * 600 * 100  # inicio de la hora en segundos
                            fin = inicio + 600 * 100  # fin de la hora en segundos
                            datos_hora5 = datos5[inicio:fin]

                            if len(datos_hora5) < 600 * 100:  # Si la hora estÃ¡ incompleta, agregar ceros al final
                                datos_hora5 = np.append(datos_hora5, np.zeros(600 * 100 - len(datos_hora5)))

                            entropia_shannon5.append(calcular_entropia(datos_hora5))
                            entropia_promediada5.append(calcular_entropia(datos_hora5) / len(datos_hora5))


                    # CreaciÃ³n del array de la entropia normal y la promediada de Shannon para st1
                    entropia_shannon = np.array(entropia_shannon)
                    entropia_promediada = np.array(entropia_promediada)

                    # CreaciÃ³n del array de la entropia normal y la promediada de Shannon para st2
                    entropia_shannon2 = np.array(entropia_shannon2)
                    entropia_promediada2 = np.array(entropia_promediada2)

                    # CreaciÃ³n del array de la entropia normal y la promediada de Shannon para st3
                    entropia_shannon3 = np.array(entropia_shannon3)
                    entropia_promediada3 = np.array(entropia_promediada3)

                    # CreaciÃ³n del array de la entropia normal y la promediada de Shannon para st4
                    entropia_shannon4 = np.array(entropia_shannon4)
                    entropia_promediada4 = np.array(entropia_promediada4)

                    # CreaciÃ³n del array de la entropia normal y la promediada de Shannon para st4
                    entropia_shannon5 = np.array(entropia_shannon5)
                    entropia_promediada5 = np.array(entropia_promediada5)

                    # Graficar los vectores en figuras separadas
                    dias = np.arange(1, 8761*6+1)

                    # GrÃ¡fico de EntropÃ­a de Shannon

                    indices_no_cero_shannon = np.where(entropia_shannon != 0)[0]
                    indices_no_cero_shannon2 = np.where(entropia_shannon2 != 0)[0]
                    indices_no_cero_shannon3 = np.where(entropia_shannon3 != 0)[0]
                    indices_no_cero_shannon4 = np.where(entropia_shannon4 != 0)[0]
                    indices_no_cero_shannon5 = np.where(entropia_shannon5 != 0)[0]

                    # Use example
                    Y = entropia_shannon
                    Y = np.where(Y == 0, np.nan, Y)

                    Y1 = entropia_shannon2
                    Y1 = np.where(Y1 == 0, np.nan, Y1)

                    Y2 = entropia_shannon3
                    Y2 = np.where(Y2 == 0, np.nan, Y2)

                    Y3 = entropia_shannon4
                    Y3 = np.where(Y3 == 0, np.nan, Y3)

                    Y4 = entropia_shannon5
                    Y4 = np.where(Y4 == 0, np.nan, Y4)

                    # Plot the vectors into separate figures.

                    # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE. *** The median filter function is used ***  PARA st1

                    y_filtered = nanfastsmooth(Y.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                    # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE. *** The median filter function is used ***  PARA st2
                    y_filtered2 = nanfastsmooth(Y1.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original   # By default work with size=50

                    # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE. *** The median filter function is used ***  PARA st3
                    y_filtered3 = nanfastsmooth(Y2.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original   # By default work with size=50

                    # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE. *** The median filter function is used ***  PARA st4
                    y_filtered4 = nanfastsmooth(Y3.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original   # By default work with size=50

                    # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE. *** The median filter function is used ***  PARA st5
                    y_filtered5 = nanfastsmooth(Y4.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original   # By default work with size=50


                    # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                    # Graph 4 - Envelope only graph.

                    fig, ax = plt.subplots() # To put several plot in same graphics.

                    ax.plot(dias[indices_no_cero_shannon], y_filtered[indices_no_cero_shannon], label='Filter Bandpass [ ' + str(frecMinB) + ' - ' + str(frecMaxB) + ' ] Hz.', color='darkblue')

                    ax.plot(dias[indices_no_cero_shannon], y_filtered2[indices_no_cero_shannon2], label='Filter Bandpass [ ' + str(frecMin2B) + ' - ' + str(frecMax2B) + ' ] Hz.', color='red')

                    ax.plot(dias[indices_no_cero_shannon], y_filtered3[indices_no_cero_shannon3], label='Filter Bandpass [ ' + str(frecMin3B) + ' - ' + str(frecMax3B) + ' ] Hz.', color='darkgreen')

                    ax.plot(dias[indices_no_cero_shannon], y_filtered4[indices_no_cero_shannon4], label='Filter Bandpass [ ' + str(frecMin4B) + ' - ' + str(frecMax4B) + ' ] Hz.', color='darkorange')

                    ax.plot(dias[indices_no_cero_shannon], y_filtered5[indices_no_cero_shannon5], label='Filter Bandpass [ ' + str(frecMin5B) + ' - ' + str(frecMax5B) + ' ] Hz.', color='darkgoldenrod')

                    plt.legend(prop = {'size': 10}, loc='upper right')          # Para colocar la leyenda a la izquierda
                    plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                    plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                    plt.title(Nombre3 + '_Envelope of Shannon entropy - Each point = 10 min. with Bandpass filter.' + " Envelope Windows = " + TM, color ="darkgreen", fontsize=12)

                    # Grahps with dots.

                    fig, ax = plt.subplots() # To put several plot in same graphics.

                    ax.plot(dias[indices_no_cero_shannon], entropia_shannon[indices_no_cero_shannon], "o", mfc="darkblue", mec = "darkblue", label='Filter Bandpass [ ' + str(frecMinB) + ' - ' + str(frecMaxB) + ' ] Hz.', color='darkblue')

                    ax.plot(dias[indices_no_cero_shannon], entropia_shannon2[indices_no_cero_shannon2], "o", mfc="red", mec = "red", label='Filter Bandpass [ ' + str(frecMin2B) + ' - ' + str(frecMax2B) + ' ] Hz.', color='red')

                    ax.plot(dias[indices_no_cero_shannon], entropia_shannon3[indices_no_cero_shannon3], "o", mfc="darkgreen", mec = "darkgreen", label='Filter Bandpass [ ' + str(frecMin3B) + ' - ' + str(frecMax3B) + ' ] Hz.', color='darkgreen')

                    ax.plot(dias[indices_no_cero_shannon], entropia_shannon4[indices_no_cero_shannon4], "o", mfc="r", mec = "r", label='Filter Bandpass [ ' + str(frecMin4B) + ' - ' + str(frecMax4B) + ' ] Hz.', color='darkorange')

                    ax.plot(dias[indices_no_cero_shannon], entropia_shannon5[indices_no_cero_shannon5], "o", mfc="darkgoldenrod", mec = "darkgoldenrod", label='Filter Bandpass [ ' + str(frecMin5B) + ' - ' + str(frecMax5B) + ' ] Hz.', color='darkgoldenrod')

                    plt.legend(prop = {'size': 10}, loc='upper right')          # Para colocar la leyenda a la izquierda
                    plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                    plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                    plt.title(Nombre3 + '_Envelope of Shannon entropy - Each point = 10 min. with Bandpass filter.' + " Envelope Windows = " + TM  , color ="darkgreen", fontsize=12)

                    plt.show()


        except:                         # In any other case of invalid or empty inputs
                plt.close()                                                 # Close the existing chart.
                msgBox = QMessageBox()
                msgBox.setIcon(QMessageBox.Warning)
                msgBox.setText("The File Does not exist, is Invalid or the Format is not recognized. Please, try again ... ...")
                msgBox.setWindowTitle("Invalid input parameter or registry file")
                returnValue = msgBox.exec()
                pass


    def filtrobandstop(self):                                           # 4.- Function to execute the Bandstop filter with 1 hr. analysis window.

        try:

            # Verifying that the checkbox is true. Work with time intervals.

            if self.checkBox.isChecked() == True:

                # Verify (Validation), that the text box and label is not empty.

                if not self.label_5.text():
                    MensCombo1 = QMessageBox()
                    MensCombo1.setIcon(QMessageBox.Warning)
                    MensCombo1.setWindowTitle("Empty directory to upload records")
                    MensCombo1.setText("Please, enter a valid name of directory")
                    returnValue = MensCombo1.exec()

                elif not self.lineEdit_2.text():
                    MensCombo3 = QMessageBox()
                    MensCombo3.setIcon(QMessageBox.Warning)
                    MensCombo3.setWindowTitle("Empty Start time")
                    MensCombo3.setText("Please, enter a valid Value")
                    returnValue = MensCombo3.exec()

                elif not self.lineEdit_3.text():
                    MensCombo4 = QMessageBox()
                    MensCombo4.setIcon(QMessageBox.Warning)
                    MensCombo4.setWindowTitle("Empty End time")
                    MensCombo4.setText("Please, enter a valid Value")
                    returnValue = MensCombo4.exec()

                elif not self.lineEdit_4.text():
                    MensCombo5 = QMessageBox()
                    MensCombo5.setIcon(QMessageBox.Warning)
                    MensCombo5.setWindowTitle("Empty Filter Order")
                    MensCombo5.setText("Please, enter a valid Value")
                    returnValue = MensCombo5.exec()

                elif not self.lineEdit_10.text():
                    MensCombo6 = QMessageBox()
                    MensCombo6.setIcon(QMessageBox.Warning)
                    MensCombo6.setWindowTitle("Empty Min. Freq. Filter 1")
                    MensCombo6.setText("Please, enter a valid Value")
                    returnValue = MensCombo6.exec()

                elif not self.lineEdit_11.text():
                    MensCombo7 = QMessageBox()
                    MensCombo7.setIcon(QMessageBox.Warning)
                    MensCombo7.setWindowTitle("Empty Max. Freq. Filter 1")
                    MensCombo7.setText("Please, enter a valid Value")
                    returnValue = MensCombo7.exec()

                elif not self.lineEdit_12.text():
                    MensCombo8 = QMessageBox()
                    MensCombo8.setIcon(QMessageBox.Warning)
                    MensCombo8.setWindowTitle("Empty Min. Freq. Filter 2")
                    MensCombo8.setText("Please, enter a valid Value")
                    returnValue = MensCombo8.exec()

                elif not self.lineEdit_13.text():
                    MensCombo9 = QMessageBox()
                    MensCombo9.setIcon(QMessageBox.Warning)
                    MensCombo9.setWindowTitle("Empty Max. Freq. Filter 2")
                    MensCombo9.setText("Please, enter a valid Value")
                    returnValue = MensCombo9.exec()

                elif not self.lineEdit_14.text():
                    MensCombo10 = QMessageBox()
                    MensCombo10.setIcon(QMessageBox.Warning)
                    MensCombo10.setWindowTitle("Empty Min. Freq. Filter 3")
                    MensCombo10.setText("Please, enter a valid Value")
                    returnValue = MensCombo10.exec()

                elif not self.lineEdit_15.text():
                    MensCombo11 = QMessageBox()
                    MensCombo11.setIcon(QMessageBox.Warning)
                    MensCombo11.setWindowTitle("Empty Max. Freq. Filter 3")
                    MensCombo11.setText("Please, enter a valid Value")
                    returnValue = MensCombo11.exec()

                elif not self.lineEdit_16.text():
                    MensCombo12 = QMessageBox()
                    MensCombo12.setIcon(QMessageBox.Warning)
                    MensCombo12.setWindowTitle("Empty Min. Freq. Filter 4")
                    MensCombo12.setText("Please, enter a valid Value")
                    returnValue = MensCombo12.exec()

                elif not self.lineEdit_17.text():
                    MensCombo13 = QMessageBox()
                    MensCombo13.setIcon(QMessageBox.Warning)
                    MensCombo13.setWindowTitle("Empty Max. Freq. Filter 4")
                    MensCombo13.setText("Please, enter a valid Value")
                    returnValue = MensCombo13.exec()

                elif not self.lineEdit_18.text():
                    MensCombo14 = QMessageBox()
                    MensCombo14.setIcon(QMessageBox.Warning)
                    MensCombo14.setWindowTitle("Empty Min. Freq. Filter 5")
                    MensCombo14.setText("Please, enter a valid Value")
                    returnValue = MensCombo14.exec()

                elif not self.lineEdit_19.text():
                    MensCombo15 = QMessageBox()
                    MensCombo15.setIcon(QMessageBox.Warning)
                    MensCombo15.setWindowTitle("Empty Max. Freq. Filter 5")
                    MensCombo15.setText("Please, enter a valid Value")
                    returnValue = MensCombo15.exec()

                elif not self.lineEdit_20.text():
                    MensCombo16 = QMessageBox()
                    MensCombo16.setIcon(QMessageBox.Warning)
                    MensCombo16.setWindowTitle("Empty Envelope Window size")
                    MensCombo16.setText("Please, enter a valid Value")
                    returnValue = MensCombo16.exec()

                elif not self.lineEdit_21.text():
                    MensCombo17 = QMessageBox()
                    MensCombo17.setIcon(QMessageBox.Warning)
                    MensCombo17.setWindowTitle("Empty Smoothing type")
                    MensCombo17.setText("Please, enter a valid Value")
                    returnValue = MensCombo17.exec()

                elif not self.lineEdit_22.text():
                    MensCombo18 = QMessageBox()
                    MensCombo18.setIcon(QMessageBox.Warning)
                    MensCombo18.setWindowTitle("Empty NaN Tolerance")
                    MensCombo18.setText("Please, enter a valid Value")
                    returnValue = MensCombo18.exec()

                else:
                    # Filtering with a Bandstop.

                    plt.close()                                                 # Close the existing chart.

                    carpeta = (self.label_5.text())                             # Reading the directory or file folder label.

                    # Code to detect the contents of the folder and the files that the folder contains
                    with os.scandir(carpeta) as ficheros:
                        ficheros4 = [fichero.name for fichero in ficheros if fichero.is_file()]

                    # The contents of the files in "ficheros4" is a list. This code converts them to string
                    lfiles = [str(elemento) for elemento in ficheros4]

                    # Code used to determine the name of the files contained in the folder and to be used in the loading loop
                    Iniciolfiles = lfiles[0]                                    # Detects the numeric value of the "Start" in the name
                    Finlfiles = lfiles[-1]                                      # Detects the numerical value of the "End" in the name
                    Indice1 = Iniciolfiles.rfind('.')                           # Determines the index, which will be marked by the dot at the end for the extension
                    Nombre3 = Iniciolfiles[0:Indice1]                           # Indicates the name of the file in str (minus) the index or extension (each day)

                    # Data entry from labels and fields or text boxes (this value is a string by default)

                    frecMin = (self.lineEdit_10.text())                          # Minimum Frequency, Filter 1 label reading.
                    frecMax = (self.lineEdit_11.text())                          # Maximum Frequency, Filter 1 label reading.

                    frecMin2 = (self.lineEdit_12.text())                          # Minimum Frequency, Filter 2 label reading.
                    frecMax2 = (self.lineEdit_13.text())                          # Maximum Frequency, Filter 2 label reading.

                    frecMin3 = (self.lineEdit_14.text())                          # Minimum Frequency, Filter 3 label reading.
                    frecMax3 = (self.lineEdit_15.text())                          # Maximum Frequency, Filter 3 label reading.

                    frecMin4 = (self.lineEdit_16.text())                          # Minimum Frequency, Filter 4 label reading.
                    frecMax4 = (self.lineEdit_17.text())                          # Maximum Frequency, Filter 4 label reading.

                    frecMin5 = (self.lineEdit_18.text())                          # Minimum Frequency, Filter 5 label reading.
                    frecMax5 = (self.lineEdit_19.text())                          # Maximum Frequency, Filter 5 label reading.

                    orden1 = (self.lineEdit_4.text())                           # Reading the Filter Order Label.

                    # Data entry for enveloped (this value is a string by default)
                    Tam = (self.lineEdit_20.text())                             # Reading the envelope window size label.
                    Tsua = (self.lineEdit_21.text())                            # Reading the Smoothing type label.
                    Tnan = (self.lineEdit_22.text())                            # Reading the NaN Tolerance label.

                    Start1 = (self.lineEdit_2.text())                           # Star Time Size label reading.
                    End1 = (self.lineEdit_3.text())                             # End Time Size label reading.

                    # Convert the string value of the input text boxes to float or integer
                    frecMinB=float(frecMin)                                     # Converts Minimum Frequency, Filter 1 value to float.
                    frecMaxB=float(frecMax)                                     # Converts Maximum Frequency, Filter 1 value to float.

                    frecMin2B=float(frecMin2)                                   # Converts Minimum Frequency, Filter 2 value to float.
                    frecMax2B=float(frecMax2)                                   # Converts Maximum Frequency, Filter 2 value to float.

                    frecMin3B=float(frecMin3)                                   # Converts Minimum Frequency, Filter 3 value to float.
                    frecMax3B=float(frecMax3)                                   # Converts Maximum Frequency, Filter 3 value to float.

                    frecMin4B=float(frecMin4)                                   # Converts Minimum Frequency, Filter 4 value to float.
                    frecMax4B=float(frecMax4)                                   # Converts Maximum Frequency, Filter 4 value to float.

                    frecMin5B=float(frecMin5)                                   # Converts Minimum Frequency, Filter 5 value to float.
                    frecMax5B=float(frecMax5)                                   # Converts Maximum Frequency, Filter 5 value to float.

                    orden4=int(orden1)                                          # Converts filter order value to integer.

                    Tam1=int(Tam)                                               # Converts the envelope window size value to integer.
                    Tsua1=int(Tsua)                                             # Converts the Smoothing type value to integer.
                    Tnan1=int(Tnan)                                             # Converts the NaN Tolerance value to integer.

                    timeIn = 365

                    Start2=int(Start1)                                          # Converts the Start time window size value to an integer.
                    End2=int(End1)                                              # Converts the End time window size value to an integer.

                    Diferencia = End2 - Start2                                  # Value of the difference between end and start to obtain the number of days to calculate

                    TM = str(Tam1)                                              # Coverts the windows size to string to put in plot label

                    Start2=int(Start1)                                          # Converts the Start time window size value to an integer.
                    End2=int(End1)                                              # Converts the End time window size value to an integer.

                    # Function for Shannon entropy calculating
                    def calcular_entropia(datos):
                        params = stats.norm.fit(datos)
                        dist = stats.norm(*params)
                        probabilidades = dist.pdf(datos)
                        entropia = -np.sum(probabilidades * np.log2(probabilidades))
                        return entropia

                    # Function for Shannon entropy enveloped calculating
                    def nanfastsmooth(Y, w, type=1, tol=0.5):

                        """
                        Smooths vector Y with a moving average of width w, ignoring NaNs in data.

                        Parameters:
                        Y (numpy array): Input signal.
                        w (int): Window width.
                        type (int): Smooth type (1 for rectangular, 2 for triangular, 3 for pseudo-Gaussian).
                        tol (float): Tolerance to NaNs between 0 and 1.

                        Returns:
                        numpy array: Smoothed signal.
                        """
                        mask = ~np.isnan(Y)  # Create a boolean mask for non-NaN values
                        Y[mask] = nanfastsmooth_core(Y[mask], w, type, tol)  # Apply smoothing to non-NaN values
                        return Y

                    # Function for Shannon entropy enveloped type calculating. For default the value = 3
                    def nanfastsmooth_core(Y, w, type, tol):
                        if type == 1:
                            SmoothY = moving_average(Y, w)
                        elif type == 2:
                            SmoothY = moving_average(moving_average(Y, w), w)
                        elif type == 3:
                            SmoothY = moving_average(moving_average(moving_average(Y, w), w), w)

                        return SmoothY

                    def moving_average(Y, window_size):
                        return np.convolve(Y, np.ones(window_size)/window_size, mode='same')

                    def apply_bandpass_filter(datos, frecuencia_muestreo, freq_band):
                        nyquist = 0.5 * frecuencia_muestreo
                        normal_freq_band = np.array(freq_band) / nyquist
                        b, a = signal.butter(4, normal_freq_band, btype='band')
                        datos_filtrados = signal.filtfilt(b, a, datos)
                        return datos_filtrados

                    # Start entropy and averaged entropy values
                    entropia_shannon = []
                    entropia_promediada = []

                    entropia_shannon2 = []
                    entropia_promediada2 = []

                    entropia_shannon3 = []
                    entropia_promediada3 = []

                    entropia_shannon4 = []
                    entropia_promediada4 = []

                    entropia_shannon5 = []
                    entropia_promediada5 = []

                    # Cycle for the day-by-day calculation of the entropy in the files contained in the folder, using the time range (Start to End)
                    for dia in range(Start2, End2 + 1):

                        archivo = Nombre3 + '.'+ f"{dia:003}"       # Here you select the name previously calculated plus point and the value of each Julian day

                        # If there is no file in the list, the entire day is added with a value of zero
                        if not os.path.exists(os.path.join(carpeta, archivo)):
                            for _ in range(24):  # Adds 24 hours with zero value if there is no file
                                entropia_shannon.append(0)
                                entropia_promediada.append(0)
                            continue

                        elif not os.path.exists(os.path.join(carpeta, archivo)):
                            for _ in range(24):  # AÃ±ade 24 horas con valor cero si no hay archivo
                                entropia_shannon2.append(0)
                                entropia_promediada2.append(0)
                            continue

                        elif not os.path.exists(os.path.join(carpeta, archivo)):
                            for _ in range(24):  # AÃ±ade 24 horas con valor cero si no hay archivo
                                entropia_shannon3.append(0)
                                entropia_promediada3.append(0)
                            continue

                        elif not os.path.exists(os.path.join(carpeta, archivo)):
                            for _ in range(24):  # AÃ±ade 24 horas con valor cero si no hay archivo
                                entropia_shannon4.append(0)
                                entropia_promediada4.append(0)
                            continue

                        elif not os.path.exists(os.path.join(carpeta, archivo)):
                            for _ in range(24):  # AÃ±ade 24 horas con valor cero si no hay archivo
                                entropia_shannon5.append(0)
                                entropia_promediada5.append(0)
                            continue

                        # CreaciÃ³n de st para la lectura del fichero
                        st = Stream()
                        st += read(os.path.join(carpeta, archivo))

                        # CreaciÃ³n de st2 para la lectura del fichero
                        st2 = Stream()
                        st2 += read(os.path.join(carpeta, archivo))

                        # CreaciÃ³n de st3 para la lectura del fichero
                        st3 = Stream()
                        st3 += read(os.path.join(carpeta, archivo))

                        # CreaciÃ³n de st4 para la lectura del fichero
                        st4 = Stream()
                        st4 += read(os.path.join(carpeta, archivo))

                        # CreaciÃ³n de st5 para la lectura del fichero
                        st5 = Stream()
                        st5 += read(os.path.join(carpeta, archivo))

                        # calculation of the bandstop filter with the parameters indicated by the user.

                        st.filter('bandstop', freqmin=frecMinB, freqmax=frecMaxB, corners=4, zerophase=True)

                        st2.filter('bandstop', freqmin=frecMin2B, freqmax=frecMax2B, corners=4, zerophase=True)

                        st3.filter('bandstop', freqmin=frecMin3B, freqmax=frecMax3B, corners=4, zerophase=True)

                        st4.filter('bandstop', freqmin=frecMin4B, freqmax=frecMax4B, corners=4, zerophase=True)

                        st5.filter('bandstop', freqmin=frecMin5B, freqmax=frecMax5B, corners=4, zerophase=True)

                        # Datos para st
                        datos = st[0].data
                        #diff = datos[1:] - datos[0:-1]

                        # Datos2 para st2
                        datos2 = st2[0].data
                        #diff2 = datos2[1:] - datos2[0:-1]

                        # Datos3 para st3
                        datos3 = st3[0].data
                        #diff3 = datos3[1:] - datos3[0:-1]

                        # Datos4 para st4
                        datos4 = st4[0].data
                        #diff4 = datos4[1:] - datos4[0:-1]

                        # Datos5 para st5
                        datos5 = st5[0].data
                        #diff5 = datos5[1:] - datos5[0:-1]

                        # Divide the data into hours and calculate entropy for each hour.

                        # CreaciÃ³n de las entropias en base a los datos con st
                        for hora in range(24*6):
                            inicio = hora * 600 * 100  # start of time in seconds.
                            fin = inicio + 600 * 100  # End of time in seconds.
                            datos_hora = datos[inicio:fin]

                            if len(datos_hora) < 600 * 100:  # If the hour is incomplete, add zeros to the end.
                                datos_hora = np.append(datos_hora, np.zeros(600 * 100 - len(datos_hora)))

                            # Accumulator of the calculated values of the Shannon entropy and the averaged entropy.
                            entropia_shannon.append(calcular_entropia(datos_hora))
                            entropia_promediada.append(calcular_entropia(datos_hora) / len(datos_hora))

                        # Dividir los datos en horas y calcular entropÃ­a para cada hora con st2
                        for hora in range(24*6):
                            inicio = hora * 600 * 100  # inicio de la hora en segundos
                            fin = inicio + 600 * 100  # fin de la hora en segundos
                            datos_hora2 = datos2[inicio:fin]

                            if len(datos_hora2) < 600 * 100:  # Si la hora estÃ¡ incompleta, agregar ceros al final
                                datos_hora2 = np.append(datos_hora2, np.zeros(600 * 100 - len(datos_hora2)))

                            entropia_shannon2.append(calcular_entropia(datos_hora2))
                            entropia_promediada2.append(calcular_entropia(datos_hora2) / len(datos_hora2))

                        # Dividir los datos en horas y calcular entropÃ­a para cada hora con st3
                        for hora in range(24*6):
                            inicio = hora * 600 * 100  # inicio de la hora en segundos
                            fin = inicio + 600 * 100  # fin de la hora en segundos
                            datos_hora3 = datos3[inicio:fin]

                            if len(datos_hora3) < 600 * 100:  # Si la hora estÃ¡ incompleta, agregar ceros al final
                                datos_hora3 = np.append(datos_hora3, np.zeros(600 * 100 - len(datos_hora3)))

                            entropia_shannon3.append(calcular_entropia(datos_hora3))
                            entropia_promediada3.append(calcular_entropia(datos_hora3) / len(datos_hora3))

                        # Dividir los datos en horas y calcular entropÃ­a para cada hora con st4
                        for hora in range(24*6):
                            inicio = hora * 600 * 100  # inicio de la hora en segundos
                            fin = inicio + 600 * 100  # fin de la hora en segundos
                            datos_hora4 = datos4[inicio:fin]

                            if len(datos_hora4) < 600 * 100:  # Si la hora estÃ¡ incompleta, agregar ceros al final
                                datos_hora4 = np.append(datos_hora4, np.zeros(600 * 100 - len(datos_hora4)))

                            entropia_shannon4.append(calcular_entropia(datos_hora4))
                            entropia_promediada4.append(calcular_entropia(datos_hora4) / len(datos_hora4))

                        # Dividir los datos en horas y calcular entropÃ­a para cada hora con st5
                        for hora in range(24*6):
                            inicio = hora * 600 * 100  # inicio de la hora en segundos
                            fin = inicio + 600 * 100  # fin de la hora en segundos
                            datos_hora5 = datos5[inicio:fin]

                            if len(datos_hora5) < 600 * 100:  # Si la hora estÃ¡ incompleta, agregar ceros al final
                                datos_hora5 = np.append(datos_hora5, np.zeros(600 * 100 - len(datos_hora5)))

                            entropia_shannon5.append(calcular_entropia(datos_hora5))
                            entropia_promediada5.append(calcular_entropia(datos_hora5) / len(datos_hora5))

                    # CreaciÃ³n del array de la entropia normal y la promediada de Shannon para st1
                    entropia_shannon = np.array(entropia_shannon)
                    entropia_promediada = np.array(entropia_promediada)

                    # CreaciÃ³n del array de la entropia normal y la promediada de Shannon para st2
                    entropia_shannon2 = np.array(entropia_shannon2)
                    entropia_promediada2 = np.array(entropia_promediada2)

                    # CreaciÃ³n del array de la entropia normal y la promediada de Shannon para st3
                    entropia_shannon3 = np.array(entropia_shannon3)
                    entropia_promediada3 = np.array(entropia_promediada3)

                    # CreaciÃ³n del array de la entropia normal y la promediada de Shannon para st4
                    entropia_shannon4 = np.array(entropia_shannon4)
                    entropia_promediada4 = np.array(entropia_promediada4)

                    # CreaciÃ³n del array de la entropia normal y la promediada de Shannon para st4
                    entropia_shannon5 = np.array(entropia_shannon5)
                    entropia_promediada5 = np.array(entropia_promediada5)

                    # Shannon Entropy Graph. Value of non-zero indices where there is no data.
                    indices_no_cero_shannon = np.where(entropia_shannon != 0)[0]
                    indices_no_cero_shannon2 = np.where(entropia_shannon2 != 0)[0]
                    indices_no_cero_shannon3 = np.where(entropia_shannon3 != 0)[0]
                    indices_no_cero_shannon4 = np.where(entropia_shannon4 != 0)[0]
                    indices_no_cero_shannon5 = np.where(entropia_shannon5 != 0)[0]

                    # Use example
                    Y = entropia_shannon
                    Y = np.where(Y == 0, np.nan, Y)

                    Y1 = entropia_shannon2
                    Y1 = np.where(Y1 == 0, np.nan, Y1)

                    Y2 = entropia_shannon3
                    Y2 = np.where(Y2 == 0, np.nan, Y2)

                    Y3 = entropia_shannon4
                    Y3 = np.where(Y3 == 0, np.nan, Y3)

                    Y4 = entropia_shannon5
                    Y4 = np.where(Y4 == 0, np.nan, Y4)

                    # Plot the vectors into separate figures.

                    dias = np.arange(1, 8761*6+1)


                    # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE. *** The median filter function is used ***  PARA st1

                    y_filtered = nanfastsmooth(Y.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                    # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE. *** The median filter function is used ***  PARA st2
                    y_filtered2 = nanfastsmooth(Y1.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original   # By default work with size=50

                    # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE. *** The median filter function is used ***  PARA st3
                    y_filtered3 = nanfastsmooth(Y2.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original   # By default work with size=50

                    # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE. *** The median filter function is used ***  PARA st4
                    y_filtered4 = nanfastsmooth(Y3.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original   # By default work with size=50

                    # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE. *** The median filter function is used ***  PARA st5
                    y_filtered5 = nanfastsmooth(Y4.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original   # By default work with size=50


                    # Graph 4 - Envelope only graph.

                    fig, ax = plt.subplots() # To put several plot in same graphics.

                    ax.plot(dias[indices_no_cero_shannon], y_filtered[indices_no_cero_shannon], label='Filter Bandstop [ ' + str(frecMinB) + ' - ' + str(frecMaxB) + ' ] Hz.', color='darkblue')

                    ax.plot(dias[indices_no_cero_shannon], y_filtered2[indices_no_cero_shannon2], label='Filter Bandstop [ ' + str(frecMin2B) + ' - ' + str(frecMax2B) + ' ] Hz.', color='red')

                    ax.plot(dias[indices_no_cero_shannon], y_filtered3[indices_no_cero_shannon3], label='Filter Bandstop [ ' + str(frecMin3B) + ' - ' + str(frecMax3B) + ' ] Hz.', color='darkgreen')

                    ax.plot(dias[indices_no_cero_shannon], y_filtered4[indices_no_cero_shannon4], label='Filter Bandstop [ ' + str(frecMin4B) + ' - ' + str(frecMax4B) + ' ] Hz.', color='darkorange')

                    ax.plot(dias[indices_no_cero_shannon], y_filtered5[indices_no_cero_shannon5], label='Filter Bandstop [ ' + str(frecMin5B) + ' - ' + str(frecMax5B) + ' ] Hz.', color='darkgoldenrod')

                    plt.legend(prop = {'size': 10}, loc='upper right')          # Para colocar la leyenda a la izquierda
                    plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                    plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                    plt.title(Nombre3 + '_Envelope of Shannon entropy - Each point = 10 min. with Bandstop filter.' + " Envelope Windows = " + TM, color ="darkgreen", fontsize=12)

                    # Graphs with dots

                    fig, ax = plt.subplots() # To put several plot in same graphics.

                    ax.plot(dias[indices_no_cero_shannon], entropia_shannon[indices_no_cero_shannon], "o", mfc="darkblue", mec = "darkblue", label='Filter Bandstop [ ' + str(frecMinB) + ' - ' + str(frecMaxB) + ' ] Hz.', color='darkblue')

                    ax.plot(dias[indices_no_cero_shannon], entropia_shannon2[indices_no_cero_shannon2], "o", mfc="red", mec = "red", label='Filter Bandstop [ ' + str(frecMin2B) + ' - ' + str(frecMax2B) + ' ] Hz.', color='red')

                    ax.plot(dias[indices_no_cero_shannon], entropia_shannon3[indices_no_cero_shannon3], "o", mfc="darkgreen", mec = "darkgreen", label='Filter Bandstop [ ' + str(frecMin3B) + ' - ' + str(frecMax3B) + ' ] Hz.', color='darkgreen')

                    ax.plot(dias[indices_no_cero_shannon], entropia_shannon4[indices_no_cero_shannon4], "o", mfc="r", mec = "r", label='Filter Bandstop [ ' + str(frecMin4B) + ' - ' + str(frecMax4B) + ' ] Hz.', color='darkorange')

                    ax.plot(dias[indices_no_cero_shannon], entropia_shannon5[indices_no_cero_shannon5], "o", mfc="darkgoldenrod", mec = "darkgoldenrod", label='Filter Bandstop [ ' + str(frecMin5B) + ' - ' + str(frecMax5B) + ' ] Hz.', color='darkgoldenrod')

                    plt.legend(prop = {'size': 10}, loc='upper right')          # Para colocar la leyenda a la izquierda
                    plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                    plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                    plt.title(Nombre3 + '_Envelope of Shannon entropy - Each point = 10 min. with Bandstop filter.' + " Envelope Windows = " + TM , color ="darkgreen", fontsize=12)

                    plt.show()


            else:                                           # Here the value of the entropy is calculated without the time interval (Start - End)

                if not self.label_5.text():
                    MensCombo1 = QMessageBox()
                    MensCombo1.setIcon(QMessageBox.Warning)
                    MensCombo1.setWindowTitle("Empty directory to upload records")
                    MensCombo1.setText("Please, enter a valid name of directory")
                    returnValue = MensCombo1.exec()

                elif not self.lineEdit_4.text():
                    MensCombo3 = QMessageBox()
                    MensCombo3.setIcon(QMessageBox.Warning)
                    MensCombo3.setWindowTitle("Empty Filter Order")
                    MensCombo3.setText("Please, enter a valid Value")
                    returnValue = MensCombo3.exec()

                elif not self.lineEdit_10.text():
                    MensCombo6 = QMessageBox()
                    MensCombo6.setIcon(QMessageBox.Warning)
                    MensCombo6.setWindowTitle("Empty Min. Freq. Filter 1")
                    MensCombo6.setText("Please, enter a valid Value")
                    returnValue = MensCombo6.exec()

                elif not self.lineEdit_11.text():
                    MensCombo7 = QMessageBox()
                    MensCombo7.setIcon(QMessageBox.Warning)
                    MensCombo7.setWindowTitle("Empty Max. Freq. Filter 1")
                    MensCombo7.setText("Please, enter a valid Value")
                    returnValue = MensCombo7.exec()

                elif not self.lineEdit_12.text():
                    MensCombo8 = QMessageBox()
                    MensCombo8.setIcon(QMessageBox.Warning)
                    MensCombo8.setWindowTitle("Empty Min. Freq. Filter 2")
                    MensCombo8.setText("Please, enter a valid Value")
                    returnValue = MensCombo8.exec()

                elif not self.lineEdit_13.text():
                    MensCombo9 = QMessageBox()
                    MensCombo9.setIcon(QMessageBox.Warning)
                    MensCombo9.setWindowTitle("Empty Max. Freq. Filter 2")
                    MensCombo9.setText("Please, enter a valid Value")
                    returnValue = MensCombo9.exec()

                elif not self.lineEdit_14.text():
                    MensCombo10 = QMessageBox()
                    MensCombo10.setIcon(QMessageBox.Warning)
                    MensCombo10.setWindowTitle("Empty Min. Freq. Filter 3")
                    MensCombo10.setText("Please, enter a valid Value")
                    returnValue = MensCombo10.exec()

                elif not self.lineEdit_15.text():
                    MensCombo11 = QMessageBox()
                    MensCombo11.setIcon(QMessageBox.Warning)
                    MensCombo11.setWindowTitle("Empty Max. Freq. Filter 3")
                    MensCombo11.setText("Please, enter a valid Value")
                    returnValue = MensCombo11.exec()

                elif not self.lineEdit_16.text():
                    MensCombo12 = QMessageBox()
                    MensCombo12.setIcon(QMessageBox.Warning)
                    MensCombo12.setWindowTitle("Empty Min. Freq. Filter 4")
                    MensCombo12.setText("Please, enter a valid Value")
                    returnValue = MensCombo12.exec()

                elif not self.lineEdit_17.text():
                    MensCombo13 = QMessageBox()
                    MensCombo13.setIcon(QMessageBox.Warning)
                    MensCombo13.setWindowTitle("Empty Max. Freq. Filter 4")
                    MensCombo13.setText("Please, enter a valid Value")
                    returnValue = MensCombo13.exec()

                elif not self.lineEdit_18.text():
                    MensCombo14 = QMessageBox()
                    MensCombo14.setIcon(QMessageBox.Warning)
                    MensCombo14.setWindowTitle("Empty Min. Freq. Filter 5")
                    MensCombo14.setText("Please, enter a valid Value")
                    returnValue = MensCombo14.exec()

                elif not self.lineEdit_19.text():
                    MensCombo15 = QMessageBox()
                    MensCombo15.setIcon(QMessageBox.Warning)
                    MensCombo15.setWindowTitle("Empty Max. Freq. Filter 5")
                    MensCombo15.setText("Please, enter a valid Value")
                    returnValue = MensCombo15.exec()

                elif not self.lineEdit_20.text():
                    MensCombo16 = QMessageBox()
                    MensCombo16.setIcon(QMessageBox.Warning)
                    MensCombo16.setWindowTitle("Empty Envelope Window size")
                    MensCombo16.setText("Please, enter a valid Value")
                    returnValue = MensCombo16.exec()

                elif not self.lineEdit_21.text():
                    MensCombo17 = QMessageBox()
                    MensCombo17.setIcon(QMessageBox.Warning)
                    MensCombo17.setWindowTitle("Empty Smoothing type")
                    MensCombo17.setText("Please, enter a valid Value")
                    returnValue = MensCombo17.exec()

                elif not self.lineEdit_22.text():
                    MensCombo18 = QMessageBox()
                    MensCombo18.setIcon(QMessageBox.Warning)
                    MensCombo18.setWindowTitle("Empty NaN Tolerance")
                    MensCombo18.setText("Please, enter a valid Value")
                    returnValue = MensCombo18.exec()

                else:
                    # Filtering with a Bandstop.

                    plt.close()                                                 # Close the existing chart.

                    carpeta = (self.label_5.text())                             # Reading the directory or file folder label.

                    # Code to detect the contents of the folder and the files that the folder contains
                    with os.scandir(carpeta) as ficheros:
                        ficheros4 = [fichero.name for fichero in ficheros if fichero.is_file()]

                    # The contents of the files in "ficheros4" is a list. This code converts them to string
                    lfiles = [str(elemento) for elemento in ficheros4]

                    # Code used to determine the name of the files contained in the folder and to be used in the loading loop
                    Iniciolfiles = lfiles[0]                                    # Detects the numeric value of the "Start" in the name
                    Finlfiles = lfiles[-1]                                      # Detects the numerical value of the "End" in the name
                    Indice1 = Iniciolfiles.rfind('.')                           # Determines the index, which will be marked by the dot at the end for the extension
                    Nombre3 = Iniciolfiles[0:Indice1]                           # Indicates the name of the file in str (minus) the index or extension (each day)

                    # Data entry from labels and fields or text boxes (this value is a string by default)

                    frecMin = (self.lineEdit_10.text())                          # Minimum Frequency, Filter 1 label reading.
                    frecMax = (self.lineEdit_11.text())                          # Maximum Frequency, Filter 1 label reading.

                    frecMin2 = (self.lineEdit_12.text())                          # Minimum Frequency, Filter 2 label reading.
                    frecMax2 = (self.lineEdit_13.text())                          # Maximum Frequency, Filter 2 label reading.

                    frecMin3 = (self.lineEdit_14.text())                          # Minimum Frequency, Filter 3 label reading.
                    frecMax3 = (self.lineEdit_15.text())                          # Maximum Frequency, Filter 3 label reading.

                    frecMin4 = (self.lineEdit_16.text())                          # Minimum Frequency, Filter 4 label reading.
                    frecMax4 = (self.lineEdit_17.text())                          # Maximum Frequency, Filter 4 label reading.

                    frecMin5 = (self.lineEdit_18.text())                          # Minimum Frequency, Filter 5 label reading.
                    frecMax5 = (self.lineEdit_19.text())                          # Maximum Frequency, Filter 5 label reading.

                    orden1 = (self.lineEdit_4.text())                           # Reading the Filter Order Label.

                    # Data entry for enveloped (this value is a string by default)
                    Tam = (self.lineEdit_20.text())                             # Reading the envelope window size label.
                    Tsua = (self.lineEdit_21.text())                             # Reading the Smoothing type label.
                    Tnan = (self.lineEdit_22.text())                            # Reading the NaN Tolerance label.

                    # Convert the string value of the input text boxes to float or integer
                    frecMinB=float(frecMin)                                     # Converts Minimum Frequency, Filter 1 value to float.
                    frecMaxB=float(frecMax)                                     # Converts Maximum Frequency, Filter 1 value to float.

                    frecMin2B=float(frecMin2)                                   # Converts Minimum Frequency, Filter 2 value to float.
                    frecMax2B=float(frecMax2)                                   # Converts Maximum Frequency, Filter 2 value to float.

                    frecMin3B=float(frecMin3)                                   # Converts Minimum Frequency, Filter 3 value to float.
                    frecMax3B=float(frecMax3)                                   # Converts Maximum Frequency, Filter 3 value to float.

                    frecMin4B=float(frecMin4)                                   # Converts Minimum Frequency, Filter 4 value to float.
                    frecMax4B=float(frecMax4)                                   # Converts Maximum Frequency, Filter 4 value to float.

                    frecMin5B=float(frecMin5)                                   # Converts Minimum Frequency, Filter 5 value to float.
                    frecMax5B=float(frecMax5)                                   # Converts Maximum Frequency, Filter 5 value to float.

                    orden4=int(orden1)                                          # Converts filter order value to integer.

                    Tam1=int(Tam)                                               # Converts the envelope window size value to integer.
                    Tsua1=int(Tsua)                                             # Converts the Smoothing type value to integer.
                    Tnan1=int(Tnan)                                             # Converts the NaN Tolerance value to integer.

                    timeIn = 365

                    TM = str(Tam1)                                              # Coverts the windows size to string to put in plot label

                    # Function for Shannon entropy calculating
                    def calcular_entropia(datos):
                        params = stats.norm.fit(datos)
                        dist = stats.norm(*params)
                        probabilidades = dist.pdf(datos)
                        entropia = -np.sum(probabilidades * np.log2(probabilidades))
                        return entropia

                    # Function for Shannon entropy enveloped calculating
                    def nanfastsmooth(Y, w, type=1, tol=0.5):

                        """
                        Smooths vector Y with a moving average of width w, ignoring NaNs in data.

                        Parameters:
                        Y (numpy array): Input signal.
                        w (int): Window width.
                        type (int): Smooth type (1 for rectangular, 2 for triangular, 3 for pseudo-Gaussian).
                        tol (float): Tolerance to NaNs between 0 and 1.

                        Returns:
                        numpy array: Smoothed signal.
                        """
                        mask = ~np.isnan(Y)  # Create a boolean mask for non-NaN values
                        Y[mask] = nanfastsmooth_core(Y[mask], w, type, tol)  # Apply smoothing to non-NaN values
                        return Y

                    # Function for Shannon entropy enveloped type calculating. For default the value = 3
                    def nanfastsmooth_core(Y, w, type, tol):
                        if type == 1:
                            SmoothY = moving_average(Y, w)
                        elif type == 2:
                            SmoothY = moving_average(moving_average(Y, w), w)
                        elif type == 3:
                            SmoothY = moving_average(moving_average(moving_average(Y, w), w), w)

                        return SmoothY

                    def moving_average(Y, window_size):
                        return np.convolve(Y, np.ones(window_size)/window_size, mode='same')

                    def apply_bandpass_filter(datos, frecuencia_muestreo, freq_band):
                        nyquist = 0.5 * frecuencia_muestreo
                        normal_freq_band = np.array(freq_band) / nyquist
                        b, a = signal.butter(4, normal_freq_band, btype='band')
                        datos_filtrados = signal.filtfilt(b, a, datos)
                        return datos_filtrados

                    # Start entropy and averaged entropy values
                    entropia_shannon = []
                    entropia_promediada = []

                    entropia_shannon2 = []
                    entropia_promediada2 = []

                    entropia_shannon3 = []
                    entropia_promediada3 = []

                    entropia_shannon4 = []
                    entropia_promediada4 = []

                    entropia_shannon5 = []
                    entropia_promediada5 = []

                    # Cycle for the day-by-day calculation of the entropy in the files contained in the folder, using the time range (Start to End)
                    for dia in range(1, timeIn + 1):

                        archivo = Nombre3 + '.'+ f"{dia:003}"       # Here you select the name previously calculated plus point and the value of each Julian day

                        # If there is no file in the list, the entire day is added with a value of zero
                        if not os.path.exists(os.path.join(carpeta, archivo)):
                            for _ in range(24):  # AÃ±ade 24 horas con valor cero si no hay archivo
                                entropia_shannon.append(0)
                                entropia_promediada.append(0)
                            continue

                        elif not os.path.exists(os.path.join(carpeta, archivo)):
                            for _ in range(24):  # AÃ±ade 24 horas con valor cero si no hay archivo
                                entropia_shannon2.append(0)
                                entropia_promediada2.append(0)
                            continue

                        elif not os.path.exists(os.path.join(carpeta, archivo)):
                            for _ in range(24):  # AÃ±ade 24 horas con valor cero si no hay archivo
                                entropia_shannon3.append(0)
                                entropia_promediada3.append(0)
                            continue

                        elif not os.path.exists(os.path.join(carpeta, archivo)):
                            for _ in range(24):  # AÃ±ade 24 horas con valor cero si no hay archivo
                                entropia_shannon4.append(0)
                                entropia_promediada4.append(0)
                            continue

                        elif not os.path.exists(os.path.join(carpeta, archivo)):
                            for _ in range(24):  # AÃ±ade 24 horas con valor cero si no hay archivo
                                entropia_shannon5.append(0)
                                entropia_promediada5.append(0)
                            continue

                        # CreaciÃ³n de st para la lectura del fichero
                        st = Stream()
                        st += read(os.path.join(carpeta, archivo))

                        # CreaciÃ³n de st2 para la lectura del fichero
                        st2 = Stream()
                        st2 += read(os.path.join(carpeta, archivo))

                        # CreaciÃ³n de st3 para la lectura del fichero
                        st3 = Stream()
                        st3 += read(os.path.join(carpeta, archivo))

                        # CreaciÃ³n de st4 para la lectura del fichero
                        st4 = Stream()
                        st4 += read(os.path.join(carpeta, archivo))

                        # CreaciÃ³n de st5 para la lectura del fichero
                        st5 = Stream()
                        st5 += read(os.path.join(carpeta, archivo))

                        # calculation of the bandstop filter with the parameters indicated by the user.

                        st.filter('bandstop', freqmin=frecMinB, freqmax=frecMaxB, corners=4, zerophase=True)

                        st2.filter('bandstop', freqmin=frecMin2B, freqmax=frecMax2B, corners=4, zerophase=True)

                        st3.filter('bandstop', freqmin=frecMin3B, freqmax=frecMax3B, corners=4, zerophase=True)

                        st4.filter('bandstop', freqmin=frecMin4B, freqmax=frecMax4B, corners=4, zerophase=True)

                        st5.filter('bandstop', freqmin=frecMin5B, freqmax=frecMax5B, corners=4, zerophase=True)

                        # Datos para st
                        datos = st[0].data

                        # Datos2 para st2
                        datos2 = st2[0].data

                        # Datos3 para st3
                        datos3 = st3[0].data

                        # Datos4 para st4
                        datos4 = st4[0].data

                        # Datos5 para st5
                        datos5 = st5[0].data

                        # Dividir los datos en horas y calcular entropÃ­a para cada hora con st
                        for hora in range(24*6):
                            inicio = hora * 600 * 100  # inicio de la hora en segundos
                            fin = inicio + 600 * 100  # fin de la hora en segundos
                            #datos_hora = diff[inicio:fin]
                            datos_hora = datos[inicio:fin]

                            if len(datos_hora) < 600 * 100:  # Si la hora estÃ¡ incompleta, agregar ceros al final
                                datos_hora = np.append(datos_hora, np.zeros(600 * 100 - len(datos_hora)))

                            entropia_shannon.append(calcular_entropia(datos_hora))
                            entropia_promediada.append(calcular_entropia(datos_hora) / len(datos_hora))

                        # Dividir los datos en horas y calcular entropÃ­a para cada hora con st2
                        for hora in range(24*6):
                            inicio = hora * 600 * 100  # inicio de la hora en segundos
                            fin = inicio + 600 * 100  # fin de la hora en segundos
                            datos_hora2 = datos2[inicio:fin]

                            if len(datos_hora2) < 600 * 100:  # Si la hora estÃ¡ incompleta, agregar ceros al final
                                datos_hora2 = np.append(datos_hora2, np.zeros(600 * 100 - len(datos_hora2)))

                            entropia_shannon2.append(calcular_entropia(datos_hora2))
                            entropia_promediada2.append(calcular_entropia(datos_hora2) / len(datos_hora2))

                        # Dividir los datos en horas y calcular entropÃ­a para cada hora con st3
                        for hora in range(24*6):
                            inicio = hora * 600 * 100  # inicio de la hora en segundos
                            fin = inicio + 600 * 100  # fin de la hora en segundos
                            datos_hora3 = datos3[inicio:fin]

                            if len(datos_hora3) < 600 * 100:  # Si la hora estÃ¡ incompleta, agregar ceros al final
                                datos_hora3 = np.append(datos_hora3, np.zeros(600 * 100 - len(datos_hora3)))

                            entropia_shannon3.append(calcular_entropia(datos_hora3))
                            entropia_promediada3.append(calcular_entropia(datos_hora3) / len(datos_hora3))

                        # Dividir los datos en horas y calcular entropÃ­a para cada hora con st4
                        for hora in range(24*6):
                            inicio = hora * 600 * 100  # inicio de la hora en segundos
                            fin = inicio + 600 * 100  # fin de la hora en segundos
                            datos_hora4 = datos4[inicio:fin]

                            if len(datos_hora4) < 600 * 100:  # Si la hora estÃ¡ incompleta, agregar ceros al final
                                datos_hora4 = np.append(datos_hora4, np.zeros(600 * 100 - len(datos_hora4)))

                            entropia_shannon4.append(calcular_entropia(datos_hora4))
                            entropia_promediada4.append(calcular_entropia(datos_hora4) / len(datos_hora4))

                        # Dividir los datos en horas y calcular entropÃ­a para cada hora con st5
                        for hora in range(24*6):
                            inicio = hora * 600 * 100  # inicio de la hora en segundos
                            fin = inicio + 600 * 100  # fin de la hora en segundos
                            datos_hora5 = datos5[inicio:fin]

                            if len(datos_hora5) < 600 * 100:  # Si la hora estÃ¡ incompleta, agregar ceros al final
                                datos_hora5 = np.append(datos_hora5, np.zeros(600 * 100 - len(datos_hora5)))

                            entropia_shannon5.append(calcular_entropia(datos_hora5))
                            entropia_promediada5.append(calcular_entropia(datos_hora5) / len(datos_hora5))


                    # CreaciÃ³n del array de la entropia normal y la promediada de Shannon para st1
                    entropia_shannon = np.array(entropia_shannon)
                    entropia_promediada = np.array(entropia_promediada)

                    # CreaciÃ³n del array de la entropia normal y la promediada de Shannon para st2
                    entropia_shannon2 = np.array(entropia_shannon2)
                    entropia_promediada2 = np.array(entropia_promediada2)

                    # CreaciÃ³n del array de la entropia normal y la promediada de Shannon para st3
                    entropia_shannon3 = np.array(entropia_shannon3)
                    entropia_promediada3 = np.array(entropia_promediada3)

                    # CreaciÃ³n del array de la entropia normal y la promediada de Shannon para st4
                    entropia_shannon4 = np.array(entropia_shannon4)
                    entropia_promediada4 = np.array(entropia_promediada4)

                    # CreaciÃ³n del array de la entropia normal y la promediada de Shannon para st4
                    entropia_shannon5 = np.array(entropia_shannon5)
                    entropia_promediada5 = np.array(entropia_promediada5)

                    # Graficar los vectores en figuras separadas
                    dias = np.arange(1, 8761*6+1)

                    # GrÃ¡fico de EntropÃ­a de Shannon

                    indices_no_cero_shannon = np.where(entropia_shannon != 0)[0]
                    indices_no_cero_shannon2 = np.where(entropia_shannon2 != 0)[0]
                    indices_no_cero_shannon3 = np.where(entropia_shannon3 != 0)[0]
                    indices_no_cero_shannon4 = np.where(entropia_shannon4 != 0)[0]
                    indices_no_cero_shannon5 = np.where(entropia_shannon5 != 0)[0]

                    # Use example
                    Y = entropia_shannon
                    Y = np.where(Y == 0, np.nan, Y)

                    Y1 = entropia_shannon2
                    Y1 = np.where(Y1 == 0, np.nan, Y1)

                    Y2 = entropia_shannon3
                    Y2 = np.where(Y2 == 0, np.nan, Y2)

                    Y3 = entropia_shannon4
                    Y3 = np.where(Y3 == 0, np.nan, Y3)

                    Y4 = entropia_shannon5
                    Y4 = np.where(Y4 == 0, np.nan, Y4)

                    # Plot the vectors into separate figures.

                    # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE. *** The median filter function is used ***  PARA st1

                    y_filtered = nanfastsmooth(Y.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original

                    # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE. *** The median filter function is used ***  PARA st2
                    y_filtered2 = nanfastsmooth(Y1.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original   # By default work with size=50

                    # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE. *** The median filter function is used ***  PARA st3
                    y_filtered3 = nanfastsmooth(Y2.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original   # By default work with size=50

                    # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE. *** The median filter function is used ***  PARA st4
                    y_filtered4 = nanfastsmooth(Y3.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original   # By default work with size=50

                    # CALCULATION OF THE VALUE OF THE FILTER FOR THE ENVELOPE. *** The median filter function is used ***  PARA st5
                    y_filtered5 = nanfastsmooth(Y4.copy(), Tam1, Tsua1, Tnan1)  # A copy of Y is created, in order to avoid modifying the original   # By default work with size=50


                    # *** PRESENT THE ENTROPY AND THE ENVELOPE GRAPHICS  ***

                    # Graph 4 - Envelope only graph.

                    fig, ax = plt.subplots() # To put several plot in same graphics.

                    ax.plot(dias[indices_no_cero_shannon], y_filtered[indices_no_cero_shannon], label='Filter Bandstop [ ' + str(frecMinB) + ' - ' + str(frecMaxB) + ' ] Hz.', color='darkblue')

                    ax.plot(dias[indices_no_cero_shannon], y_filtered2[indices_no_cero_shannon2], label='Filter Bandstop [ ' + str(frecMin2B) + ' - ' + str(frecMax2B) + ' ] Hz.', color='red')

                    ax.plot(dias[indices_no_cero_shannon], y_filtered3[indices_no_cero_shannon3], label='Filter Bandstop [ ' + str(frecMin3B) + ' - ' + str(frecMax3B) + ' ] Hz.', color='darkgreen')

                    ax.plot(dias[indices_no_cero_shannon], y_filtered4[indices_no_cero_shannon4], label='Filter Bandstop [ ' + str(frecMin4B) + ' - ' + str(frecMax4B) + ' ] Hz.', color='darkorange')

                    ax.plot(dias[indices_no_cero_shannon], y_filtered5[indices_no_cero_shannon5], label='Filter Bandstop [ ' + str(frecMin5B) + ' - ' + str(frecMax5B) + ' ] Hz.', color='darkgoldenrod')

                    plt.legend(prop = {'size': 10}, loc='upper right')          # Para colocar la leyenda a la izquierda
                    plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                    plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                    plt.title(Nombre3 + '_Envelope of Shannon entropy - Each point = 10 min. with Bandstop filter.' + " Envelope Windows = " + TM, color ="darkgreen", fontsize=12)

                    # Grahps with dots.

                    fig, ax = plt.subplots() # To put several plot in same graphics.

                    ax.plot(dias[indices_no_cero_shannon], entropia_shannon[indices_no_cero_shannon], "o", mfc="darkblue", mec = "darkblue", label='Filter Bandstop [ ' + str(frecMinB) + ' - ' + str(frecMaxB) + ' ] Hz.', color='darkblue')

                    ax.plot(dias[indices_no_cero_shannon], entropia_shannon2[indices_no_cero_shannon2], "o", mfc="red", mec = "red", label='Filter Bandstop [ ' + str(frecMin2B) + ' - ' + str(frecMax2B) + ' ] Hz.', color='red')

                    ax.plot(dias[indices_no_cero_shannon], entropia_shannon3[indices_no_cero_shannon3], "o", mfc="darkgreen", mec = "darkgreen", label='Filter Bandstop [ ' + str(frecMin3B) + ' - ' + str(frecMax3B) + ' ] Hz.', color='darkgreen')

                    ax.plot(dias[indices_no_cero_shannon], entropia_shannon4[indices_no_cero_shannon4], "o", mfc="r", mec = "r", label='Filter Bandstop [ ' + str(frecMin4B) + ' - ' + str(frecMax4B) + ' ] Hz.', color='darkorange')

                    ax.plot(dias[indices_no_cero_shannon], entropia_shannon5[indices_no_cero_shannon5], "o", mfc="darkgoldenrod", mec = "darkgoldenrod", label='Filter Bandstop [ ' + str(frecMin5B) + ' - ' + str(frecMax5B) + ' ] Hz.', color='darkgoldenrod')

                    plt.legend(prop = {'size': 10}, loc='upper right')          # Para colocar la leyenda a la izquierda
                    plt.xlabel('Date', fontfamily="serif", fontweight='bold', color ="red", fontsize=18)
                    plt.ylabel(r"Entropy H(X) =  " r"$-\sum_{i=1}^n p(x_i)log_2p(x_i)$", fontsize=20, color='blue')
                    plt.title(Nombre3 + '_Envelope of Shannon entropy - Each point = 10 min. with Bandstop filter.' + " Envelope Windows = " + TM  , color ="darkgreen", fontsize=12)

                    plt.show()


        except:                         # In any other case of invalid or empty inputs
                plt.close()                                                 # Close the existing chart.
                msgBox = QMessageBox()
                msgBox.setIcon(QMessageBox.Warning)
                msgBox.setText("The File Does not exist, is Invalid or the Format is not recognized. Please, try again ... ...")
                msgBox.setWindowTitle("Invalid input parameter or registry file")
                returnValue = msgBox.exec()
                pass



    """ Function to go back at home (Main Menu) """

    def Back1(self):                                                        # Call function to Menu Module (Back)
        if sistema == "Windows":                                            # If the system is Windows
            plt.close()                                                     # Close the existing chart.
            subprocess.Popen(["python", "Menu1.py"])
            app.quit()
            #print("We are in {}".format(sistema))
        else:                                                               # If the system is Linux
            plt.close()                                                     # Close the existing chart
            subprocess.Popen(["python3", "Menu1.py"])
            app.quit()

    """  Fuction to exit system  """

    def Exit1(self):                                # Call function to show exit dialog box
        msg = QMessageBox()
        msg.setIcon(QMessageBox.Question)
        msg.setWindowTitle("Exit Envelope Entropy Filter")
        msg.setText("Are you sure to exit the Envelope Entropy Filter?")
        msg.setStandardButtons(QMessageBox.Ok | QMessageBox.Cancel)
        msg.setDefaultButton(QMessageBox.Ok)                            # By default, the focus is on the OK button
        returnValue = msg.exec()
        if returnValue == QMessageBox.Ok:                               # If the answer is OK
            app.closeAllWindows()                                       # Close all windows and exit
            app.quit()


if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())
    # Developed by: Ligdamis A. GutiÃ©rrez E. PhD.
    # Shannon Entropy Work by Pablo Rey D.
